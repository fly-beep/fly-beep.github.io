

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="顾海耀">
  <meta name="keywords" content="">
  
    <meta name="description" content="对软件工程与工具课程的主要内容进行总结">
<meta property="og:type" content="article">
<meta property="og:title" content="软件过程与工具">
<meta property="og:url" content="https://fly-beep.top/post/f6d9959d.html">
<meta property="og:site_name" content="Fly-beep&#39;s Blog">
<meta property="og:description" content="对软件工程与工具课程的主要内容进行总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fly-beep.top/img/fgx.jpg">
<meta property="article:published_time" content="2022-03-24T06:32:39.000Z">
<meta property="article:modified_time" content="2022-05-30T08:10:13.520Z">
<meta property="article:author" content="顾海耀">
<meta property="article:tag" content="软件过程与工具">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://fly-beep.top/img/fgx.jpg">
  
  
  <title>软件过程与工具 - Fly-beep&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"fly-beep.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"9SDM4ZdpdF76KYx9z9yK89zC-MdYXbMMI","app_key":"OiJBGDhFh3KBbnMdv3G0Wf45","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>fly-beep</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="软件过程与工具">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-24 14:32" pubdate>
        2022年3月24日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      157 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">软件过程与工具</h1>
            
            <div class="markdown-body">
              <p>对软件工程与工具课程的主要内容进行总结</p>
<span id="more"></span>
<h1 id="软件过程与工具">软件过程与工具</h1>
<h2 id="概述">1.概述🥡</h2>
<h3 id="软件的基本概念">1.1 软件的基本概念</h3>
<ul>
<li>1.1.1 什么是软件
<ul>
<li>软件：一组对象或项目所形成的一个“配置”，由<strong>程序、文档和数据</strong>构成。</li>
<li>“变化”是永恒的主题</li>
</ul></li>
<li>1.1.2 软件的发展
<ul>
<li>面向构件的软件 = 构件 + 框架</li>
<li>面向服务的软件 = 服务 + 消息 + 总线</li>
</ul></li>
</ul>
<h3 id="软件工程的基本概念">1.2 软件工程的基本概念</h3>
<ul>
<li>1.2.1 软件工程产生的历史根源</li>
<li>1.2.2 软件工程的基本概念</li>
<li>1.2.3 软件工程的知识体系</li>
</ul>
<h3 id="软件工程工具">1.3 软件工程工具</h3>
<ul>
<li>1.3.1 CASE工具</li>
</ul>
<h2 id="软件过程核心思想">2.软件过程核心思想😶‍🌫️</h2>
<h3 id="软件工程的本质不同抽象层次之间的映射与转换">2.1
软件工程的本质：不同抽象层次之间的映射与转换</h3>
<ul>
<li><p>任何软件系统开发的共同本质在于：<strong>从现实空间的需求到计算机空间的软件代码之间的映射与转换</strong></p></li>
<li><p>单步映射与多步映射</p>
<p><img
src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337499.png" srcset="/img/loading.gif" lazyload /></p>
<p>如上图所示，黑色虚线是正确的实现途径，红色是实际的实现途径（单步映射），蓝色也是实际的实现途径（多步映射）</p>
<ul>
<li>软件工程本质：用严格的规范和管理手段来缩小偏差，通过牺牲“时间”来提高“质量”</li>
</ul></li>
<li><p>软件工程的两个映射</p>
<ul>
<li>概念映射：问题空间的概念与解空间的模型化概念之间的映射
<ul>
<li>“学生” <span class="math inline">\(\rightarrow Class Student (No,
Name, Dept, Grade)\)</span></li>
</ul></li>
<li>业务逻辑映射：问题空间的处理逻辑与解空间处理逻辑之间的映射
<ul>
<li>计算某班学生平均分数→</li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">calculateAverageScore</span> <span class="hljs-params">(Struct [] scores)</span> <br>&#123;<br>    检索;<br>    计算平均分算法;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>软件工程：不同抽象层次之间的映射过程</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337315.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p>现实空间的需求<span class="math inline">\(\rightarrow\)</span>
需求规约<span class="math inline">\(\rightarrow\)</span> 设计规约<span
class="math inline">\(\rightarrow\)</span> 代码</p></li>
</ul>
<h3 id="软件工程所关注的目标">2.2 软件工程所关注的目标</h3>
<ul>
<li><p>软件工程所关注的对象</p>
<ul>
<li><p>产品：各个抽象层次的产出物</p></li>
<li><p>过程：在各个抽象层次之间进行映射和转换</p>
<p>“产品与过程二相性”：要把二者结合起来去考虑，而不能忽略其中任何一方</p></li>
</ul></li>
<li><p>软件工程所关注的目标</p>
<ol type="1">
<li>功能性需求：软件所实现的功能达到它的设计规范和满足用户需求的程度
<ul>
<li>完备性、正确性（描述软件在需求范围之内的行为）、健壮性（描述软件在需求范围之外的行为）、可靠性</li>
</ul></li>
<li>非功能性需求：系统能够完成所期望的工作的性能与质量
<ul>
<li>效率、可用性、可维护性、可移植性、清晰性、安全性、兼容性、经济性、商业质量</li>
</ul></li>
<li>不同目标之间的关系：折中</li>
</ol></li>
</ul>
<h3 id="软件开发中的多角色">2.3 软件开发中的多角色</h3>
<h3 id="软件工程-最佳实践">2.4 软件工程 = 最佳实践</h3>
<p><del>（当你把所有错误都犯过之后，你就是正确的了）</del></p>
<h3 id="软件工程的四个核心理论概念">2.5 软件工程的四个核心理论概念</h3>
<ul>
<li>分治</li>
<li>复用</li>
<li>折中</li>
<li>演化
<ul>
<li>软件系统在其生命周期中面临各种变化</li>
<li>可修改性、可维护性、可扩展性</li>
</ul></li>
</ul>
<h2 id="软件过程模型">3.软件过程模型📮</h2>
<h3 id="软件过程">3.1 软件过程</h3>
<ul>
<li><p>黑盒过程和白盒过程</p>
<p>将整个软件开发过程看成一个黑盒，而在实际软件开发中要在黑盒中留出白盒进行反馈（<span
class="math inline">\(feedback\)</span>）</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337643.png" srcset="/img/loading.gif" lazyload  style="zoom:80%;" /></p></li>
</ul>
<h3 id="典型软件过程模型">3.2 典型软件过程模型</h3>
<h4 id="瀑布模型">3.2.1 瀑布模型</h4>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337802.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>过程：从上一项活动接收该项活动的工作对象作为输入，利用这一输入实施该项活动应完成的内容给出该项活动的工作成果，并作为输出传给下一项活动。同时评审该项活动的实施，若确认，则继续下一项活动；否则返回前面，甚至更前面的活动（但是这种回溯非常困难）</p>
<p>每个阶段都有里程碑和提交物。</p>
<ul>
<li>优点：追求效率、能够逐步稳定的使项目向前发展</li>
<li>缺点：过于理想化、快速建立起来的系统结构可能会在后续的持续更改中导致软件质量低下、客户只有在末期才能得到可执行程序</li>
<li>适合场景：软件项目较小，各模块间接口定义非常清晰；需求在项目开始之前已经被全面的了解，产品的定义非常稳定；需求在开发中不太可能发生重大改变</li>
</ul>
<p>瀑布模型太理想化，太单纯，已不再适合现代的软件开发模式，在大型系统开发中已经很少使用。</p>
<h4 id="增量过程模型">3.2.2 增量过程模型</h4>
<p>无须等到所有需求都出来才进行开发，只要某个需求的核心部分出来，即可进行开发；可能迫切需要为用户迅速提供一套功能有限的软件产品，然后在后续版本中再细化和扩展功能。</p>
<ul>
<li><p>增量模型</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337609.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p><strong>本质：以迭代的方式运用瀑布模型</strong></p>
<p>当使用增量模型时，<strong>第1个增量往往是核心的产品</strong>，即第1个增量实现了基本的需求，但很多补充的特征还没有发布。客户对每一个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。<strong>增量模型强调每一个增量均发布一个可操作的产品。</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">例：开发一个类似于Word的字处理软件<br><span class="hljs-code">	增量1：提供基本的文件管理、编辑和文档生成功能</span><br><span class="hljs-code">	增量2：提供高级的文档编辑功能</span><br><span class="hljs-code">	增量3：实现拼写和语法检查功能</span><br><span class="hljs-code">	增量4：完成高级的页面排版功能</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>优点：能够快速推出软件产品，满足客户需求，对客户有一定的镇定作用、不用一下子投入太多资源。灵活性比较高</li>
<li>缺点：由于软件其他构件是后期加入的，容易导致由于构件之间的不稳定从而使系统崩溃。</li>
</ul></li>
<li><p>快速应用程序开发(RAD)</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337170.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<ul>
<li>优点：<strong>侧重于短开发周期</strong>（一般为60~90天）的增量过程模型，是瀑布模型的高速变体，通过<strong>基于构件的构建方法</strong>实现快速开发；<strong>多个团队并行进行开发</strong>，但启动时间有先后，先启动团队的提交物将作为后启动团队的输入</li>
<li>缺点：</li>
<li><strong>需要大量的人力资源</strong>来创建多个相对独立的RAD团队；如果<strong>没有在短时间内为急速完成整个系统做好准备</strong>，RAD项目将会失败；如果<strong>系统不能被合理的模块化</strong>，RAD将会带来很多问题；<strong>技术风险很高的情况下</strong>（采用很多新技术、软件需与其他已有软件建立集成等等），不宜采用RAD</li>
</ul></li>
<li><p>增量模型和RAD模型区别：增量模型要求后来的增量不能对之前的系统结构进行破坏</p></li>
</ul>
<h4 id="演化过程模型">3.2.3 演化过程模型</h4>
<p>需求的变更频繁，要求在非常短的期限内实现，以充分满足客户/用户要求、及时投入市场</p>
<p>本质：循环、反复、不断调整当前系统以适应需求变化</p>
<p>由于构建产品所需的周期数据不确定，给项目管理带来困难；演化速度太快，项目陷入混乱；演化速度太慢，影响生产率；为追求软件的高质量而牺牲了开发速度、灵活性和可扩展性</p>
<ul>
<li><p>快速原型法</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337551.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337539.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<ul>
<li><p>原型的分类</p>
<ul>
<li><p>抛弃式原型</p>
<p>最初的原型在完成并得到用户认可之后，将不会作为交付给用户的最终系统的一部分，而是被抛弃，其目的只是为了收集与验证需求</p>
<p><strong>该类原型是不可执行的</strong></p></li>
<li><p>演化式模型</p>
<p>最初构造的原型将具备较高的质量，包含了系统的核心功能，然后通过收集需求对其进行不断的改善和精化</p>
<p><strong>该类原型是可执行的，将成为最终系统的一部分</strong></p></li>
</ul></li>
<li><p>优点：提高和改善客户/用户的参与程度，最大程度的响应用户需求的变化</p></li>
<li><p>缺点：设计原型时未考虑整体软件质量和长期的可维护性，系统结构较差；混淆原型系统和最终系统；额外的开发费用</p></li>
</ul></li>
<li><p>螺旋模型</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337809.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p>制定计划<span class="math inline">\(\rightarrow\)</span>
风险分析<span class="math inline">\(\rightarrow\)</span>实施工程<span
class="math inline">\(\rightarrow\)</span>客户评价<span
class="math inline">\(\rightarrow\)</span>制定计划<span
class="math inline">\(\rightarrow\)</span>...</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">例：<br>第1圈：开发出产品的规格说明<br>第2圈：开发产品的原型系统<br>第3~n圈：不断的迭代，开发不同的软件版本<br>根据每圈交付后用户的反馈来调整预算、进度、需要迭代的次数<br></code></pre></div></td></tr></table></figure>
<p><strong>与增量、RAD等的最大区别在于重视风险评估</strong></p>
<ul>
<li>出发点：开发过程中及时识别和分析风险，并采取适当措施以消除或减少风险带来的危害</li>
<li>优点：结合了原型的迭代性质与瀑布模型的系统性和可控性，是一种<strong>风险驱动型的过程模型</strong></li>
<li>缺点：周期长，成本高，软件开发人员应该擅长寻找可能的风险</li>
</ul></li>
</ul>
<h4 id="其他过程模型">3.2.4 其他过程模型</h4>
<ul>
<li>形式化过程</li>
<li>软件复用过程</li>
</ul>
<h3 id="案例分析">3.3 案例分析</h3>
<h2 id="敏捷方法与过程">4.敏捷方法与过程🎑</h2>
<h4 id="敏捷过程模型">4.1 敏捷过程模型</h4>
<p>开发过程中<strong>“变化”</strong>是无处不在的，要将<strong>“变化”</strong>的意识贯穿在每一项开发活动中。</p>
<p><strong>“小步快跑，及时反馈”</strong></p>
<p>本质：<strong>以快速的增量和迭代方式进行软件开发</strong></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337761.png" srcset="/img/loading.gif" lazyload style="zoom:75%;" /></p>
<p>敏捷过程中最重要的因素：<strong>人</strong></p>
<h4 id="极限编程xp">4.2 极限编程(XP)</h4>
<p>planning(用户故事User story) → design(测试驱动的开发TDD) →
coding(结对编程Pair programming) → test(持续集成Continuous
instegration)</p>
<ul>
<li><p>XP planning</p>
<p>用户故事：<strong>客户</strong>为用户故事指定<strong>优先级</strong>，<strong>XP团队</strong>为用户故事指定<strong>成本</strong></p>
<p>将若干个用户故事指定为<strong>下一次发布的增量</strong></p>
<p>规划<strong>整体进度</strong></p></li>
<li><p>XP design</p>
<p>遵循<span class="math inline">\(KIS(Keep\ It\
Simple)\)</span>原则</p>
<p>设计模型：面向对象方法，<span
class="math inline">\(CRC\)</span>卡片</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337682.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p>遇到困难问题：创建原型</p>
<p>对设计方案不断<strong>重构</strong></p></li>
<li><p>XP coding &amp; test</p>
<p>测试驱动的开发<span class="math inline">\((TDD):\)</span></p>
<ul>
<li><p>编码前设计<strong>单元测试用例</strong></p></li>
<li><p><strong>结对编程</strong></p>
<ul>
<li><p>驾驶员：控制键盘输入的人</p></li>
<li><p>领航员：起到领航，提醒的作用</p></li>
<li><p>驾驶员和领航员不断轮换角色，不宜连续工作超过一小时；领航员要控制时间</p></li>
<li><p>主动参与、只有水平上的差距，没有级别上的差异</p></li>
<li><p>程序各方面的质量取决于<strong>一对程序员中各方面水平较高的那一位</strong></p></li>
</ul></li>
</ul></li>
</ul>
<p>何以谓“极限”：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337950.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<h4 id="scrum">4.3 Scrum</h4>
<p>整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个<span
class="math inline">\(Sprint\)</span>，每个<span
class="math inline">\(Sprint\)</span>的建议长度是2到4周</p>
<p>使用产品列表<span class="math inline">\(Product\
Backlog\)</span>来管理需求，产品列表<span class="math inline">\(Product\
Backlog\)</span>是一个按照商业价值排序的需求列表，列表条目的体现形式通常为用户故事</p>
<p>先开发对于用户具有较高价值的需求</p>
<p>在<span class="math inline">\(Sprint\)</span>中，<span
class="math inline">\(Scrum\)</span>团队从产品列表<span
class="math inline">\(Product\
Backlog\)</span>中挑选最高优先级的需求进行开发；挑选的需求在<span
class="math inline">\(Sprint\)</span>计划会议上经过讨论、分析和估算得到相应的任务列表(<span
class="math inline">\(Sprint\ backlog\)</span>)</p>
<p>在每个迭代结束时，<span
class="math inline">\(Scrum\)</span>团队将提交潜在可交付的产品增量</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211210103202604.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338325.png" srcset="/img/loading.gif" lazyload style="zoom:55%;" /></p>
<p><span class="math inline">\(Scrum\)</span>中的六项活动</p>
<ul>
<li><span class="math inline">\(Sprint\)</span>
(冲刺)：代表一个1-4周的迭代</li>
<li>发布计划会议<span class="math inline">\((Release\ Planning\
Meeting)\rightarrow\ Product\ Backlog\)</span></li>
<li><span class="math inline">\(Sprint\)</span>计划会议<span
class="math inline">\((Sprint\ Planning\ Meeting) \rightarrow\ Sprint\
Backlog\)</span></li>
<li>每日站会<span class="math inline">\((Daily\ Scrum\
Meeting)\)</span></li>
<li><span class="math inline">\(Sprint\)</span>评审会<span
class="math inline">\((Sprint\ Review\ Meeting)\)</span></li>
<li><span class="math inline">\(Sprint\)</span>回顾会议<span
class="math inline">\((Sprint\ Retrospective\ Meeting)\)</span></li>
</ul>
<p>每日站会：</p>
<ul>
<li>我昨天做了什么<span class="math inline">\((What\ have\ you\ done\
since\ yesterday? )\)</span></li>
<li>我今天要做什么<span class="math inline">\((What\ are\ you\ planning\
to\ do\ today? )\)</span></li>
<li>我碰到了哪些问题<span class="math inline">\((Do\ you\ have\ any\
problems\ that\ would\ prevent\ you\ from\ accomplishing\ your\ goal\
?)\)</span></li>
</ul>
<p><span class="math inline">\(Sprint\ Burndown\
chart\)</span>：燃尽图，用于表示剩余工作量的工作图表，由横轴（X）和纵轴（Y）组成，横轴表示时间，纵轴表示工作量。这种图表可以直观的预测何时工作将全部完成。</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338703.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<h4 id="与传统开发过程模型的对比">4.4 与传统开发过程模型的对比</h4>
<ul>
<li>瀑布模型
<ul>
<li>将全部需求以整体方式向前推进，无迭代<br />
</li>
<li>基本模型</li>
</ul></li>
<li>增量模型
<ul>
<li>将需求分成多份，串行推进，无迭代</li>
<li>串行的瀑布</li>
</ul></li>
<li>RAD模型
<ul>
<li>将需求分成多份，并行推进，无迭代</li>
<li>并行的瀑布</li>
</ul></li>
<li>原型模型
<ul>
<li>迭代</li>
<li>基本模型</li>
</ul></li>
<li>螺旋模型
<ul>
<li>按瀑布阶段划分，各阶段分别迭代(原型+风险分析)</li>
<li>原型+瀑布</li>
</ul></li>
<li>敏捷模型
<ul>
<li>将需求分成尽量小的碎片，以碎片为单位进行高速迭代</li>
<li>增量+迭代</li>
</ul></li>
</ul>
<h4 id="敏捷案例分析">4.5 敏捷案例分析</h4>
<h4 id="总结">4.6总结</h4>
<ul>
<li><span class="math inline">\(XP\)</span>与<span
class="math inline">\(Scrum\)</span>区别
<ul>
<li>迭代长度的不同。<span class="math inline">\(XP\)</span>的一个<span
class="math inline">\(Sprint\)</span>的迭代长度大致为1~2周, 而<span
class="math inline">\(Scrum\)</span>的迭代长度一般为 2~ 4周。</li>
<li>在迭代中, 是否允许修改需求。<span
class="math inline">\(XP\)</span>在一个迭代中，如果一个用户故事还没有实现，
则可以考虑用另外的需求将其替换， 替换的原则是需求实现的时间量是相等的。
而<span
class="math inline">\(Scrum\)</span>是不允许这样做的，一旦迭代开工会完毕,
任何需求都不允许添加进来，并有<span class="math inline">\(Scrum\
Master\)</span>严格把关，不允许开发团队收到干扰。</li>
<li>在迭代中，用户故事是否严格按照优先级别来实现。<span
class="math inline">\(XP\)</span>是务必要遵守优先级别的。 但<span
class="math inline">\(Scrum\)</span>在这点做得很灵活，
可以不按照优先级别来做。</li>
<li>软件的实施过程中，是否采用严格的工程方法，保证进度或者质量。<span
class="math inline">\(Scrum\)</span>没有对软件的整个实施过程开出严格工程实践的处方，要求开发者自觉保证；但<span
class="math inline">\(XP\)</span>对整个流程方法定义非常严格，规定需要采用<span
class="math inline">\(TDD\)</span>,
自动测试，结对编程，简单设计，重构等约束团队的行为。</li>
</ul></li>
</ul>
<h2 id="软件项目管理">5.软件项目管理🦄</h2>
<p>软件项目的特征：</p>
<ul>
<li>不可见性</li>
<li>不确定性</li>
<li>多变化性</li>
<li>高技能及其高流通性</li>
</ul>
<h4 id="软件项目管理的案例">5.1 软件项目管理的案例</h4>
<p>软件项目管理的<span class="math inline">\(4P\)</span></p>
<ul>
<li>人员</li>
<li>产品</li>
<li>过程</li>
<li>项目</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338571.png" srcset="/img/loading.gif" lazyload/></p>
<h4 id="人员people">5.2 人员(People)</h4>
<p>软件开发团队的组织方式：</p>
<ul>
<li>一窝蜂模式</li>
<li>主治医师模式
<ul>
<li>明星模式</li>
</ul></li>
<li>社区模式
<ul>
<li>开源项目</li>
</ul></li>
<li>交响乐团模式
<ul>
<li>“工厂” <span class="math inline">\(\rightarrow\)</span>
“规格严格”</li>
</ul></li>
<li>爵士乐模式
<ul>
<li>类似于一群天才构成的敏捷团队<span
class="math inline">\(\rightarrow\)</span>“功夫到家”</li>
</ul></li>
<li>功能团队模式</li>
<li>官僚模式</li>
</ul>
<p>大型项目的技术管理组织结构</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338920.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338516.png" srcset="/img/loading.gif" lazyload  style="zoom:80%;" /></p>
<h4 id="产品product">5.3 产品(Product)</h4>
<p>确定软件范围<span class="math inline">\(\rightarrow\)</span>分治</p>
<p>产品结构分解<span class="math inline">\(PBS\)</span></p>
<ul>
<li>通过分层的树型结构来定义和组织<strong>项目范围内的所有产出物(产品)</strong>，自顶向下，逐级细分</li>
</ul>
<h4 id="过程process">5.4 过程(Process)</h4>
<p>选择合适的软件过程模型<span
class="math inline">\(\rightarrow\)</span>根据所选的过程模型，对其进行适应性修改<span
class="math inline">\(\rightarrow\)</span>确定过程中所包含的工作任务列表</p>
<p>工作结构分解<span class="math inline">\(WBS\)</span></p>
<ul>
<li>通过分层的树型结构来定义和组织<strong>工作任务之间的分解关系</strong>，自顶向下，逐级细分</li>
</ul>
<h4 id="项目project">5.5 项目(Project)</h4>
<p><span class="math inline">\(W^{5}HH\)</span>原则</p>
<ul>
<li><span class="math inline">\(Why\)</span> 为什么要开发这个系统？</li>
<li><span class="math inline">\(What\)</span> 将要做什么？</li>
<li><span class="math inline">\(When\)</span> 什么时候做？</li>
<li><span class="math inline">\(Who\)</span> 某功能由谁来做？</li>
<li><span class="math inline">\(Where\)</span> 机构组织位于何处？</li>
<li><span class="math inline">\(How\)</span>
如何完成技术与管理工作？</li>
<li><span class="math inline">\(How\ much\)</span>
各种资源分别需要多少？</li>
</ul>
<h4 id="可行性分析与估算">5.6 可行性分析与估算</h4>
<h4 id="项目进度计划与监控">5.7 项目进度计划与监控</h4>
<p>甘特图；描述任务的进度安排</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338913.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>下图是一张项目进度跟踪甘特图：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338810.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p><span class="math inline">\(T_{x}\)</span>标识<span
class="math inline">\(task\)</span>，<span
class="math inline">\(M_{x}\)</span>标识里程碑，白色标识各项目计划开始/结束日期，白色
+ 蓝色标识各项目实际开始/结束日期。</p>
<p><span
class="math inline">\(XP/Scrum\)</span>敏捷开发中的进度计划与监控</p>
<ul>
<li><p>以“迭代”为单位：每次迭代包含多少个用户故事或用例</p></li>
<li><p>每次迭代为30天左右</p></li>
<li><p>针对每个用户故事，团队成员联合估算和协商开发代价(时间)</p></li>
<li><p>使用任务墙(<span class="math inline">\(Task\
Board\)</span>)/燃尽图(<span class="math inline">\(Burndown\
Chart\)</span>)等作为进度监控工具，评估迭代的当前进展情况</p></li>
</ul>
<h2 id="软件演化与配置管理">6.软件演化与配置管理🍳</h2>
<h4 id="软件演化">6.1 软件演化</h4>
<p>软件演化的<span class="math inline">\(Lehman\)</span>定律</p>
<ul>
<li><p>持续变化：现实世界的系统要么变得越来越没有价值，要么进行持续不断的变化以适应环境的变化；环境变化产生软件修改，软件修改又继续促进环境变化</p></li>
<li><p>复杂度逐渐增大：当系统逐渐发生变化时，其结构和功能将变得越来越复杂，并逐渐难以维护并失去控制，直至无法继续演化，从而需要大量额外的资源和维护工作来保持系统的正常运行；软件修改会引入新的错误，造成故障率的升高</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211211095223736.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p></li>
</ul>
<p>软件演化的处理策略：</p>
<ul>
<li>软件维护：为了修改软件缺陷或增加新的功能而对软件进行的变更；软件变更通常发生在局部，不会改变整个结构</li>
<li>软件再工程：为了避免软件退化而对软件的一部分进行重新设计、编码和测试，提高软件的可维护性和可靠性等</li>
<li><strong>前者力度小</strong></li>
</ul>
<h4 id="软件维护">6.2 软件维护</h4>
<p>软件维护类型</p>
<ul>
<li>纠错性维护（开发中有错误）</li>
<li>适应性维护（外部环境和数据环境变化）</li>
<li>完善性维护（新的需求和要求）【占比最大】</li>
<li>预防性维护（减少或避免前三类维护所做的维护）</li>
</ul>
<p>软件维护内容：</p>
<ul>
<li>程序维护</li>
<li>数据维护</li>
<li>硬件维护</li>
</ul>
<h4 id="软件配置管理scm">6.3 软件配置管理(SCM)</h4>
<p><span
class="math inline">\(SCI\)</span>：软件配置项，软件配置的基本单位（文件）</p>
<p><span
class="math inline">\(SCM\)</span>贯穿整个软件生命周期与软件工程过程</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338393.png" srcset="/img/loading.gif" lazyload style="zoom:75%;" /></p>
<p><span
class="math inline">\(SCM\)</span>目标：当变更发生时，能够提高适应变更的容易程度，并且能够减少所花费的工作量</p>
<p><span class="math inline">\(SCM\)</span>基本元素：</p>
<ul>
<li><p>配置项<span class="math inline">\((CI)\)</span></p>
<p>软件过程的输出信息可以分为三个主要类别：程序、文档，数据。</p>
<p>软件配置项<span
class="math inline">\(SCI\)</span>：上述三项的总称，包含了所有在软件中产生的信息，<strong>是软件全生命周期内受管理和控制的基本单位</strong>，大到整个系统，小到某个硬件设备或软件模块</p>
<p><span class="math inline">\(SCI\)</span>具有唯一的名称和多个属性</p>
<p><span
class="math inline">\(CI\)</span>之间<strong>依赖关系</strong>：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338465.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>对每一个<span
class="math inline">\(CI\)</span>建立一个演变图，以记录对象的变更历史</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338247.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p></li>
<li><p>基线<span class="math inline">\((Baseline)\)</span></p>
<p>在软件配置项成为基线之前，可以迅速而随意的进行变更，一旦成为基线，<strong>变更时需要遵循正式的评审流程才可以变更</strong>，因此，基线可看作是软件开发过程中的“里程碑”</p>
<p>基线是在某个时间点上对产品属性的一致描述，它是定义变化的基础</p>
<p><span class="math inline">\(Version \geqslant Release \geqslant
Baseline \geqslant Milestone \geqslant checkpoint\)</span></p>
<p><span class="math inline">\(Version\)</span>：对外发布版本</p>
<p><span
class="math inline">\(Release\)</span>：不一定要对外发布，但对外发布版本一定是<span
class="math inline">\(Release\)</span></p>
<p><span class="math inline">\(Baseline\)</span>：不能改动</p>
<p><span class="math inline">\(Milestone\)</span>：里程碑</p>
<p><span
class="math inline">\(checkpoint\)</span>：检查点，最为灵活</p></li>
<li><p>配置管理数据库<span class="math inline">\((CMDB)\)</span></p>
<p>也称为<span
class="math inline">\(SCM\)</span>中心存储库，用于保存与软件相关的所有配置项的信息以及配置项之间关系的数据库</p>
<p><span class="math inline">\(\alpha
测试\)</span>：内部单用户在开发环境测试</p>
<p><span class="math inline">\(\beta
测试\)</span>：多用户在开发环境测试</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338613.png" srcset="/img/loading.gif" lazyload  style="zoom:80%;" /></p></li>
<li><p>最终硬件库<span class="math inline">\((DHS)\)</span></p></li>
<li><p>最终软件库<span class="math inline">\((DSL)\)</span></p></li>
</ul>
<h4 id="持续集成">6.4 持续集成</h4>
<p>敏捷开发的一项重要实践</p>
<p>集成：集成测试【集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。一些局部反映不出来的问题，在全局上很可能暴露出来。）】</p>
<p>所有的开发人员需要在本地机器上做本地构建，然后再提交到版本控制库中，从而确保他们的变更不会导致持续集成失败，开发人员每天至少向版本控制库中提交一次代码，开发人员每天至少需要从版本控制库中更新一次代码到本地机器。需要有专门的集成服务器来执行集成构建，每天要执行多次构建，每次构建都要<span
class="math inline">\(100
\%\)</span>通过，每次构建都可以生成可发布的产品，<strong>修复失败的构建是优先级最高的事情</strong></p>
<h4 id="本地-vs-分布式-版本控制系统">6.5 本地 vs 分布式
版本控制系统</h4>
<ul>
<li><p>本地版本控制系统(<span class="math inline">\(Local\
VCS\)</span>)</p>
<p>采用简单的数据库或文件系统来记录本地文件的历次更新差异</p></li>
<li><p>集中化版本控制系统<span class="math inline">\((Centralized\
VCS)\)</span></p>
<p>有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的开发者通过客户端连到这台服务器，取出最新的文件或者提交更新</p>
<p>缺点：单点故障，可靠性</p></li>
<li><p>分布式版本控制系统<span class="math inline">\((Distributed\
VCS)\)</span></p>
<p>客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来</p>
<p>任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p>
<p>每一次的提取操作，实际上都是一次对代码仓库的完整备份</p></li>
</ul>
<h4 id="git的基本思想">6.6 Git的基本思想</h4>
<p><span
class="math inline">\(git\)</span>关注文件数据整体是否发生变化而不是文件内容</p>
<ul>
<li><p>传统思路：存储每个文件与初始版本的差异</p>
<p><img
src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338587.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p><span
class="math inline">\(git\)</span>思路：存储项目随时间变化的快照（在本地磁盘保留项目的完整历史，以空间换时间）</p>
<p><img
src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338023.png" srcset="/img/loading.gif" lazyload /></p></li>
</ul>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211211134742881.png" srcset="/img/loading.gif" lazyload style="zoom:40%;" /></p>
<ul>
<li><span class="math inline">\(workspace\)</span>工作目录【已修改<span
class="math inline">\(modified\)</span>】</li>
<li><span
class="math inline">\(staging\)</span>暂存区（本地不占内存）【已暂存<span
class="math inline">\(stages\)</span>】：本质上是一个文件，保存了下次要提交的文件列表信息</li>
<li><span class="math inline">\(local\
repository\)</span>本地仓库【已提交<span
class="math inline">\(committed\)</span>】</li>
<li><span class="math inline">\(remote\ repository\)</span>远程仓库</li>
</ul>
<p><span class="math inline">\(git\)</span>工作流程</p>
<ul>
<li>在工作目录中修改某些文件</li>
<li>对修改后的文件进行快照，然后保存到暂存区域</li>
<li>提交更新，将保存在暂存区域的文件快照永久转储到Git目录中</li>
</ul>
<h4 id="基本git指令">6.7 基本Git指令</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git status<br>哪些更新未暂存？哪些更新已暂存？<br></code></pre></div></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git diff<br>比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容（修改之后但未加入暂存）<br></code></pre></div></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git diff --cached<br>比较的是暂存区域内的文件的更改（修改之后加入缓存但尚未提交）<br></code></pre></div></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git diff HEAD<br>查看已缓存和未缓存的所有差异<br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338492.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git commit -a<br>跳过git add<br></code></pre></div></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git reset<br>git add的反向操作,使得暂存区与仓库版本一致<br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338369.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>更改一次<span class="math inline">\(commit\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">1.git commit --amend<br>2.git reset HEAD^<br>^表示上一次提交<br></code></pre></div></td></tr></table></figure>
<h4 id="git远程仓库指令">6.8 Git远程仓库指令</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git fetch<br>从远程仓库抓取数据到本地，获取本地仓库尚未拥有的全部更新<br>如果本地仓库有了不同的修改，则需要手工将本地修改与远程仓库的修改合并起来<br>git merge<br>分支合并<br>git pull = git fetch + git merge<br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338982.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<h4 id="git分支指令">6.9 Git分支指令</h4>
<p><span class="math inline">\(git\)</span>分支本质：指向<span
class="math inline">\(commit\)</span>对象的可变指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git checkout -b xxx = git branch xxx + git checkout xxx<br>创建分支并跳转<br></code></pre></div></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/techflow/p/13876755.html"><span
class="math inline">\(git\)</span>分支</a></p>
<h4 id="远程分支">6.10 远程分支</h4>
<p>远程仓库只能看，不能修改</p>
<h4 id="使用git进行协同开发的实例">6.11 使用Git进行协同开发的实例</h4>
<h2 id="uml及建模工具">7. UML及建模工具🪂</h2>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338391.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>UML中事物：</p>
<ul>
<li>结构事物</li>
<li>行为事物</li>
<li>分组事物
<ul>
<li>包（只存在于开发阶段）</li>
</ul></li>
<li>注释事物</li>
</ul>
<p>UML中关系：</p>
<ul>
<li><p>关联</p>
<p><img
src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338747.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>依赖</p>
<p><img
src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339834.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>泛化</p>
<p><img
src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339535.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>实现</p>
<p><img
src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339262.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>聚合</p>
<p><img
src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339198.png" srcset="/img/loading.gif" lazyload /></p></li>
</ul>
<h4 id="用例图">7.1 用例图</h4>
<p>用例图分类：<strong>业务用例图、系统用例图</strong></p>
<p>用例图组成：<strong>参与者<span
class="math inline">\(Actor\)</span>，用例<span
class="math inline">\(Use\ Case\)</span>，关联关系<span
class="math inline">\(Association\)</span>，包含关系<span
class="math inline">\(Include\)</span>，扩展关系<span
class="math inline">\(Extend\)</span>，泛化关系<span
class="math inline">\(Generalization\)</span></strong></p>
<ul>
<li><p>参与者</p>
<ul>
<li>参与者对系统而言总是外部的</li>
<li>分为启动者（消费者）和支持者（商家）</li>
<li>参与者之间可以有泛化关系</li>
</ul></li>
<li><p>用例</p>
<ul>
<li><p>区分用例和事件流：用例处于系统的需求分析阶段，避免考虑细节性问题；事件流描述系统“做什么”，会有更多的细节，也是在需求分析阶段。</p></li>
<li><p>用例对应有事件流文件</p>
<p>举例：<strong>用例名称：学生选课</strong></p>
<p><strong>简要描述：把具有选课资格的某一学生加到该课程的选课名单中</strong></p>
<p><strong>前提条件：学生已注册，选过该课程的先导课程并获得学分</strong></p>
<p><strong>后置条件：如果学生具有注册资格，并且该课程仍有空位，则学生注册到该课程</strong></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339512.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p>👆🏻一个用例对应的事件流文件</p></li>
</ul></li>
<li><p>关联关系</p>
<ul>
<li>参与者与用例之间的关系</li>
</ul></li>
<li><p>包含关系</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211213201926513.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<ul>
<li>用户用例执行，提供者用例必须执行</li>
</ul></li>
<li><p>扩展关系</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339441.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<ul>
<li>没有基础用例，扩展用例也是完整的用例</li>
<li>基础用例被执行时，一般不会涉及扩展用例，只有特定的条件发生，扩展用例才可能被执行，这是与包含关系的差别</li>
</ul></li>
<li><p>泛化关系</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339556.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<ul>
<li>子用例表示父用例的特殊形式</li>
<li>一个用例（父用例）可以被特别地列举为一个或多个子用例</li>
<li>泛化关系是一般和特殊的关系</li>
</ul></li>
<li><p>用例是有粒度的，用例的粒度指的是用例所包含的系统服务或功能单元的多少。</p>
<ul>
<li>用例的粒度越大，用例包含的功能越多，反之则包含的功能越少。</li>
<li><strong>步骤不是用例</strong></li>
<li>用例识别的标准：<span
class="math inline">\(actor\)</span>与系统之间的一次独立交互</li>
</ul></li>
<li><p>注意用例的边界</p></li>
<li><p>用例是<span
class="math inline">\(actor\)</span>与系统之间的交互，<span
class="math inline">\(actor\)</span>与<span
class="math inline">\(actor\)</span>在现实中的交互不应包含在<span
class="math inline">\(use\ case\)</span></p></li>
<li><p>注意区分<span class="math inline">\(actor\)</span>和系统</p></li>
<li><p>我们要开发的系统（软件）是业务组织里面的一个业务对象，系统<strong>用例就是这个业务对象对外提供的服务</strong></p></li>
</ul>
<h4 id="活动图">7.2 活动图</h4>
<p>活动图描述活动的顺序，展现从一个活动到另一个活动的控制流，本质是一种<strong>流程图</strong>，着重表现从一个活动到另一个活动的控制流。</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214141101491.png" srcset="/img/loading.gif" lazyload  style="zoom:80%;" /></p>
<p>活动图元素：</p>
<ul>
<li><p>动作状态</p>
<p><span class="math inline">\(Action\)</span> 节点</p>
<p>原子（无法分解），不可中断（一旦开始，一直运行到结束），瞬时，可以有入转换，至少有一条出转换</p>
<p><strong>不能有</strong>入口动作和出口动作，<strong>不能有</strong>内部转移</p></li>
<li><p>活动状态</p>
<p><span class="math inline">\(Activity\)</span>节点</p>
<p>非原子运行（可以分解），活动状态的内部活动可以用另一个<strong>活动图</strong>来表示，可以有入口动作和出口动作，可以有内部转移</p>
<p><strong>动作状态是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态</strong></p></li>
<li><p>开始点&amp;结束点</p>
<p><span class="math inline">\(\bullet\)</span> 表示开始</p>
<p><span class="math inline">\(\bigotimes\)</span> 表示子流程结束</p>
<p><span class="math inline">\(\odot\)</span> 表示整个活动结束</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339185.png" srcset="/img/loading.gif" lazyload  style="zoom:60%;" /></p>
<p>等价于：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339939.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p></li>
<li><p>分支与合并</p>
<p><span class="math inline">\(\lozenge\)</span> 节点</p></li>
<li><p>分叉与汇合</p>
<p>分叉用将控制流分为两个或者多个<strong>并发</strong>运行的分支；汇合用于同步这些<strong>并发</strong>分支，以达到共同完成一项事务的目的</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339135.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p></li>
<li><p>泳道</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339325.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p></li>
<li><p>对象流</p>
<p>对象流是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或动作对对象的影响；可以理解为数据流</p></li>
</ul>
<p>活动图 <span class="math inline">\(VS\)</span> 状态图</p>
<p><strong>活动图</strong>着重表现从一个活动到另一个活动的控制流，是<strong>内部处理驱动的流程</strong>；<strong>状态图</strong>着重描述从一个状态到另一个状态的流程，主要有<strong>外部事件的参与</strong></p>
<p>活动图 <span class="math inline">\(VS\)</span> 流程图</p>
<p><strong>流程图</strong>着重描述处理过程，它的主要控制结构是顺序、分支和循环，各个处理之间有严格的顺序和时间关系；<strong>活动图</strong>描述的则是对象活动的顺序关系所遵循的规则，它着重表现的是系统的行为，而非系统的处理过程；<strong>活动图能够表示并发活动的情形，流程图不能</strong></p>
<h4 id="类图对象图">7.3 类图/对象图</h4>
<p>描述类、接口及他们之间关系的图</p>
<p>显示系统各个类的<strong>静态结构</strong></p>
<p>类图的元素</p>
<ul>
<li><p>类</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214155332101.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p>类属性可见性：</p>
<p><span class="math inline">\(public \mapsto +\)</span></p>
<p><span class="math inline">\(private \mapsto -\)</span></p>
<p><span class="math inline">\(protected \mapsto\#\)</span></p>
<p><span class="math inline">\(package \mapsto\)</span> ~</p></li>
<li><p>接口</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214160404753.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p></li>
<li><p>依赖关系</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339425.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
<li><p>泛化关系</p>
<p><span class="math inline">\(is\ a\ kind\ of\)</span></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339243.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p></li>
<li><p>关联关系</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339923.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<ul>
<li><p>关联的名称不是必需的</p></li>
<li><p>关联的角色</p></li>
</ul>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214161919998.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<ul>
<li>关联的多重性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339601.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<ul>
<li><p>聚合关系</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214162140753.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p>整体和部分 <span class="math inline">\(has\ a\)</span></p></li>
<li><p>组合关系</p>
<p>一种特殊的聚合关系--&gt;强聚合</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340625.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p><strong>成员对象的生命周期取决于聚合的生命周期</strong></p>
<p>聚合不仅控制着成员对象的行为，而且控制着成员对象的<strong>创建和析构</strong></p></li>
</ul></li>
<li><p>实现关系</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340457.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p></li>
</ul>
<h4 id="序列图协作图">7.4 序列图/协作图</h4>
<p>交互图：描述系统中对象之间消息通信的图，包括：序列图，协作图</p>
<p>序列图用来描述系统中对象间通过消息进行交互，它强调消息在时间轴上的先后顺序：纵轴是时间轴，时间沿竖线向下延伸；横轴代表了在交互中的各独立的对象</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340272.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>序列图用来描述<strong>用例的实现</strong>，标识了消息发生交互的先后顺序，<strong>明确类的职责</strong></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340372.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p>序列图组成：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340467.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<ul>
<li><p>对象</p>
<p>创建对象的两种表示方法：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214190345889.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p>
<p>注销对象：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340653.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p></li>
<li><p>生命线</p></li>
<li><p>消息</p>
<p>对象之间某种形式的通信；可以是<strong>信号</strong>，也可以是<strong>调用</strong>；可以用于在对象间传递参数</p>
<p>消息分类：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340425.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p></li>
<li><p>激活</p></li>
</ul>
<p>用例图、类图，序列图关系</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340337.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p><span class="math inline">\(BCE\)</span>模式</p>
<p>边界类（<span
class="math inline">\(Boundary\)</span>）：边界类用来<strong>隔离系统内部和外部</strong>，负责接收参与者的消息</p>
<p>控制类（<span
class="math inline">\(Control\)</span>）：控制类对应用例，用来控制用例执行期间的复杂运算或者业务逻辑；<strong>在分析阶段，通常针对一个用例生成一个控制类</strong></p>
<p>实体类（<span
class="math inline">\(Entity\)</span>）：对应于类图中领域概念中的类；封装了数据结构和数据存储有关的类</p>
<p>边界类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340947.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>控制类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340254.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>实体类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340303.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>原则：</p>
<ul>
<li>针对每一个用例，可以对应生成一个控制类</li>
<li>参与者对象只能跟边界对象互动</li>
<li>实体对象不能发送消息给边界对象和控制对象</li>
<li>特别情况，如只是对数据进行增加、删除、修改和查询操作也可以不设置控制对象，让边界对象直接发送消息给实体对象，以提高执行速度</li>
</ul>
<p>一个序列图可以描述多个场景</p>
<p>组合片段：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340021.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p>操作符分类：</p>
<ul>
<li><p><span
class="math inline">\(opt\)</span>：包含一个可能发生或可能不发生的序列，可以在临界条件中指定序列发生的条件</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340371.png" srcset="/img/loading.gif" lazyload  style="zoom:70%;" /></p></li>
<li><p><span
class="math inline">\(alt\)</span>：可以在每个片段中设置一个临界条件来指示该片段可以运行的条件；
else
的指示其他任何临界条件都不为true时应运行的片段；如果所有临界条件都为false并且没有else，则不执行任何片段</p></li>
<li><p><span
class="math inline">\(loop\)</span>：片段重复一定次数，可以在临界条件中指示片段重复的条件</p></li>
<li><p><span
class="math inline">\(break\)</span>：如果执行此片段，则放弃序列的其余部分，可以使用临界来指示发生中断的条件</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342515.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
<li><p><span
class="math inline">\(par\)</span>：并行处理，片段中的事件可以交错</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342987.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
<li><p><span
class="math inline">\(critical\)</span>：指示此片段中的消息不得与其他消息交错，通常是一些原子性操作</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342038.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
<li><p><span
class="math inline">\(ref\)</span>：用来在一个交互图中，引用其他的交互图</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342976.png" srcset="/img/loading.gif" lazyload style="zoom:90%;" /></p></li>
</ul>
<p>协作图组成：</p>
<ul>
<li>对象</li>
<li>链</li>
<li>消息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342783.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>序列图和协作图是等价的，可以从一种形式的图转换为另一种形式的图而不丢失任何信息</p>
<h4 id="状态图">7.5 状态图</h4>
<p>状态图主要用于描述<strong>一个对象</strong>在其生存期间的<strong>动态行为</strong>，表现为<strong>一个对象所经历的状态序列</strong>，引起状态转移的<strong>事件</strong>（<span
class="math inline">\(Event\)</span>），以及因状态转移而伴随的<strong>动作</strong>（<span
class="math inline">\(Action\)</span>）</p>
<p>状态图元素：</p>
<ul>
<li><p>状态</p>
<p>状态指在对象的生命周期中的某个条件或者状况；在此期间对象将满足<strong>某些条件、执行某些活动或等待某些事件</strong></p>
<ul>
<li>初始状态 <span class="math inline">\(\bullet\)</span></li>
<li>终止状态 <span class="math inline">\(\bigodot\)</span></li>
</ul></li>
<li><p>转移</p>
<p>对象在源状态中执行一定的动作，并在某个特定事件（<strong>触发事件</strong>）发生而且某个特定的<strong>警界条件</strong>满足时进入<strong>目标状态</strong>；状态可以有返回自身状态的转移（<strong>自身转移</strong>）
<span class="math inline">\(\rightarrow\)</span></p></li>
<li><p>动作</p>
<p>原子操作</p></li>
<li><p>组合状态</p>
<p>含有子状态的状态</p></li>
<li><p>进入节点&amp;退出节点</p>
<p>进入节点 <span
class="math inline">\(\bigcirc\)</span>：不需要初始化，直接通过进入节点进入状态</p>
<p>退出节点 <span class="math inline">\(\bigotimes\)</span>
：从子状态转移到外部状态</p></li>
<li><p>历史状态</p>
<p>记住从组合状态中退出时所处的子状态</p></li>
<li><p>并发</p>
<p>组合状态在某一时刻同时到达多个子状态</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342111.png" srcset="/img/loading.gif" lazyload  style="zoom:70%;" /></p></li>
</ul>
<h4 id="组件图">7.6 组件图</h4>
<h4 id="部署图">7.7 部署图</h4>
<h2 id="需求获取与分析">8.需求获取与分析🦷</h2>
<h4 id="软件需求与需求获取">8.1 软件需求与需求获取</h4>
<h5 id="软件需求的定义">8.1.1 软件需求的定义</h5>
<p><strong>对用户需求的管理水平是决定软件成败的重要原因</strong></p>
<p>需求用于表达：“做什么”，不是表达：“怎么做”</p>
<h5 id="需求的分类">8.1.2 需求的分类</h5>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342633.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<ul>
<li><p>业务需求</p>
<p>客户对于系统的高层次目标要求<span class="math inline">\(high-level\
objectives\)</span>) ，定义了项目的远景和范畴(<span
class="math inline">\(vision\ and\ scope\)</span>)</p></li>
<li><p>用户需求</p>
<p>从用户角度描述的<strong>系统功能需求与非功能需求</strong>，通常只涉及系统的<strong>外部行为</strong>而不涉及内部特性</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342566.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<ul>
<li><p>功能需求</p>
<p>系统应提供的功能或服务</p></li>
<li><p>非功能需求</p>
<p>对<strong>质量和性能</strong>的额外要求</p>
<ul>
<li>速度、存储空间、可用性、可靠性、容错性（一般用一些可度量的特性来描述）</li>
</ul></li>
</ul></li>
</ul>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342423.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<ul>
<li><p>约束条件</p>
<p>法律法规、硬件/资源限制、开发语言</p></li>
<li><p>业务规则</p>
<p><strong>内部执行逻辑</strong></p>
<p>“如果...，那么...”</p></li>
<li><p>外部接口需求</p></li>
</ul>
<h5 id="好的需求与坏的需求">8.1.3 好的需求与坏的需求</h5>
<p>产生不合格需求的原因：</p>
<ul>
<li>无足够用户参与</li>
<li>用户需求的不断增加</li>
<li>模棱两可的需求</li>
<li>不必要的特性</li>
<li>过于精简的规格说明</li>
<li>忽略的用户分类</li>
<li>不准确的计划</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342635.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<h5 id="需求工程">8.1.4 需求工程</h5>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342624.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342468.png" srcset="/img/loading.gif" lazyload style="zoom:65%;" /></p>
<h5 id="需求获取方法">8.1.5 需求获取方法</h5>
<p>需求获取的基本步骤：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342373.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p>第1步：<strong>了解相关背景和领域/行业的知识</strong>，确定产品所期望的<strong>用户类</strong></p>
<p>第2步：与客户企业或组织的<strong>高层人员进行交流</strong>，了解实际用户任务和目标以及这些任务所支持的<strong>业务需求</strong></p>
<p>第3步：与客户企业或组织的<strong>底层人员进行交流</strong>，获取每个用户类的详细的<strong>用户需求</strong></p>
<p>第4步：整理需求纪要，<strong>发现新问题</strong>，并重复1-3步</p>
<p>第5步：<strong>需求分类和组织</strong>，以区别<strong>功能需求、非功能需求、约束条件、业务规则、外部接口需求</strong>、建议解决方法和附加信息</p>
<p>第6步：<strong>优先排序和冲突解决</strong></p>
<p>第7步：得到最终需求清单，并与客户做最终<strong>签字确认</strong></p>
<p>需求获取中的问题：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342857.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p>需求获取技术</p>
<ul>
<li><p>收集现有纸面材料</p>
<ul>
<li>收集现有的报表、表格和过程描述</li>
<li>收集现有的工作流程图</li>
<li>分发和收集需求收集表</li>
</ul></li>
<li><p>面对面访谈</p>
<p>问题分类：</p>
<p>上下文无关问题：充分理解用户的问题，不涉及具体的解决方案</p>
<p>解决方案相关的问题：通过这类问题，探寻特定的解决方案并得到用户的认可</p></li>
<li><p>需求研讨会</p>
<p><span class="math inline">\(JAD\)</span>会议</p></li>
<li><p>现场观察/体验</p>
<p>被动观察：用户实地工作，需求分析人员在旁边看</p>
<p>主动观察：需求分析人员直接参与到用户的实际工作</p></li>
<li><p>头脑风暴</p></li>
</ul>
<p>对客户输入进行分类：</p>
<ul>
<li>业务需求：描述客户可以从产品中得到的<strong>资金、市场或其它业务利润的需求</strong></li>
<li>业务规则：一些活动只能<strong>在特定的条件下，由一些特定的人来完成时</strong>，该用户可能在描述一个业务规则</li>
<li>功能需求：用户应该能<span
class="math inline">\(&lt;执行某些功能&gt;\)</span>或者系统应该<span
class="math inline">\(&lt;具有某些行为&gt;\)</span></li>
<li>非功能需求</li>
<li>外部接口序需求：从<span
class="math inline">\(&lt;某些设备&gt;\)</span>读取信号；给<span
class="math inline">\(&lt;一些其他系统&gt;\)</span>发送信息；以<span
class="math inline">\(&lt;某种格式&gt;\)</span>读取文件；能控制<span
class="math inline">\(&lt;一些硬件&gt;\)</span></li>
<li>约束条件：必须使用<span
class="math inline">\(&lt;一个特定的数据库产品或语言&gt;\)</span>；不能申请多于<span
class="math inline">\(&lt;一定数量的内存&gt;\)</span>；操作必须与<span
class="math inline">\(&lt;其它系统&gt;\)</span>相同；必须与<span
class="math inline">\(&lt;其它应用程序&gt;\)</span>一致</li>
<li>数据定义</li>
</ul>
<h4 id="用户故事与用例建模">8.2 用户故事与用例建模</h4>
<h5 id="敏捷开发中的用户故事user-story">8.2.1
敏捷开发中的“用户故事”（User Story）</h5>
<p>在敏捷开发中，需求表述为一组“用户故事”；在传统的<span
class="math inline">\(OO\)</span>分析与设计方法中，需求被表述为一组“用例”</p>
<p>组成部分：卡片、交谈、确认</p>
<p><span class="math inline">\(As\ a\ [user\ role],I\ want\ to\
[goal]\,so\ I\ can\ [reason]\ \ \ \rightarrow\ Who/What/Why\)</span></p>
<p>好的用户故事具备的特征： <span
class="math inline">\(INVEST\)</span></p>
<p><span
class="math inline">\(Independent、Negotiable(可讨论的)、Valuable、Estimable、Small、Testable\)</span></p>
<p><span class="math inline">\(TDD\)</span>：写代码前先写测试</p>
<h5 id="面向对象方法中的用例use-case">8.2.2 面向对象方法中的“用例”（Use
Case）</h5>
<h5 id="用例建模的基本过程">8.2.3 用例建模的基本过程</h5>
<ol type="1">
<li><p>识别并描述参与者（Actor）</p>
<p>特殊Actor：系统时钟</p></li>
<li><p>识别用例</p></li>
<li><p>识别参与者与角色之间的通讯关联（Association）</p></li>
<li><p>给出用例详细描述</p>
<p>事件流</p>
<ul>
<li>常规流</li>
<li>备选流（extend可以看成是备选流）</li>
</ul></li>
<li><p>细化用例模型（extend、include、泛化）</p>
<p>Actor之间存在泛化关系</p></li>
</ol>
<p>用例识别标准：actor与系统之间的一次独立交互</p>
<p>用例是actor与系统之间的交互，actor与actor在现实中的交互（讨价还价）不应包含在用例中</p>
<p>注意区分actor和系统，系统自己做的事情，不是独立的用例</p>
<h5 id="用例模型的提交物">8.2.4 用例模型的提交物</h5>
<h5 id="活动图-泳道图">8.2.5 活动图 &amp; 泳道图</h5>
<h4 id="需求的结构化分析">8.3 需求的结构化分析</h4>
<h5 id="结构化方法vs面向对象方法">8.3.1 结构化方法vs面向对象方法</h5>
<p>结构化方法：复杂世界<span
class="math inline">\(\rightarrow\)</span>复杂处理过程（事情的发生发展），设计一系列功能解决</p>
<p>面向对象方法：任何系统都是由能够完成一组相关任务的对象构成</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342199.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342024.png" srcset="/img/loading.gif" lazyload style="zoom:65%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342738.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p>
<h5 id="需求的结构化分析方法">8.3.2 需求的结构化分析方法</h5>
<p>结构化分析：帮助开发人员定义系统需要做什么（处理需求），系统需要存储和使用哪些数据（数据需求），系统需要什么样的输入和输出以及如何把这些功能结合在一起来完成任务</p>
<p>结构化分析方法：</p>
<ul>
<li>数据流图（<span class="math inline">\(DFD\)</span>）</li>
<li>实体-关系图（<span class="math inline">\(ERD,IDEF1X\)</span>）</li>
</ul>
<h5 id="数据流图dfd">8.3.3 数据流图（DFD）</h5>
<p>数据流图：用处理、外部实体、数据流以及数据存储来表示系统需求的图表</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342161.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p>从外部实体发出的“数据流”可以是：1.外部实体发出的“处理请求”，即一个事件
2.外部实体给出的“输入数据”</p>
<p>指向“外部实体”的“数据流”一般是“处理”的反馈或处理结果</p>
<p>DFD图可以描述高层次的具有高度概括的系统处理也可以描述低层次的具有更详细分解的系统处理</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342013.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342258.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p>
<ul>
<li><p>关联图：在<strong>单个处理符号</strong>中概括系统内所有处理活动的DFD</p>
<p><strong>关联图在表达系统边界时用处很大</strong>，系统的范围是通过单个的处理和外部实体所表示的事物来定义的；</p>
<p><strong>数据存储不画在关联图</strong>中是因为它本身被认为是系统内部的内容</p>
<p>当一个系统响应事件较多时，常常将系统分成多个子系统，并为每个子系统创建一张关联图</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343220.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
<li><p>DFD片段：用一个单一处理符号表示系统响应一个事件的DFD</p>
<p>在DFD片段中，展示了<strong>处理、外部实体和内部数据存储</strong>之间的交互细节</p>
<p>每个DFD片段仅显示要响应该事件的相关的那些数据存储</p>
<p><strong>一个DFD片段是为事件表中的每一个事件创建的</strong></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343251.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
<li><p>DFD的0层图：将一个系统或子系统的所有DFD片段组合到一个单个的DFD图中，这样的DFD图称为<strong>事件分离的系统模型/0层图</strong></p>
<p><strong>0层DFD图：“处理”的编号为<span
class="math inline">\(i\)</span></strong></p></li>
<li><p>DFD层次：一个DFD片段中的<strong>处理</strong>也可以包含多个更小的<strong>处理</strong>，有时分析员需要将该DFD片段进一步细化，生成更详细层次的DFD图</p>
<p>1层DFD图：将0层DFD中的处理进一步细化等到的DFD图“处理”的编号为“<span
class="math inline">\(i.j\)</span>”</p>
<p>2层DFD图：将1层DFD中的处理进一步细化等到的DFD图 “处理”的编号为“<span
class="math inline">\(i.j.k\)</span>”</p></li>
</ul>
<p>如何画一个好的DFD图：</p>
<ul>
<li><p>最小化复杂度：采用分层结构将DFD划分为小的且相对独立的子集这样可以逐级阅读、考察DFD</p>
<p><strong>单个DFD图中不应有超过7±2个处理，单个DFD中不应超过7±2个数据流进出同一个处理/数据存储</strong></p>
<p>接口最小化：DFD中各个元素之间的连接数越少越好</p></li>
<li><p>保持数据流一致：</p>
<p><strong>一个“处理”和该“处理”被详细分解后在数据流内容上应该一致</strong></p>
<p><strong>对一个“处理”，有数据流入则必须有相对应的数据流出</strong></p>
<p><strong>对一个“处理”，有数据流出则必须有相对应的数据流入</strong></p></li>
<li><p><strong>黑洞</strong>：带有输入数据的但并不用其产生输出数据的处理或数据存储</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343749.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p></li>
<li><p><strong>奇迹</strong>：没有足够数据元素作为输入或产生来源的一个处理或数据存储</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343727.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p></li>
<li><p>典型错误：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343082.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343139.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p></li>
</ul>
<p>在传统方法中，DFD图一般描述3种元素：处理【使用DFD】，（数据流，数据存储）【使用DD】</p>
<p>DFD细节描述：决策表、决策树</p>
<h5 id="数据字典dd">8.3.4 数据字典（DD）</h5>
<p>数据字典是数据分析的描述模型，包括：</p>
<ul>
<li><p>数据项定义：定义特定数据项的组成和意义</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343555.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p></li>
<li><p>数据结构定义：定义有数据项组成的表达数据的基本数据</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343415.png" srcset="/img/loading.gif" lazyload  style="zoom:60%;" /></p></li>
<li><p>数据流描述：描述数据流的数据构成，并指明其来源或去向</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343471.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p></li>
<li><p>数据存储描述：描述保存在存储介质上的数据文件或数据库表的格式和内容</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343049.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p></li>
<li><p>数据处理（广义DD）：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343127.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p></li>
</ul>
<h5 id="数据分析erdidef1x">8.3.5 数据分析（ERD、IDEF1X）</h5>
<p>实体关系图（<span class="math inline">\(ERD\)</span>）</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343154.png" srcset="/img/loading.gif" lazyload  style="zoom:80%;" /></p>
<p>关联实体：解决上述问题的人为增加的数据实体，它一定包含两端数据实体的关键字</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343157.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343885.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<h4 id="面向对象的分析">8.4 面向对象的分析</h4>
<h5 id="面向对象的分析方法概述">8.4.1 面向对象的分析方法概述</h5>
<p>面向对象的分析模型由三个独立模型构成（分为3个阶段）：</p>
<ul>
<li>功能模型：从用户角度获取功能需求，由<strong>用例模型</strong>表示</li>
<li>静态结构模型：描述系统的概念实体，由<strong>类图</strong>表示</li>
<li>动态结构模型：描述对象之间的交互行为，由<strong>时序图和协作图</strong>表示</li>
</ul>
<p>静态结构模型&amp;动态结构模型建立与实现技术无关的系统逻辑结构</p>
<h5 id="建立静态结构模型">8.4.2 建立静态结构模型</h5>
<p>静态结构模型</p>
<ul>
<li><p>边界类</p>
<p>用户界面、系统接口、设备接口</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343809.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p></li>
<li><p>控制类</p>
<p>对用例行为的封装，一般一个用例对于一个控制类</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343423.png" srcset="/img/loading.gif" lazyload style="zoom:100%;" /></p></li>
<li><p>实体类</p>
<p>“事物”</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343679.png" srcset="/img/loading.gif" lazyload style="zoom:100%;" /></p>
<p>三种类之间是“关联”关系</p>
<p><strong>一个边界类</strong>可以<strong>与多个控制类</strong>相关联</p>
<p><strong>一个控制类</strong>可以与<strong>多个边界类</strong>相关联、与<strong>多个实体类</strong>关联</p>
<p><strong>一个实体类</strong>可以与<strong>多个控制类</strong>相关联</p>
<ul>
<li><p>除非系统需要在各用例中管理和维护该角色的信息(不是指ID、密码)，否则只需将其作为actor，无需作为实体类</p></li>
<li><p><span
class="math inline">\(actor\)</span>自己做的动作，都是边界类的操作，与控制类和实体类无关</p></li>
<li><p>实体类操作分两类：</p>
<ol type="a">
<li><p><span class="math inline">\(new()、destroy()\)</span></p></li>
<li><p>对该实体内部的一个或多个属性的CRUD（增删改查）操作 —
<strong>是自己的属性，不是其他实体的！</strong>因此，对用例中actor所发出的每个动作，需要仔细分析它对哪些实体类的哪些属性做CRUD</p></li>
</ol></li>
</ul>
<p>如果操作CRUD的对象不是该实体类的属性，则说明该操作应移动到相应的实体类中。</p>
<p>若某操作op会CRUD多个实体类的属性，通常可以把这个操作分解为多个小粒度操作，每个小操作放在专门的实体类中，如果没办法分解，则使用控制类加以完成。</p></li>
</ul>
<p>关系：泛化、关联、组合、聚合、依赖</p>
<ul>
<li><p>分析类图：主要区分边界类、控制类、实体类</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343643.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
<li><p>领域类图：主要区分泛化、关联、组合、聚合、依赖</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343837.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
</ul>
<h5 id="建立动态行为模型">8.4.3 建立动态行为模型</h5>
<p>见7.4</p>
<h5 id="案例分析-1">8.4.4 案例分析</h5>
<ol type="1">
<li><p>角色识别</p></li>
<li><p>用例识别</p></li>
<li><p>建立用例模型</p></li>
<li><p>对用例图进行精化</p>
<p>（针对每个用例）</p></li>
<li><p>撰写用例描述</p></li>
<li><p>绘制用例的活动（泳道）图</p></li>
<li><p>识别分析类（边界类、控制类、实体类）</p></li>
<li><p>识别每个类的属性和方法</p></li>
<li><p>建立分析类图</p></li>
<li><p>建立领域类图</p></li>
<li><p>建立时序图</p></li>
</ol>
<h2 id="软件设计">9.软件设计🌏</h2>
<h4 id="结构化设计">9.1 结构化设计</h4>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343353.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p>自动化系统边界划分：将数据流图分为手工处理部分和系统能自动完成的部分</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343277.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p>结构图创建方法：</p>
<ul>
<li><p>DFD片段</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343667.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
<li><p>DFD分解图</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343962.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
<li><p>DFD重组</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343136.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
<li><p>结构图</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344086.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p></li>
</ul>
<p>变换型结构的数据流图呈一种线性状态，它所描述的工作可表示为输入、主处理及输出。</p>
<p>事务型结构的数据流图则呈束状，即一束数据流平行流人或流出，可能同时有几个事务要求处理。</p>
<p>DFD到系统结构图转换的模式：</p>
<ul>
<li>事务型</li>
<li>复杂变换型</li>
</ul>
<p>结构图：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344018.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p><strong>三种转换</strong>【重中之重】</p>
<p><strong>见<span class="math inline">\(PPT\)</span></strong></p>
<p><a target="_blank" rel="noopener" href="https://www.it610.com/article/1864147.htm">转换</a></p>
<h4 id="面向对象设计">9.2 面向对象设计</h4>
<p>结构化方法：分析阶段与设计阶段分得特别清楚，分别使用两套完全不同的建模符号和建模方法</p>
<p>面向对象设计（<span class="math inline">\(OOD\)</span>）：<span
class="math inline">\(OO\)</span>各阶段均采用统一的“对象”概念，各阶段之间的区分变得不明显，形成“无缝”连接</p>
<p>系统设计（<strong>概要设计</strong>）<span class="math inline">\(\
\rightarrow\ \)</span>对象设计（<strong>详细设计</strong>）</p>
<p>子系统的划分应该符合<strong>高内聚低耦合</strong>的原则</p>
<p>类与类之间存在的“聚合、组合、关联、依赖”关系导致包与包之间存在依赖关系，即“包的依赖”(<span
class="math inline">\(dependency\)</span>)；类与类之间的存在的“继承”关系导致包与包之间存在继承关系，即“包的泛化”(<span
class="math inline">\(generalization\)</span>)</p>
<p>对象设计基本步骤</p>
<ol type="1">
<li>创建初始的设计类</li>
<li>细化属性</li>
<li>细化操作</li>
<li>定义状态</li>
<li>细化依赖关系</li>
<li>细化关联关系</li>
<li>细化泛化关系</li>
</ol>
<h4 id="数据库设计">9.3 数据库设计</h4>
<p>数据库系统 = 数据库（DB） + 数据库管理系统（DBMS）</p>
<p>数据库设计任务：</p>
<ul>
<li>逻辑设计：设计<span class="math inline">\(ER\)</span>模型</li>
<li>物理设计：在具体的数据库系统中实现<span
class="math inline">\(ER\)</span>模型</li>
</ul>
<p>数据库<strong>逻辑模型设计</strong>：ERD图</p>
<p><span class="math inline">\(3NF\)</span>范式：</p>
<ul>
<li><span
class="math inline">\(1NF\)</span>：没有重复的属性或属性组（同样的东西不能重复拥有）</li>
<li><span class="math inline">\(2NF\)</span>：是<span
class="math inline">\(1NF\)</span>且每个非主属性均函数依赖于主属性（主键）（领导在，他就在，找到领导就能找到他）</li>
<li><span class="math inline">\(3NF\)</span> ：是<span
class="math inline">\(2NF\)</span>且非主属性间均不存在函数依赖（领导只有一个，不能有多级领导）</li>
</ul>
<p>根据ERD设计物理数据库</p>
<ol type="1">
<li>为每个实体创建一个二维表</li>
<li>为每个字段选择适当的数据类型和取值范围</li>
<li>定义每个表的主键</li>
<li>针对1：M关联关系的子表添加外键</li>
<li>定义完整型约束</li>
</ol>
<p>分析类图映射到ERD</p>
<p>本质：把<strong>每一个类，类之间的关系</strong>分别映射到一张表或多张表</p>
<ul>
<li><p>一类一表</p></li>
<li><p>不管是<span class="math inline">\(1\ :\ 1，1\ :\ n，m\ :\
n\)</span>的关联关系
，均可以：A，B分别映射为独立的数据表，然后再加入一张新表来存储二者之间的关联</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344870.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344820.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344920.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p></li>
<li><p>聚合/组合关系</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344279.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p></li>
<li><p>泛化关系</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344472.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p></li>
</ul>
<h4 id="用户界面设计">9.4 用户界面设计</h4>
<ul>
<li><span class="math inline">\(CUI\)</span>：字符用户界面</li>
<li><span class="math inline">\(GUI\)</span>：图形用户界面 <span
class="math inline">\(\rightarrow\ WIMP\)</span></li>
<li><span class="math inline">\(MUI\)</span>：多通道用户界面</li>
</ul>
<p>缺省设计方法：</p>
<ul>
<li>用户操作设定缺省值（也可以作为强制值输入）</li>
<li>经验值作为缺省值</li>
<li>统计方法确定出现几率大的值作为缺省值</li>
<li>统计方法确定出现几率大的值作为缺省值</li>
<li>最近使用值作为缺省值</li>
<li>输入数据的上下文关联缺省值</li>
<li>当前状态值可作为缺省值</li>
<li>当前状态值可作为缺省值</li>
<li>正常操作序列选项作为缺省值</li>
<li>树状隶属关系约束选项列表</li>
<li>智能焦点</li>
</ul>
<h2 id="软件测试">10.软件测试🍪</h2>
<h4 id="软件测试基础">10.1 软件测试基础</h4>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344061.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p>上面的<span class="math inline">\(Venn\
Diagram\)</span>可以理解测试</p>
<p>测试可以证明“程序有错”，不能证明“程序正确”</p>
<h4 id="测试过程">10.2 测试过程</h4>
<p>软件测试的<span class="math inline">\(V\)</span>模型</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344859.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<h4 id="测试方法分类">10.3 测试方法分类</h4>
<ul>
<li><p>单元测试</p>
<p><strong>开发人员</strong>执行</p>
<p>驱动模块：模仿被测模块的上一级模块</p>
<p>桩模块：模拟被测单元需调用的其他函数接口</p></li>
<li><p>集成测试</p>
<p>测试的对象是模块间的接口</p>
<ul>
<li><p>整体集成</p>
<p>将所有模块按设计要求一次全部组装起来，然后进行整体测试</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344081.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p></li>
<li><p>增量集成</p>
<p>逐步将新模块加入并测试</p>
<ul>
<li><p>自顶向下增量集成</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345446.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p>深度优先：A,B,E,C,D,F</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344771.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>广度优先：A,B,C,D,E,F</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345884.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p><strong>所需桩模块巨大</strong></p>
<p>较少需要驱动模块</p></li>
<li><p>自底向下增量集成</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345781.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p><strong>不用桩模块</strong></p>
<p>难以尽早建立信心</p></li>
<li><p>三明治集成</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345073.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p></li>
</ul></li>
</ul></li>
<li><p>确认测试</p>
<p>是否满足软件需求说明书中的确认标准</p></li>
<li><p>系统测试</p></li>
<li><p>验收测试</p>
<p>以用户为主的测试</p>
<p><span
class="math inline">\(\alpha\)</span>测试：由用户在开发环境下进行的测试</p>
<p><span
class="math inline">\(\beta\)</span>测试：由软件的多个用户在实际使用环境下进行测试</p></li>
<li><p>回归测试</p></li>
</ul>
<h4 id="黑盒测试">10.4 黑盒测试</h4>
<h5 id="黑盒测试概述">10.4.1 黑盒测试概述</h5>
<p>通常在软件接口处进行</p>
<p>原理：任何程序都可以看成是将输入定义域取值映射到输出值域的函数</p>
<p>不可能穷举所有的情况</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345324.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p>
<h5 id="等价类划分方法">10.4.2 等价类划分方法</h5>
<p>确定等价类的六大原则</p>
<ul>
<li>在输入条件规定了取值范围或值的个数的情况下，则可以确立1个有效等价类和2个无效等价类</li>
<li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立1个有效等价类和1个无效等价类</li>
<li>在输入条件是一个布尔量的情况下，可确定1个有效等价类和1个无效等价类</li>
<li>在规定了输入数据的一组值(假定n个)、并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和1个无效等价类</li>
<li>在规定了输入数据必须遵守的规则的情况下，可确立1个有效等价类(符合规则)和n个无效等价类(从不同角度违反规则)</li>
<li>在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步的划分为更小的等价类</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345728.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<h5 id="边界值方法">10.4.3 边界值方法</h5>
<p>原则</p>
<ul>
<li>如果输入条件规定了值的范围，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据</li>
<li>如果输入条件规定了值的个数，则用最大个数、最小个数、比最小个数少1,比最大个数多1的数据作为测试数据</li>
<li>将原则1和原则2应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值</li>
<li>如果程序的规格说明给出的输入域或输出域是有序集合，则应选取集合的第一个元素和最后一个元素作为测试用例</li>
<li>如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例</li>
<li>分析规格说明，找出其它可能的边界条件</li>
</ul>
<h4 id="白盒测试">10.5 白盒测试</h4>
<h5 id="白盒测试概述">10.5.1 白盒测试概述</h5>
<p><strong>白盒测试用例中的输入数据从程序结构导出，但期望输出务必从需求规格中导出</strong></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345499.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<h5 id="白盒测试的覆盖标准">10.5.2 白盒测试的覆盖标准</h5>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345445.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345190.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345956.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<ul>
<li><p>语句覆盖</p>
<p>使每条语句至少被执行一次</p></li>
<li><p>判定覆盖</p>
<p>使程序中的每个分支至少都通过一次</p></li>
<li><p>条件覆盖</p>
<p>使判定中的<strong>每个条件（不用考虑整体的结果）</strong>获得各种可能的结果</p>
<p><strong>条件覆盖并不能完全包含判定覆盖，也可能不包含语句覆盖</strong></p></li>
<li><p>判定/条件覆盖</p>
<p>使判定中的每个条件取得各种可能的结果，并使得每个分支取得各种可能的结果</p>
<p>不一定查出逻辑表达式的所有错误</p></li>
<li><p>条件组合覆盖</p>
<p>使得每个判定中多个条件的各种取值的可能组合都至少出现一次</p></li>
</ul>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345199.png" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<h5 id="基本路径法">10.5.3 基本路径法</h5>
<p>路径测试：设计足够多的测试用例，覆盖被测试对象的所有可能路径</p>
<p>基本路径测试：保证测试中程序的每一个基本独立路径至少执行一次</p>
<ol type="1">
<li>程序的控制流图：描述程序控制流的一种图示方法</li>
<li>程序圈复杂度：<span
class="math inline">\(McCabe\)</span>复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界</li>
<li>导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果</li>
<li>准备测试用例：确保基本路径集中的每一条路径的执行</li>
</ol>
<ul>
<li><p>程序流图</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345315.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345807.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p>如果判断中的条件表达式是由一个或多个逻辑运算符 (<span
class="math inline">\(OR, AND, NAND, NOR\)</span>)
连接的复合条件表达式，则需要改为一系列只有单条件的嵌套的判断</p>
<p>独立路径：一条程序执行的路径，至少包含一条在定义该路径之前的其他基本路径不曾用过得边</p>
<p>圈复杂度：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345553.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p><strong>某些独立路径不能以独立的方式被测试(即穿越路径所需的数据组合不能形成程序的正常流)；在这种情况下，这些路径必须作为另一个路径测试的一部分来进行测试</strong></p>
<p>“圈复杂度”表示：<strong>只要最多V(G)个测试用例就可以达到基本路径覆盖，但并非一定要设计V(G)个用例</strong></p>
<p>但是：<strong>测试用例越简化，代表测试越少、可能发现的错误就越少</strong></p></li>
</ul>
<h5 id="循环测试法">10.5.4 循环测试法</h5>
<h5 id="xunit白盒测试">10.5.5 xUnit白盒测试</h5>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%B7%A5%E5%85%B7/">软件过程与工具</a>
                    
                  </div>
                
              </div>
              <p class="note note-warning">
                <strong>本文作者: </strong><a href="/">fly-beep</a> <br>
                <strong>本文链接: </strong><a href="https://fly-beep.top/post/f6d9959d.html">https://fly-beep.top/post/f6d9959d.html</a> <br>
                <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                   </p>
                   
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/e5a09991.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">编译原理期末总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/1c335eca.html">
                        <span class="hidden-mobile">JDBC学习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@waline/client@1/dist/Waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://waline-3s11u25y3-fly-beep.vercel.app/","path":"window.location.pathname","placeholder":null,"meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili"],"dark":"html[data-user-color-scheme=\"dark\"]","avatar":"retro","avatarCDN":"https://seccdn.libravatar.org/avatar/","avatarForce":false,"wordLimit":0,"pageSize":10,"highlight":true},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        new Waline(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          Fluid.plugins.initFancyBox('#waline .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> <div> 人生天地间，忽如远行客。 </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/Cherry.min.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
