

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="顾海耀">
  <meta name="keywords" content="">
  
    <meta name="description" content="本系列文章主要对VTK的相关知识进行总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="VTK学习笔记（二）">
<meta property="og:url" content="https://fly-beep.top/post/4036df29.html">
<meta property="og:site_name" content="Fly-beep&#39;s Blog">
<meta property="og:description" content="本系列文章主要对VTK的相关知识进行总结。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fly-beep.top/img/vtk.jpg">
<meta property="article:published_time" content="2022-12-02T08:53:06.675Z">
<meta property="article:modified_time" content="2022-12-02T08:55:39.653Z">
<meta property="article:author" content="顾海耀">
<meta property="article:tag" content="VTK">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://fly-beep.top/img/vtk.jpg">
  
  
  <title>VTK学习笔记（二） - Fly-beep&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"fly-beep.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"9SDM4ZdpdF76KYx9z9yK89zC-MdYXbMMI","app_key":"OiJBGDhFh3KBbnMdv3G0Wf45","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>fly-beep</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="VTK学习笔记（二）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-12-02 16:53" pubdate>
        2022年12月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      125 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">VTK学习笔记（二）</h1>
            
            <div class="markdown-body">
              <p>本系列文章主要对<a
target="_blank" rel="noopener" href="https://vtk.org/">VTK</a>的相关知识进行总结。 <span id="more"></span></p>
<h1 id="vtk学习笔记二">VTK学习笔记（二）</h1>
<h2 id="vtkobjectbase和vtkobject">vtkObjectBase和vtkObject🃏</h2>
<p>vtkObjectBase是一个抽象基类，派生出绝大多数的VTK类。它是VTK里所有引用计数(Reference
Counting)类的基类，著名的子类包括：vtkCommand，vtkInformationKey和vtkObject。</p>
<p>如果很多对象有相同的值，将这个值存储多次是很无聊的。更好的办法是让所有的对象共享这个值的实现。这么做不但节省内存，而且可以使得程序运行更快，因为不需要构造和析构这个值的拷贝。引用计数就是这样一个技巧，它允许多个有相同值的对象共享这个值的实现。引用计数是个简单的垃圾回收体系，只要其它对象引用某对象(记为对象O)，对象O就会存在一个引用计数，当最后引用对象O的对象移除，O对象就会自动析构。VTK里使用引用计数的好处是，可以实现数据之间的共享而不用拷贝，从而达到节省内存的目的。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkSmartPointer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkBMPReader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkImageData.h&quot;</span></span><br><br><span class="hljs-comment">// 因为我没有使用 CMake 进行配置，所以需要下面语句</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vtkAutoInit.h&gt;</span></span><br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkRenderingOpenGL2);<br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkInteractionStyle);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vtkSmartPointer&lt;vtkBMPReader&gt;reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>	reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>	reader-&gt;<span class="hljs-built_in">Update</span>();<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Reference Count of reader-&gt;GetOutput (BeforeAssignment) = &quot;</span> <br>        &lt;&lt; reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetReferenceCount</span>() &lt;&lt; std::endl;<br>	vtkSmartPointer&lt;vtkImageData&gt; image1 = reader-&gt;<span class="hljs-built_in">GetOutput</span>();<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Reference Count of reader-&gt;GetOutput (Assignto image1) = &quot;</span> <br>        &lt;&lt; reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetReferenceCount</span>() &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Reference Count of image1 = &quot;</span> &lt;&lt; image1-&gt;<span class="hljs-built_in">GetReferenceCount</span>() &lt;&lt; std::endl;<br>	vtkSmartPointer&lt;vtkImageData&gt; image2 = reader-&gt;<span class="hljs-built_in">GetOutput</span>();<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Reference Count of reader-&gt;GetOutput (Assignto image2) = &quot;</span> <br>        &lt;&lt; reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetReferenceCount</span>() &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Reference Count of image2 = &quot;</span> &lt;&lt; image2-&gt;<span class="hljs-built_in">GetReferenceCount</span>() &lt;&lt; std::endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212011516764.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>在上例里，我们先用vtkBMPReader读入一幅BMP图像lena.bmp，在赋值之前我们输出了reader-&gt;GetOutput()的引用计数值，其值为1(使用方法New()创建对象以后，初始的引用计数值就等于1)；然后我们创建了一个vtkImageData类型的对象image1，并把reader的输出赋给了image1，这时image1就指向了reader的输出，也就是说，reader的输出多了一个引用，这个时候输出的reader-&gt;GetOutput()和image1的引用计数都为2；接着我们又创建一个类型同样为vtkImageData的对象image2，同样也是把reader的输出赋值给image2，这时，image2也指向reader的输出，亦即reader的输出又多了一个引用，所以输出的reader-&gt;GetOutput()和image2的引用计数值变成了3。</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212011520669.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>一旦某个对象的引用计数等于0时，就表明没有别的对象再引用它，它的使命也宣告完成，程序就会自动的析构这个对象。在这个示例里，我们看不到引用计数减少的相关代码，这是因为我们使用了智能指针vtkSmartPointer。</p>
<hr />
<h2 id="智能指针">智能指针🥶</h2>
<p>智能指针会自动管理引用计数的增加与减少，如果检测到某对象的引用计数值减少为0，则会自动地释放该对象的资源，从而达到自动管理内存的目的。</p>
<p>VTK里，要创建一个对象可以用两种方法，一种是使用vtkObjectBase里的静态成员变量New()，用Delete()方法析构；另一种就是我们示例里使用多次的使用智能指针vtkSmartPointer<T>。</p>
<p>对于第一种方法，用New()创建的对象，程序最后必须要调用Delete()方法释放对应的内存，而且由于vtkObjectBase及其子类的构造函数都是声明为受保护的，这意味着它们不能在栈区(栈区上的内存是由编译器自动分配与释放的，堆区上的内存则是由程序员分配和手动释放的。)上分配内存。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//创建vtkBMPReader对象</span><br>vtkBMPReader*reader = vtkBMPReader::<span class="hljs-built_in">New</span>(); <br>...<br><span class="hljs-comment">//程序最后要调用Delete()，这里并没有直接析构对象，而是使引用计数值减1。</span><br>reader-&gt;<span class="hljs-built_in">Delete</span>();<br></code></pre></div></td></tr></table></figure>
<p>用New()创建的对象，如果没有用Delete()方法删除的话，程序有可能会出现内存泄漏，即用户负责对象内存的管理。</p>
<p>如果使用智能指针创建的对象，则无需手动调用Delete()方法让引用计数减少，因为引用计数的增加与减少都是由智能指针自动完成的。使用智能指针时，首先是要包含智能指针的头文件：<code>#include "vtkSmartPointer.h"</code>。vtkSmartPointer是一个模板类，所需的模板参数就是待创建的对象的类名，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 注意等号两端都要加上vtkSmartPointer</span><br>vtkSmartPointer&lt;vtkImageData&gt;image = vtkSmartPointer&lt;vtkImageData&gt;::<span class="hljs-built_in">New</span>();<br></code></pre></div></td></tr></table></figure>
<p>智能指针可以做函数返回值、类成员变量。在做类成员变量时，不需要在析构函数中进行删除。</p>
<p><strong>当你创建一个智能指针类型的对象，然后改变它的指向，这时引用计数就会出错。</strong>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkImageData&gt; imageData = vtkSmartPointer&lt;vtkImageData&gt;::<span class="hljs-built_in">New</span>();<br>imageData = Reader-&gt;<span class="hljs-built_in">GetOutput</span>();<br></code></pre></div></td></tr></table></figure>
<p>上面两行代码里，我们首先创建一个imageData，并给他分配好了内存，接着我们又把imageData指向Reader的输出，而不是一直指向我们创建的那块内存。对于这种情况，我们只要简单地调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkImageData*imageData = Reader-&gt;<span class="hljs-built_in">GetOutput</span>();<br></code></pre></div></td></tr></table></figure>
<p>这里没有必要使用智能指针，因为我们没有实际创建任何新的对象。</p>
<hr />
<h2 id="运行时类型识别rtti">运行时类型识别（RTTI）🌞</h2>
<p>在C++里，对象类型是通过typeid
(需要包含头文件#include<type_info>)获取的；VTK里在vtkObjectBase定义了获取对象类型的方法：GetClassName()和IsA()。GetClassName()返回的是该对象类名的字符串(VTK用类名来识别各个对象)，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkBMPReader&gt;Reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br><span class="hljs-comment">//返回“vtkBMPReader”字符串</span><br>constchar* type = Reader-&gt;<span class="hljs-built_in">GetClassName</span>(); <br></code></pre></div></td></tr></table></figure>
<p>IsA()方法用于测试某个对象是否为指定字符串的类型或其子类，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 这里IsA()会返回真。</span><br><span class="hljs-keyword">if</span>(Reader-&gt;<span class="hljs-built_in">IsA</span>(“vtkImageReader”) ) &#123;……&#125;; <br></code></pre></div></td></tr></table></figure>
<p>类比C++里的操作RTTI操作符，除了typeid之外，还有dynamic_cast，主要用于基类向子类的类型转换，称为向下转型。VTK里同样提供了类似的方法，也就是vtkObject里定义的SafeDownCast()，它是vtkObject里的静态成员函数，意味着它是属于类的，而不是属于对象的，即可以用vtkObject::SafeDownCast()直接调用，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkImageReader&gt;ReaderBase = vtkSmartPointer&lt;vtkImageReader&gt;::<span class="hljs-built_in">New</span>();<br>vtkBMPReader* bmpReader = vtkBMPReader::<span class="hljs-built_in">SafeDownCast</span>(ReaderBase);<br></code></pre></div></td></tr></table></figure>
<p>与dynamic_cast类似，SafeDownCast也是运行时才转换的，这种转换只有当bmpReader的类型确实是ReaderBase的派生类时才有效，否则返回空指针。</p>
<p>除了运行时类型识别，vtkObjectBase还提供了用于调试的状态输出接口Print()。虽然vtkObjectBase里除了Print()还提供PrintSelf()、PrintHeader()、PrintTrailer()等公共接口，但在调试VTK程序时，如果需要输出某个对象的状态信息时，一般都是调用Print()函数，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">bmpReader-&gt;<span class="hljs-built_in">Print</span>(std::cout);<br></code></pre></div></td></tr></table></figure>
<hr />
<h2 id="vtkobject">vtkObject👾</h2>
<p>vtkObject里定义了与程序调试相关的一些公共接口，包括：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">DebugOn</span>() | <span class="hljs-built_in">DebugOff</span>() | <span class="hljs-built_in">GetDebug</span>() | <span class="hljs-built_in">SetDebug</span>(unsignedchar)<br><span class="hljs-built_in">SetGlobalWarningDisplay</span>(<span class="hljs-type">int</span>) | <span class="hljs-built_in">GetGlobalWarningDisplay</span>() | <span class="hljs-built_in">GlobalWarningDisplayOn</span>() | <span class="hljs-built_in">GlobalWarningDisplayOff</span>()<br></code></pre></div></td></tr></table></figure>
<p>其中后四个是静态成员函数。</p>
<hr />
<p>vtkObject实现了观察者/命令设计模式</p>
<p>vtkObject定义了与观察者Observer相关的方法(如，AddObserver()/RemoveObserver())，观察者模式主要针对两个对象：Object和Observer。一个Object可以有多个Observer，它定义对象间的一种一对多的依赖关系，当—个Object对象的状态发生改变时，所有依赖于它的Observer对象都得到通知被自动更新。</p>
<p>命令模式属于对象行为模式，它将—个请求封装为一个对象，并提供一致性发送请求的接口，当一个事件发生时，它不直接把事件传递到事件调用者，而是在命令和调用者之间增加一个中间者，将这种直接关系切断，同时两者之间都隔离。事件调用者只是和接口打交道，不和具体实现交互。命令模式的实现是由vtkObjectBase的另外一个重要子类vtkCommand及其派生类实现的。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkSmartPointer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkBMPReader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkImageViewer2.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkRenderWindowInteractor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkCallbackCommand.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vtkAutoInit.h&gt;</span></span><br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkRenderingOpenGL2);<br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkInteractionStyle);<br><br><span class="hljs-type">long</span> pressCounts = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//第一步，定义回调函数。</span><br><span class="hljs-comment">//注意回调函数的签名，不能更改。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyCallbackFunc</span><span class="hljs-params">(vtkObject*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eid, <span class="hljs-type">void</span>* clientdata,<span class="hljs-type">void</span> *calldata)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout&lt;&lt;<span class="hljs-string">&quot;You have clicked:&quot;</span>&lt;&lt;++pressCounts&lt;&lt;<span class="hljs-string">&quot; times.&quot;</span>&lt;&lt;std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>	reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>	reader-&gt;<span class="hljs-built_in">Allow8BitBMPOn</span>();<br>	reader-&gt;<span class="hljs-built_in">SetDebug</span>(<span class="hljs-number">0</span>);<br>	reader-&gt;<span class="hljs-built_in">GlobalWarningDisplayOff</span>();<br>	reader-&gt;<span class="hljs-built_in">Update</span>();<br>	vtkSmartPointer&lt;vtkImageViewer2&gt; viewer = vtkSmartPointer&lt;vtkImageViewer2&gt;::<span class="hljs-built_in">New</span>();<br>	viewer-&gt;<span class="hljs-built_in">SetInputData</span>(reader-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>	vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; interactor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>	viewer-&gt;<span class="hljs-built_in">SetupInteractor</span>(interactor);<br>	viewer-&gt;<span class="hljs-built_in">Render</span>();<br>	<span class="hljs-comment">//第二步，设置回调函数。</span><br>	vtkSmartPointer&lt;vtkCallbackCommand&gt; mouseCallback = vtkSmartPointer&lt;vtkCallbackCommand&gt;::<span class="hljs-built_in">New</span>();<br>	mouseCallback-&gt;<span class="hljs-built_in">SetCallback</span>(MyCallbackFunc);<br>	<span class="hljs-comment">//第三步，将vtkCallbackCommand对象添加到观察者列表。</span><br>	interactor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(viewer-&gt;<span class="hljs-built_in">GetRenderWindow</span>());<br>	interactor-&gt;<span class="hljs-built_in">AddObserver</span>(vtkCommand::LeftButtonPressEvent, mouseCallback);<br>	interactor-&gt;<span class="hljs-built_in">Initialize</span>();<br>	interactor-&gt;<span class="hljs-built_in">Start</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021022024.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" /></p>
<p>首先，定义回调函数。回调函数的签名只能是以下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyCallbackFunc</span><span class="hljs-params">(vtkObject*obj,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eid, <span class="hljs-type">void</span>* clientdata, <span class="hljs-type">void</span> *calldata)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>其次是创建一个vtkCallbackCommand对象，并调用vtkCallbackCommand::SetCallback()设置第一步定义的回调函数。</p>
<p>最后是将vtkCallbackCommand对象添加到对象的观察者列表。</p>
<p>下面说另一种使用回调函数的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkSmartPointer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkConeSource.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkPolyDataMapper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkRenderWindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkRenderWindowInteractor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkCamera.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkActor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkRenderer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkCommand.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkBoxWidget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkTransform.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkInteractorStyleTrackballCamera.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vtkAutoInit.h&gt;</span></span><br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkRenderingOpenGL2);<br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkInteractionStyle);<br><br><span class="hljs-comment">//第一步</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vtkMyCallback</span> : <span class="hljs-keyword">public</span> vtkCommand<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> vtkMyCallback* <span class="hljs-title">New</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> vtkMyCallback; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">(vtkObject* caller, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eventId, <span class="hljs-type">void</span>* callData)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vtkTransform* t = vtkTransform::<span class="hljs-built_in">New</span>();<br>        vtkBoxWidget* widget = <span class="hljs-built_in">reinterpret_cast</span>&lt;vtkBoxWidget*&gt;(caller);<br>        widget-&gt;<span class="hljs-built_in">GetTransform</span>(t);<br>        widget-&gt;<span class="hljs-built_in">GetProp3D</span>()-&gt;<span class="hljs-built_in">SetUserTransform</span>(t);<br>        t-&gt;<span class="hljs-built_in">Delete</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkConeSource&gt; cone = vtkSmartPointer&lt;vtkConeSource&gt;::<span class="hljs-built_in">New</span>();<br>    cone-&gt;<span class="hljs-built_in">SetHeight</span>(<span class="hljs-number">3.0</span>);<br>    cone-&gt;<span class="hljs-built_in">SetRadius</span>(<span class="hljs-number">1.0</span>);<br>    cone-&gt;<span class="hljs-built_in">SetResolution</span>(<span class="hljs-number">10</span>);<br><br>    vtkSmartPointer&lt;vtkPolyDataMapper&gt; coneMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::<span class="hljs-built_in">New</span>();<br>    coneMapper-&gt;<span class="hljs-built_in">SetInputConnection</span>(cone-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br><br>    vtkSmartPointer&lt;vtkActor&gt; coneActor = vtkSmartPointer&lt;vtkActor&gt;::<span class="hljs-built_in">New</span>();<br>    coneActor-&gt;<span class="hljs-built_in">SetMapper</span>(coneMapper);<br><br>    vtkSmartPointer&lt;vtkRenderer&gt; ren1 = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>    ren1-&gt;<span class="hljs-built_in">AddActor</span>(coneActor);<br>    ren1-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>);<br><br>    vtkSmartPointer&lt;vtkRenderWindow&gt; renWin = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>    renWin-&gt;<span class="hljs-built_in">AddRenderer</span>(ren1);<br>    renWin-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br><br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; iren = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    iren-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renWin);<br><br>    vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt; style = vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt;::<span class="hljs-built_in">New</span>();<br>    iren-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br><br>    <span class="hljs-comment">//通过vtkBoxWidget可以控制coneActor的变换矩阵，从而实现coneActor的形变</span><br>    vtkSmartPointer&lt;vtkBoxWidget&gt; boxWidget = vtkSmartPointer&lt;vtkBoxWidget&gt;::<span class="hljs-built_in">New</span>();<br>    boxWidget-&gt;<span class="hljs-built_in">SetInteractor</span>(iren);<br>    boxWidget-&gt;<span class="hljs-built_in">SetPlaceFactor</span>(<span class="hljs-number">1.25</span>);<br>    boxWidget-&gt;<span class="hljs-built_in">SetProp3D</span>(coneActor);<br>    boxWidget-&gt;<span class="hljs-built_in">PlaceWidget</span>();<br><br>    <span class="hljs-comment">//第二步</span><br>    vtkSmartPointer&lt;vtkMyCallback&gt; callback = vtkSmartPointer&lt;vtkMyCallback&gt;::<span class="hljs-built_in">New</span>();<br>    <span class="hljs-comment">//第三步</span><br>    boxWidget-&gt;<span class="hljs-built_in">AddObserver</span>(vtkCommand::InteractionEvent, callback);<br><br>    <span class="hljs-comment">//激活Widget。按“i”键可以关闭或激活Widget。</span><br>    boxWidget-&gt;<span class="hljs-built_in">On</span>();<br><br>    iren-&gt;<span class="hljs-built_in">Initialize</span>();<br>    iren-&gt;<span class="hljs-built_in">Start</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021108926.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p>
<p>首先我们从vtkCommand派生出类vtkMyCallback，该类主要实现两个方法，一个是New()，用于为创建的对象申请内存；一个是Execute()，这是父类vtkCommand里定义的纯虚函数，其原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">(vtkObject *caller, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eventId,<span class="hljs-type">void</span> *callData)</span> </span>= <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>
<p>这意味着，只要从vtkCommand派生的类，都必须实现这个方法。而这个方法的作用就是一旦监听到所要监听的事件，就会自动地调用该方法。监听到事件后，要完成什么样的操作，都是在Execute()方法里实现。</p>
<hr />
<p>在vtkObject.h文件里面有一个受保护的数据成员MTime，与这个MTime相关的公共接口有GetMTime()
(返回MTime的值)以及Modified()。MTime全称是Modification
Time，vtkObject实现了可视化管线。</p>
<hr />
<h2 id="可视化管线">可视化管线😎</h2>
<p>在之前的例子中，我们可以找到以下列出的类或其子类：</p>
<p>vtkProp; vtkAbstractMapper;vtkProperty; vtkCamera; vtkLight;
vtkRenderer; vtkRenderWindow;vtkRenderWindowInteractor; vtkTransform;
vtkLookupTable</p>
<p>我们发现，这些类都是与数据显示或者说渲染相关的。用一个专业的词汇来说，它们构成了VTK的渲染引擎(Rendering
Engine)。渲染引擎主要负责数据的可视化表达，它是VTK里的两个重要模块之一，另外一个重要的模块就是可视化管线(Visualization
Pipeline)。</p>
<p>可视化管线是指用于获取或创建数据，处理数据，以及把数据写入文件或者把数据传递给渲染引擎进行显示，这样的一种结构在VTK里就称之为可视化管线。数据对象(Data
Object)、处理对象(Process Object)和数据流方向(Direction of Data
Flow)是可视化管线的三个基本要素。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkSmartPointer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkStructuredPointsReader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkRenderer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkRenderWindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkRenderWindowInteractor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkMarchingCubes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkPolyDataMapper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkActor.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vtkAutoInit.h&gt;</span></span><br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkRenderingOpenGL2);<br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkInteractionStyle);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//读入Structured_Points类型的vtk文件。</span><br>    vtkSmartPointer&lt;vtkStructuredPointsReader&gt; reader = vtkSmartPointer&lt;vtkStructuredPointsReader&gt;::<span class="hljs-built_in">New</span>();<br>    <span class="hljs-comment">// 此 vtk 文件地址 ： https://masterwangzx.com/assets/vtk_res/head.vtk</span><br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;head.vtk&quot;</span>);<br><br>    <span class="hljs-comment">//用移动立方体法提取等值面。</span><br>    vtkSmartPointer&lt;vtkMarchingCubes&gt; marchingCubes = vtkSmartPointer&lt;vtkMarchingCubes&gt;::<span class="hljs-built_in">New</span>();<br>    marchingCubes-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>    marchingCubes-&gt;<span class="hljs-built_in">SetValue</span>(<span class="hljs-number">0</span>, <span class="hljs-number">500</span>);<br><br>    <span class="hljs-comment">//将生成的等值面数据进行Mapper</span><br>    vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::<span class="hljs-built_in">New</span>();<br>    mapper-&gt;<span class="hljs-built_in">SetInputConnection</span>(marchingCubes-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br><br>    <span class="hljs-comment">//把Mapper的输出送入渲染引擎进行显示</span><br>    <span class="hljs-comment">//渲染引擎部分</span><br>    vtkSmartPointer&lt;vtkActor&gt; actor = vtkSmartPointer&lt;vtkActor&gt;::<span class="hljs-built_in">New</span>();<br>    actor-&gt;<span class="hljs-built_in">SetMapper</span>(mapper);<br><br>    vtkSmartPointer&lt;vtkRenderWindow&gt; renWin = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>    vtkSmartPointer&lt;vtkRenderer&gt; renderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; interactor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br><br>    renderer-&gt;<span class="hljs-built_in">AddActor</span>(actor);<br>    renWin-&gt;<span class="hljs-built_in">AddRenderer</span>(renderer);<br>    interactor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renWin);<br><br>    interactor-&gt;<span class="hljs-built_in">Initialize</span>();<br>    interactor-&gt;<span class="hljs-built_in">Start</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021639654.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p>
<p>在我们之前的项目中，项目的可视化管线一般是这样的：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021455051.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;" /></p>
<p>在上面的例子中的可视化管线是这样的：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021456235.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>上例中多了一个vtkMarchingCubes用于处理读入的数据。<strong>在VTK里，我们把与vtkMarchingCubes类似的对数据做处理的类称为Filter</strong>。我们还可以抽象出更一般的VTK可视化管线结构图：</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021457013.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;" /></p>
<p>Source是指用于创建数据(如vtkCylinderSource)或者读取数据(如vtkBMPReader、vtkStructuredPointsReader等)的类的统称，即VTK的数据源。Source输出的数据作为Filter的输入，经Filter处理以后(可以经多个Filter处理)，生成新的数据。Filter的输出可以直接写入文件，或者经Mapper变换后送入渲染引擎进行渲染、显示，结束可视化管线。我们知道，可视化管线的三要素分别是数据对象、处理对象和数据流方向，Source、Filter和Mapper一起就构成了处理对象，它们的区别是基于数据流的初始化、维持和终止。根据数据的生成方式，Source可以分为Procedural对象(如vtkCylinderSource，通过程序代码生成相关的数据)和Reader对象(如vtkBMPReader，从外部文件中导入数据)。</p>
<p>关于Source、Filter和Mapper的区别可以简单地通过下图表示。Source没有输入，但至少有一个输出；Filter可以有一个或多个输入，产生一个或多个输出；Mapper接受一个或多个的输出，但没有输出，写文件的Writer(如vtkBMPWriter)可以看作是Mapper，负责把数据写入文件或者流(Stream)中，因此，Mapper是可视化管线的终点，同时也是可视化管线和渲染引擎(有时也称之为图形管线)的桥梁。</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021501637.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>可视化管线里各个模块的连接是通过接口SetInputConnection()和GetOutputPort()来完成的。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">marchingCubes-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br></code></pre></div></td></tr></table></figure>
<p>上行代码把reader的输出(由GetOutputPort()得到)作为marchingCubes的输入(SetInputConnection()设置其输入)。</p>
<p>vtkMarchingCubes作为Filter只接受一个输入，Filter概括起来有以下三种类型：单个输入，产生单个输出；多个输入，产生单个输出，但输出的数据可有多种用途，比如，我们读入数据以后，可以对其作等值面提取，另外还可以针对读入的数据生成轮廓线(Outline)；第三种Filter是单个输入，产生多个输出。</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021505275.png" srcset="/img/loading.gif" lazyload style="zoom:75%;" /></p>
<hr />
<p>可视化管线连接完成后，必须有一种机制来控制管线的执行。比如某些时候，对某一部分数据做了改变，我们希望得到的结果是：改变的这部分数据在可视化管线里作更新，而其他没做改变的数据则不要去惊动它。下图中，假如Filter
D的输入发生了变化，E和F是依赖于D的输入的，所以红色虚线框内的部分是需要重新执行的管线，而C和G是另外一个分支，D输入改变不影响C和G，所以，为了节省运行时间，C和G是不需要重新执行的。毕竟对于三维的应用程序来说，一般所处理的数据都是大得惊人的，如果真能做到这样，也有利于提高程序的运行速率。</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021521475.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<p>VTK采用一种叫做“惰性赋值”(LazyEvaluation)的方案来控制管线的执行，惰性赋值是指根据每个对象的内部修改时间来决定什么时候执行管线，只有当你或者程序发出“请求数据”时，管线才会被执行(前面提到vtkObject里有一个重要的成员变量MTime，管线里的每个从vtkObject派生的类的对象都会跟踪自己的内部修改时间，当遇到“请求数据”时，该对象会比较这个修改时间，如果发现修改时间发生了改变，对象就会执行。)。换言之，VTK是采用命令驱动(Demand
Driven)的方法来控制管线的执行，这种方法的好处是，当对数据对象作了更改时，不必立即作计算，只有当发出请求时才开始处理，这样能最小化计算所需的时间，以便更流畅地与数据进行交互。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>    vtkImageData* imageData = reader-&gt;<span class="hljs-built_in">GetOutput</span>();<br>    <span class="hljs-comment">// 删除下面这行代码是有问题的</span><br>    <span class="hljs-comment">// reader-&gt;Update();</span><br>    <span class="hljs-type">int</span> extent[<span class="hljs-number">6</span>];<br>    imageData-&gt;<span class="hljs-built_in">GetExtent</span>(extent);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Extent of image:&quot;</span> &lt;&lt; extent[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; extent[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; extent[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span><br>        &lt;&lt; extent[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; extent[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; extent[<span class="hljs-number">5</span>] &lt;&lt; std::endl;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码是无法输出这张图片的长宽等信息的，主要原因在于在渲染引擎的最后，当我们调用Render()函数的时候，Actor就会收到渲染请求，接着Actor会请求Mapper给它发送数据，而Mapper又会请求上一层的Filter的数据，Filter最后去请求Source给它数据，于是，整条管线就被执行。除非像上面的代码段里列出的，读入数据以后，中间想要输出某些信息，在得到这些信息之前，你就应该显性地调用Update()函数。</p>
<p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021537566.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" /></p>
<hr />
<h2 id="总结">总结🪔</h2>
<p>vtkObjectBase和vtkObject是VTK里两个重要的父类，vtkObjectBase采用引用计数和智能指针的技术来管理VTK对象的内存分配与回收。vtkObjectBase定义了运行时类型识别及状态信息输出的相关接口，有助于调试VTK应用程序。VTK框架里，大多数的类都是从vtkObject派生，vtkObject实现了观察者/命令(Observer/Command)设计模式，内部维护一个修改时间，用于控制可视化管线的执行。可视化管线是VTK里的重要概念，管线的连接应该使用SetInputConnection()/GetOutputPort()接口进行连接。VTK采用“惰性赋值”(Lazy
Evaluation)的方案来控制管线的执行，只有当发出“请求数据”时，管线才会被执行。好处是，当对数据对象作了更改时，不必立即作计算，只有当发出请求时才开始处理，这样能最小化计算所需的时间，以便更流畅地进行交互。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/VTK/">VTK</a>
                    
                  </div>
                
              </div>
              <p class="note note-warning">
                <strong>本文作者: </strong><a href="/">fly-beep</a> <br>
                <strong>本文链接: </strong><a href="https://fly-beep.top/post/4036df29.html">https://fly-beep.top/post/4036df29.html</a> <br>
                <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                   </p>
                   
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/d287c7b.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">VTK学习笔记（三）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/702033f1.html">
                        <span class="hidden-mobile">VTK学习笔记（一）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@waline/client@1/dist/Waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://waline-3s11u25y3-fly-beep.vercel.app/","path":"window.location.pathname","placeholder":null,"meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili"],"dark":"html[data-user-color-scheme=\"dark\"]","avatar":"retro","avatarCDN":"https://seccdn.libravatar.org/avatar/","avatarForce":false,"wordLimit":0,"pageSize":10,"highlight":true},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        new Waline(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          Fluid.plugins.initFancyBox('#waline .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> <div> 人生天地间，忽如远行客。 </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/Cherry.min.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
