<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库期末总结</title>
    <link href="/post/48d4ae84.html"/>
    <url>/post/48d4ae84.html</url>
    
    <content type="html"><![CDATA[<h1 id="数据库系统期末总结">数据库系统期末总结</h1><p>主要针对数据库系统期末复习中的一些重点进行归纳总结</p><span id="more"></span><h3 id="数据库系统概述">数据库系统概述🐲</h3><ul><li><p>三级模式：</p><ul><li>外模式、用户模式、子模式、局部模式、（视图）</li><li>逻辑模式、概念模式、全局模式、（模式）</li><li>内模式、物理模式、存储模式</li></ul></li><li><p>两层映像：</p><ul><li>E-C ： 外 → 逻辑</li><li>C-I ： 逻辑 → 内</li></ul></li><li><p>两个独立性：</p><ul><li>逻辑数据独立性：当逻辑模式改变，不用改外模式，改 E-I 即可</li><li>物理数据独立性：当内模式改变，不用改逻辑模式，改 C-I 即可</li></ul></li><li><p>模式：对数据的抽象</p></li><li><p>模型：对模式的抽象</p></li></ul><h3 id="关系数据模型">关系数据模型🦴</h3><ul><li>主属性：包含在任意一个<strong>候选码</strong>中的属性</li><li>主码：候选码中的一个</li><li>两个关系通常是通过<strong>外码</strong>联系起来的</li><li><span class="math inline">\(\sigma\)</span> 操作的优先级： 非 &gt; <span class="math inline">\(\wedge\)</span> &gt; <span class="math inline">\(\vee\)</span></li><li><span class="math inline">\(\pi\)</span> 操作自带去重</li><li>完整性：<ul><li>实体完整性：主码不能为空</li><li>参数完整性：外码必须有对应值或空值</li><li>用户自定义完整性</li></ul></li><li><span class="math inline">\(\theta\)</span>连接<strong>不会去重</strong>、等值连接<strong>不会去重</strong>、自然连接<strong>会去重</strong></li><li>重命名：<span class="math inline">\(\rho\)</span></li><li><span class="math inline">\(R ÷ S= \pi_{R-S}(R)-\pi_{R-S}((\pi_{R-S}(R)×S)-R)\)</span></li><li>外连接是为了防止在连接（<span class="math inline">\(\theta\)</span>连接）操作后会出现元组数据的丢失的情况（空值）</li><li>关系演算：<span class="math inline">\(\{ t|P(t)\}\)</span> ，P是一个谓语</li><li>优先级： ( ) &gt; <span class="math inline">\(\theta\)</span> &gt; <span class="math inline">\(\exists\)</span> &gt; <span class="math inline">\(\forall\)</span> &gt; 非 &gt; <span class="math inline">\(\wedge\)</span> &gt; <span class="math inline">\(\vee\)</span> （这里的 <span class="math inline">\(\theta\)</span> 是指比较运算符）</li><li>关系域演算：<span class="math inline">\(\{ &lt;x_1,x_2...x_n&gt; | P(x_1,x_2...x_n) \}\)</span></li></ul><h3 id="sql">SQL🦐</h3><ul><li><p><code>insert into table_name values (a,b,c)</code></p></li><li><p><code>insert into table_name 子查询</code></p></li><li><p><code>asc</code>为升序（默认），<code>desc</code>为降序</p></li><li><p><code>update table_name set a=b where c=d</code></p></li><li><div class="code-wrapper"><pre class="mysql"><code>  select 字段列表[字段别名]   from 数据源  [where条件字句]  [group by 字句]  [having 字句]  [order by 字句]  [limit 字句]</code></pre></div></li><li><p>表达式 (not) in 子查询</p></li><li><p>子查询只能外层向内层传参数</p></li><li><p>表达式 <span class="math inline">\(\theta\ some/all\)</span> 子查询</p></li><li><p>in <span class="math inline">\(\leftrightarrow\)</span> =some、not in <span class="math inline">\(\leftrightarrow\)</span> &lt;&gt;all</p></li><li><p>子查询 union (all) / intersect (all) / except (all) ，其中带有 <strong>all 不删除重复元组</strong></p></li><li><p>任何<strong>没有出现</strong>在group by子句中的属性如果出现在select子句中的话，它<strong>只能出现在聚集函数的内部</strong>，否则这样的查询就是错误的</p></li><li><p>只有 COUNT 不忽略 null</p></li><li><p><span class="math inline">\(from\ table_{name1}\ (natural)\ inner\ join / left\ outer\ join / right\ outer\ join / full\ outer\ join\ table_{name2}\ (on ...)\)</span></p></li><li><p><span class="math inline">\(create\ view\ view_{name}\ as\)</span> 子查询</p></li><li><p>不能更新的view：</p><ul><li>select 目标列包含聚集函数</li><li>select 子句使用distinct</li><li>包含group by</li><li>包含经算术表达式计算出的列</li><li>由单个表的列组成但未包含主键</li></ul></li></ul><h3 id="概念数据库设计">概念数据库设计🪂</h3><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205201502437.png" /></p><h3 id="逻辑数据库设计">逻辑数据库设计🚍</h3><ul><li><span class="math inline">\(armstrong公理\)</span>：<ul><li><span class="math inline">\(Y\subseteq X \subseteq U,则X → Y\)</span></li><li><span class="math inline">\(X \rightarrow Y \in F.Z \subseteq U,则XZ \rightarrow YZ\)</span></li><li><span class="math inline">\(X \rightarrow Y,Y \rightarrow Z,则X \rightarrow Z\)</span></li><li><span class="math inline">\(X \rightarrow Y,X\rightarrow Z,则X\rightarrow YZ\)</span></li><li><span class="math inline">\(X\rightarrow Y,WY\rightarrow Z,则XW\rightarrow Z\)</span></li><li>$XY,Z Y,则XZ $</li></ul></li><li>最小覆盖（最小依赖集）计算：<ul><li>将F中的任意函数依赖 <span class="math inline">\(X → Y\)</span>替换为右部仅包含一个属性的函数依赖</li><li>删除左部的冗余属性</li><li>删除冗余函数依赖</li></ul></li><li>NF总结<ul><li>1NF 保证分量不可分</li><li>2NF 保证只有主键才能推出其他，消除非主属性对<strong>候选键</strong>的部分函数依赖</li><li>3NF 消除非主属性对<strong>候选键</strong>的传递函数依赖</li><li>BCNF 保证主属性完全函数依赖于<strong>候选键</strong>、或者满足1NF并且最小覆盖的左部都是<strong>候选键</strong></li></ul></li><li>识别无损连接分解：画表格</li><li>识别函数依赖保持：函数依赖的并集是否可以覆盖F</li><li>关系模式分解为 3NF：将每一个函数依赖单独组成一个关系，然后把左部相同的进行合并【保持依赖】</li><li>关系模式分解为 BCNF：将左侧不含候选键的函数依赖单独组成一个关系，将包含候选键的组成一关系【无损连接】</li></ul><h3 id="物理数据库设计">物理数据库设计🥡</h3><ul><li>索引文件组织方式：<ul><li>排序索引文件</li><li>散列索引文件</li></ul></li><li><span class="math inline">\(create\ index\ index_{name}\ on\ table_{name}(a,b,c)\)</span></li><li>稠密索引 VS 稀疏索引<ul><li>稠密索引：索引文件中包含了主文件对应字段的所有不同值</li><li>稀疏索引：索引文件中包含了主文件对应字段的部分不同值</li></ul></li><li>主索引 VS 辅助索引<ul><li>主索引通常是对每一存储块有一个索引项（稀疏索引）</li><li>辅助索引是稠密索引</li><li>一个主文件仅可以有一个主索引，但可以有多个辅助索引</li><li>主索引通常建立于主码/排序码上面；辅助索引建立于其他属性上面</li><li>主索引可以重新组织主文件数据，但辅助索引不能改变主文件数据</li></ul></li><li>聚簇索引 VS 非聚簇索引<ul><li>聚簇索引：索引中邻近的记录在主文件中也是临近存储的</li><li>非聚簇索引：索引中邻近的记录在主文件中不一定是邻近存储的</li><li>主索引是聚簇索引、辅助索引是非聚簇索引</li></ul></li></ul><h3 id="数据库存储">数据库存储🪢</h3><ul><li>CPU 到 主存之间按存储字访问，主存 到 外存之间按块/IO访问</li><li>操作系统对数据组织：FAT（文件分配表） -- 目录（文件夹） -- 磁盘块/簇</li><li>数据库中表所占磁盘块的分配方法：<ul><li>连续分配 【访问困难】</li><li>链接分配 【访问速度慢】</li><li>按簇分配 (簇是若干连续的磁盘块,簇之间靠指针连接)</li><li>索引分配(索引块中存放指向实际data块的指­针)</li></ul></li><li>（主）文件组织方法：<ul><li>无序记录文件（堆文件）：数据库重组是通过移走被删除的记录使有效记录连续存放，从而回收那些由删除记录而产生的未利用空间</li><li>有序记录文件（排序文件）：数据库重组是将溢出文件合并到主文件中，并恢复主文件中的记录顺序</li><li>散列文件</li><li>聚簇文件</li></ul></li></ul><h3 id="索引结构">索引结构🧆</h3><ul><li><p>B+树</p><ul><li>插入：分裂</li><li>分裂后增加父节点中的指针和键（右节点的第一个值）</li><li>删除：合并</li><li>合并后删除父节点中的指针和键</li></ul></li><li><p>可扩展散列：每次增加两倍</p></li><li><p>线性散列</p><ul><li><p>位是从右端（低位）开始取</p></li><li><p>n：当前的桶数、r：当前散列表中的记录总数、要求r&lt;= 1.7n</p></li><li><table><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">000</td><td style="text-align: center;">000</td><td style="text-align: center;">...</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">01</td><td style="text-align: center;">01</td><td style="text-align: center;">001</td><td style="text-align: center;">001</td><td style="text-align: center;">...</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">10</td><td style="text-align: center;">10</td><td style="text-align: center;">010</td><td style="text-align: center;">010</td><td style="text-align: center;">...</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">11</td><td style="text-align: center;">011</td><td style="text-align: center;">011</td><td style="text-align: center;">...</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">100</td><td style="text-align: center;">100</td><td style="text-align: center;">...</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">101</td><td style="text-align: center;">...</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">...</td></tr></tbody></table></li></ul></li></ul><h3 id="查询执行">查询执行👺</h3><ul><li><p>连接</p><ul><li>M ≥ 3（考虑输出）<ul><li><span class="math inline">\(B_R+B_R × B_S\)</span></li></ul></li><li>$M ≥ B_R+B_S $<ul><li><span class="math inline">\(B_R+B_S\)</span></li></ul></li><li><span class="math inline">\(M &gt; B_R，B_S≥B_R\)</span><ul><li><span class="math inline">\(B_R+B_S\)</span></li></ul></li><li><span class="math inline">\(B_S≥M，B_R≥M\)</span><ul><li><span class="math inline">\(\frac{B_RB_S}{M-2} + B_S\)</span> （考虑输出）</li></ul></li><li>排序<ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ M^2\)</span></li></ul></li><li>哈希<ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ (M-1)^2\)</span></li></ul></li><li>索引<ul><li>聚簇索引<ul><li><span class="math inline">\(B(R) + T(R)\left \lceil \frac{B(S)}{V(S,K)} \right \rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>非聚簇索引<ul><li><span class="math inline">\(B(R) + \frac{T(R)T(S)}{V(S,K)}\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li></ul></li></ul></li><li><p>去重（投影）</p><ul><li>一趟扫描<ul><li><span class="math inline">\(B(R)\)</span></li><li><span class="math inline">\(B(\delta(R))≤M\)</span></li></ul></li><li>排序<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ M^2\)</span></li></ul></li><li>哈希<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ (M-1)^2\)</span></li></ul></li></ul></li><li><p>分组</p><ul><li>一趟扫描<ul><li><span class="math inline">\(B(R)\)</span></li><li>所有分组可在内存中完整保存</li></ul></li><li>排序<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ M^2\)</span></li></ul></li><li>哈希<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ (M-1)^2\)</span></li></ul></li></ul></li><li><p>排序</p><ul><li><span class="math inline">\(3 B(R)\)</span> 【不考虑写回】、 <span class="math inline">\(4 B(R)\)</span> 【考虑写回】</li></ul></li><li><p>并、差、交</p><ul><li><p>集合上操作需要去重、包上操作不用去重</p></li><li><p>一趟扫描</p><ul><li><span class="math inline">\(B(R)+B(S)\)</span></li><li><span class="math inline">\(min(B(R),B(S)) ≤ M-1\)</span></li></ul></li><li><p>排序</p><ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ M^2\)</span></li></ul></li><li><p>哈希</p><ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ (M-1)^2\)</span></li></ul></li></ul></li><li><p>选择</p><ul><li>扫描<ul><li><span class="math inline">\(B(R)\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>哈希<ul><li><span class="math inline">\(\left \lceil \frac{B(R)}{V(R,K)} \right \rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>索引<ul><li>聚簇索引<ul><li><span class="math inline">\(\left \lceil \frac{B(R)}{V(R,K)} \right \rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>非聚簇索引<ul><li><span class="math inline">\(\left \lceil \frac{T(R)}{V(R,K)} \right \rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li></ul></li></ul></li></ul><h3 id="查询优化">查询优化🤡</h3><ul><li>逻辑查询优化：<ul><li>把形如<span class="math inline">\(\sigma_{F_1 \wedge F_2 \wedge ...\wedge F_n }(E)\)</span>的选择表达式变成串接形式<span class="math inline">\(\sigma_{F_1}(\sigma_{F_2}(...(\sigma_{F_n}(E)))\)</span></li><li>将<span class="math inline">\(\sigma\)</span> 移动到树底</li><li>将<span class="math inline">\(\pi\)</span> 移动到底部，若是对某表达式的所有属性进行的，则删去</li><li>将<span class="math inline">\(\sigma\)</span> 和<span class="math inline">\(\pi\)</span> 组合为<span class="math inline">\(\sigma\)</span> 后跟<span class="math inline">\(\pi\)</span> 或单个的形式</li></ul></li><li>物理查询优化：<ul><li>掌握 <span class="math inline">\(\pi\)</span> 、<span class="math inline">\(\sigma_{A=c}\)</span> 、<span class="math inline">\(\sigma_{A&lt;c}\)</span> 、<span class="math inline">\(and\)</span> 、<span class="math inline">\(or\)</span> 、自然连接的代价估计</li></ul></li></ul><h3 id="并发控制">并发控制📮</h3><ul><li><p>所有隔离级别均可以解决丢失修改问题</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205201127663.png"/></p><table><thead><tr class="header"><th style="text-align: center;">隔离级别</th><th style="text-align: center;">脏读</th><th style="text-align: center;">不可重复读</th><th style="text-align: center;">幻读</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">读未提交</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;">读已提交</td><td style="text-align: center;">×</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="odd"><td style="text-align: center;">可重复读</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;">可串行化</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td></tr></tbody></table></li><li><p>判断冲突可串行化调度：画图，判断有无环</p></li><li><p>X（排他）锁、S（读写）锁、U（更新）锁、I（增量）锁</p></li><li><p>两段锁协议</p><ul><li>读写数据之前要获得锁。每个事务中所有封锁请求先于任何一个解锁请求</li><li>两阶段：加锁段，解锁段。加锁段中不能有解锁操作，解锁段中不能有加锁操作</li></ul></li><li><p>如果一组事务中每个事务都在等待其他事务释放锁，则这组事务形成死锁</p></li><li><p>事务产生死锁当且仅当等待图中有环</p></li></ul><h3 id="故障恢复">故障恢复🚢</h3><ul><li><p>故障及其解决方法：</p><ul><li>事务故障：redo、undo事务</li><li>系统故障：运行日志，从检查点开始恢复<ul><li>检查点表征了:在检查点之前内存中数据与介质中数据是保持一致的</li></ul></li><li>介质故障：副本</li></ul></li><li><p>缓冲区处理策略</p><ul><li>Force:内存中的数据最晚在commit的时候写入磁盘</li><li>No force:内存中的数据可以一直保留，在commit之后过一段时间再写入磁盘。(此时在系统崩溃的时候可能还没写入到磁盘，需要redo)</li><li>No steal:不允许在事务commit之前把内存中的数据写入磁盘</li><li>Steal:允许在事务commit之前把内存中的数据写入磁盘。(此时若系统在commit之前崩溃时，已经有数据写入到磁盘了，要恢复到崩溃前的状态，需要Undo)</li><li>一般选用 Steal + No force</li></ul></li><li><p>undo日志：</p><ul><li>&lt;T,X,v&gt;中v为x的旧值</li><li>先OUTPUT再COMMIT</li></ul></li><li><p>redo日志：</p><ul><li>&lt;T,X,v&gt;中v为x的新值</li><li>先COMMIT再OUTPUT</li></ul></li><li><p>检查点</p><ul><li><p><code>&lt;begin checkpoint (T1,T2...Tn)&gt;</code></p><p><code>...</code></p><p><code>&lt;end checkpoint&gt;</code></p><p>redo 从 <code>begin checkpoint</code>开始扫描</p><p>undo 扫描到T1，T2 ... Tn 中最早的事务 Ti 的日志记录<code>&lt;Ti , begin&gt;</code>为止</p></li></ul></li><li><p>一般使用 &lt;T,X,u,v&gt;，其中旧值为u，新值为v</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个AES加密算法的工具类</title>
    <link href="/post/abbb7a99.html"/>
    <url>/post/abbb7a99.html</url>
    
    <content type="html"><![CDATA[<h1 id="一个aes加密算法的工具类android">一个AES加密算法的工具类（Android）</h1><p>我想要实现对一个字符串用AES加密算法进行加密，解密的操作，本来以为很容易，但是网上找到很多都是不能用的，下面这份代码亲测可用，于是记录之。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.util.Base64;<br><span class="hljs-keyword">import</span> android.util.Log;<br><br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AESUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> AESUtils.class.getSimpleName();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 采用AES加密算法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 字符编码(用哪个都可以，要注意new String()默认使用UTF-8编码 getBytes()默认使用ISO8859-1编码)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Charset</span> <span class="hljs-variable">CHARSET_UTF8</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加解密算法/工作模式/填充方式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CIPHER_ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES/ECB/PKCS5Padding&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789abcdef&quot;</span>; <span class="hljs-comment">//这里只要是16位字符即可</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * AES 加密</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data      待加密内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回Base64转码后的加密数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建AES秘钥</span><br>            <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">secretKeySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(secretKey.getBytes(CHARSET_UTF8), KEY_ALGORITHM);<br>            <span class="hljs-comment">// 创建密码器</span><br>            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);<br>            <span class="hljs-comment">// 初始化加密器</span><br>            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);<br>            <span class="hljs-type">byte</span>[] encryptByte = cipher.doFinal(data.getBytes(CHARSET_UTF8));<br>            <span class="hljs-comment">// 将加密以后的数据进行 Base64 编码</span><br>            <span class="hljs-keyword">return</span> base64Encode(encryptByte);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            handleException(<span class="hljs-string">&quot;encrypt&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * AES 解密</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> base64Data 加密的密文 Base64 字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decrypt</span><span class="hljs-params">(String base64Data)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] data = base64Decode(base64Data);<br>            <span class="hljs-comment">// 创建AES秘钥</span><br>            <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">secretKeySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(secretKey.getBytes(CHARSET_UTF8), KEY_ALGORITHM);<br>            <span class="hljs-comment">// 创建密码器</span><br>            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);<br>            <span class="hljs-comment">// 初始化解密器</span><br>            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);<br>            <span class="hljs-comment">// 执行解密操作</span><br>            <span class="hljs-type">byte</span>[] result = cipher.doFinal(data);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(result, CHARSET_UTF8);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            handleException(<span class="hljs-string">&quot;decrypt&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将 字节数组 转换成 Base64 编码</span><br><span class="hljs-comment">     * 用Base64.DEFAULT模式会导致加密的text下面多一行（在应用中显示是这样）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">base64Encode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>        <span class="hljs-keyword">return</span> Base64.encodeToString(data, Base64.NO_WRAP);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将 Base64 字符串 解码成 字节数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] base64Decode(String data) &#123;<br>        <span class="hljs-keyword">return</span> Base64.decode(data, Base64.NO_WRAP);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleException</span><span class="hljs-params">(String methodName, Exception e)</span> &#123;<br>        e.printStackTrace();<br>        Log.e(TAG, methodName + <span class="hljs-string">&quot;----&gt;&quot;</span> + e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AES加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理期末总结</title>
    <link href="/post/e5a09991.html"/>
    <url>/post/e5a09991.html</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理期末总结">编译原理期末总结</h1><p>主要针对编译原理期末复习中的一些重点进行归纳总结</p><span id="more"></span><h3 id="first集follow集select集计算">FIRST集、FOLLOW集、SELECT集计算🎃</h3><p>FIRST集：</p><ul><li>FIRST集中是可以有<span class="math inline">\(\xi\)</span>的</li><li>如果遇到 <span class="math inline">\(E → aF\)</span> 之类的，FIRST(E)中加入a</li><li>如果遇到 <span class="math inline">\(E → FT\)</span> 之类的，FIRST(E)中加入FIRST(F)中内容，如果 <span class="math inline">\(F → \xi\)</span> ，则 FIRST(E)中加入FIRST(T)中内容，可以一直往后顺延至某一个终结符或FIRST集中没有<span class="math inline">\(\xi\)</span> 的非终结符</li></ul><p>FOLLOW集：</p><ul><li>FOLLOW集中没有 <span class="math inline">\(\xi\)</span></li><li>先在开始符号 S 的FOLLOW中加入 <span class="math inline">\(\$\)</span></li><li>如果遇到 $ ... → FT$ 之类的，FOLLOW(F)中加入 FIRST(T)-<span class="math inline">\(\xi\)</span></li><li>如果遇到 $ ... → Fa$ 之类的，FOLLOW(F)中加入a</li><li>如果遇到 <span class="math inline">\(E → ...T\)</span> 之类的，FOLLOW(T)中加入FOLLOW(E)</li></ul><p>SELECT集：</p><ul><li>计算SELECT集时，要把所有的语句拆成不含 | 的形式</li><li>如果遇到 <span class="math inline">\(E → T\)</span>之类的，如果FIRST(T)不包含 <span class="math inline">\(\xi\)</span> ，则SELECT=FIRST(T)，如果FIRST(T)包含 <span class="math inline">\(\xi\)</span> ，则SELECT=(FIRST(T)- <span class="math inline">\(\xi\ ) \cup\)</span> FOLLOW(E)</li></ul><h3 id="ll文法和lr文法的判定条件">LL文法和LR文法的判定条件🚀</h3><ul><li>LL文法 文法G是LL(1)的，当且仅当G的任意两个具有相同左部的产生式A → α | β 满足条件：<ol type="1"><li>文法不含左递归（即不存在终结符a使得α 和β都能够推导出以a开头的串）</li><li>α和β至多有一个能推导出ε</li><li>如果 β <span class="math inline">\(\Rightarrow ^ *\)</span> ε，则FIRST(α) ∩ FOLLOW(A) =Φ；如果 α <span class="math inline">\(\Rightarrow ^ *\)</span> ε，则FIRST(β) ∩ FOLLOW(A) =Φ；</li></ol></li><li>LR文法<ul><li><p>LR(0)文法</p><p>如果文法对应的自动机中不存在<code>移进-归约冲突</code>和<code>归约-归约冲突</code>则为LR(0)文法。换句话说LR(0)文法分析不能解决这两种冲突，所以范围最小。移进-归约冲突就是在同一个项集族中同时出现了可以移进的产生式和可以归约的产生式。归约-归约冲突类似。</p></li><li><p>SLR文法</p><p>SLR文法中还是存在<code>归约-归约冲突</code>和存在<code>移进-归约冲突</code>，但是如果可以用FOLLOW集解决则是SLR文法。换句话说，SLR文法分析过程也不一定能解决这两种冲突。用FOLLOW集来处理出现了<code>归约-规约冲突</code>或<code>移进-归约冲突</code>的两条产生式，如果其FOLLOW集相交为空则为SLR文法，反之不是。</p></li><li><p>LR(1)文法</p><p>题目出现的基本都是LR(1)文法</p></li><li><p>LALR文法</p><p>LALR文法中存在<code>归约-归约冲突</code>。</p></li></ul></li></ul><h3 id="赋值语句翻译">赋值语句翻译🦊</h3><ul><li><p>if-else-then语句：</p><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown">if x&gt;1<br>then x=0<br>else x=2<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">nif x&gt;1 goto n+2<br>n+1goto n+4<br>n+2x=0<br>n+3goto n+5<br>n+4x=2<br>n+5...<br></code></pre></td></tr></table></figure></li><li><p>while语句：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">while i&gt;0<br>do i=i+1<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">nif i&gt;0 goto n+2<br>n+1goto n+5<br>n+2t=i+1<br>n+3i=t<br>n+4goto n<br>n+5...<br></code></pre></td></tr></table></figure></li><li><p>逻辑运算符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">if ( x&lt;100 || x&gt;200 &amp;&amp; x!=y )<br><span class="hljs-code">x=0;</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">nif x&lt;100 goto n+6 <br>n+1goto n+2<br>n+2if x &gt; 200 goto n+4<br>n+3goto n+7 <br>n+4if x!=y goto n+6<br>n+5goto n+7<br>n+6x=0<br>n+7...<br></code></pre></td></tr></table></figure></li></ul><h3 id="控制语句的sdt回填">控制语句的<code>SDT</code>&amp;回填⛄</h3><p>控制流语句：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1if B then S1<br>2if B then S1 else S2<br>3while B S1<br></code></pre></td></tr></table></figure><p>布尔表达式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1B1 or B2<br>2B1 and B2<br>3not B<br>4(B)<br>5E1 relop E2<br>6true<br>7false<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052245722.png" alt="控制流语句SDT" style="zoom:75%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052245278.png" alt="布尔表达式SDT" style="zoom:75%;" /></p><p>控制流SDT编写：</p><ul><li>分析每一个非终结符之前：<ul><li>先计算继承属性</li><li>再观察代码结构图中该非终结符对应的方框顶部是否有<code>导入箭头</code>。如果有，调用<code>label()</code>函数</li></ul></li><li>上一个代码框执行完<code>不顺序执行</code>下一个代码框时，生成一条<code>显式跳转</code>指令</li><li>有<code>自下而上的箭头</code>时，设置<code>begin</code>属性。且定义后<code>直接调用label( )函数</code>绑定地址</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052148748.png" alt="控制流语句回填" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052146083.png" alt="布尔表达式的回填" style="zoom:67%;" /></p><p>回填SDT编写：</p><ul><li>文法改造<ul><li>在list箭头指向的位置设置标记非终结符M</li></ul></li><li>在产生式末尾的语义动作中<ul><li>计算综合属性</li><li>调用backpatch ( )函数回填各个list</li></ul></li></ul><p>注：上述语句的<strong>代码结构图</strong>非常重要</p><h3 id="数据流分析技术">数据流分析技术🪆</h3><h4 id="到达定值分析">到达定值分析👨🏻‍🚀</h4><p>对 <span class="math inline">\(d_i\)</span>进行分析，gen是本基本块中的所有 <span class="math inline">\(d_i\)</span>，kill是不在本基本块内，但是和本基本块内 <span class="math inline">\(d_i\)</span>左部相同的<span class="math inline">\(d_j\)</span></p><p><span class="math inline">\(IN(B)=\cup OUT(B)\)</span></p><p><span class="math inline">\(OUT(B)=gen \cup (IN(B)-kill)\)</span></p><p>用途：</p><ol type="1"><li>循环不变计算检测</li><li>常量合并</li><li>判定变量x在p点上是否未经定值被引用</li></ol><h4 id="活跃变量分析">活跃变量分析👑</h4><p>对每一个基本块内的变量进行分析，use是右部中用到的符号，def是左部中符号，若use和def有交集，放在use里</p><p><span class="math inline">\(OUT(B)=\cup IN(B)\)</span></p><p><span class="math inline">\(IN(B)=use \cup (OUT(B)-def)\)</span></p><p>注意：活跃变量分析从<span class="math inline">\(B_n\)</span>开始分析</p><p>用途：</p><ol type="1"><li>删除无用赋值</li><li>为基本块分配寄存器</li></ol><h4 id="可用表达式分析">可用表达式分析🦄</h4><p>对每一个<code>z=x op y</code> 这类的表达式进行分析，先找出所有的<code>x op y</code>，记作S。</p><p>遇到 z = x op y ，e_gen先加入x op y ,然后删掉所有含有z的表达式；e_kill先删掉x op y ，然后加入所有S中含有z的表达式。</p><p><span class="math inline">\(IN(B)=\cap OUT(B)\)</span></p><p><span class="math inline">\(OUT(B)=e_{gen} \cup (IN(B)-e_{kill})\)</span></p><p>用途：</p><ol type="1"><li>消除全局公共子表达式</li><li>复制传播</li></ol><h3 id="概念总结主要针对选填">概念总结（主要针对选填）🐼</h3><h4 id="绪论">绪论😶‍🌫️</h4><ul><li>预处理 <span class="math inline">\(\rightarrow\)</span> 编译 <span class="math inline">\(\rightarrow\)</span> 汇编 <span class="math inline">\(\rightarrow\)</span> 链接 <span class="math inline">\(\rightarrow\)</span> 目标机器代码</li><li>编译：将高级语言翻译成汇编语言或机器语言的过程</li><li>词法分析中 token ：&lt;种别码，属性值&gt;、语法分析构造<strong>语法分析树</strong>、语义分析收集标识符的属性信息<strong>建立符号表和语义检查</strong></li></ul><h4 id="语言及其文法">语言及其文法🐻‍❄️</h4><ul><li><p>对于 <span class="math inline">\(\alpha\ \rightarrow\ \beta\)</span></p><ul><li>1型文法 -- 上下文有关文法：<span class="math inline">\(|\alpha|\ ≤\ |\beta|\)</span></li><li>2型文法 -- 上下文无关文法：<span class="math inline">\(\alpha\ \in\ V_N，A\rightarrow \beta\)</span></li><li>3型文法 -- 正则文法：<ul><li>右线性文法<span class="math inline">\(A\rightarrow wB\)</span> 或 <span class="math inline">\(A \rightarrow w\)</span><br /></li><li>右线性文法<span class="math inline">\(A\rightarrow Bw\)</span> 或 <span class="math inline">\(A \rightarrow w\)</span></li></ul></li></ul></li><li><p>短语和直接短语：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205180933517.png" /></p></li></ul><h4 id="词法分析">词法分析🐒</h4><ul><li>错误恢复（恐慌模式）：从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止</li></ul><h4 id="语法分析">语法分析👻</h4><ul><li>最右推导（规范推导）<span class="math inline">\(\Leftrightarrow\)</span> 最左规约<span class="math inline">\(\Leftrightarrow\)</span>最右句型（规范句型）</li><li>LL(1)文法不需要回溯，是一种确定的自顶向下分析方法（预测分析法）</li><li>预测分析中错误恢复（恐慌模式）：忽略输入中的一些符号，直到输入中出现由设计者选定的同步词法单元集合中的某个词法单元，将FOLLOW集中元素设置为 <span class="math inline">\(synch\)</span><ul><li>如果是空：忽略</li><li>如果是 <span class="math inline">\(synch\)</span> ，弹出栈顶非终结符</li><li>如果是终结符不匹配，弹出终结符</li></ul></li><li>预测分析法实现步骤：<ol type="1"><li>构造文法</li><li>改造文法：消除二义性、消除左递归、消除回溯</li><li>求每个变量的FIRST集和FOLLOW集，从而求得每个候选式的SELECT集</li><li>检查是不是 LL(1) 文法。若是，构造预测分析表</li><li>对于递归的预测分析，根据预测分析表为每一个非终结符编写一个过程；对于非递归的预测分析，实现表驱动的预测分析算法</li></ol></li><li>每次规约的符号串称为“句柄”，句柄是句型的最左直接短语</li><li>LR分析中错误恢复<ul><li>恐慌模式：丢弃输入符号</li><li>短语层次</li></ul></li></ul><h4 id="语法制导翻译">语法制导翻译🎎</h4><ul><li><p>SDD是对CFG的推广</p></li><li><p><strong>注释分析树</strong>：每个节点都有属性值的分析树</p></li><li><p>终结符只能有综合属性</p></li><li><p>一个没有副作用的SDD称为属性文法</p></li><li><p>S-SDD可以按照自底向上顺序计算属性值并且实现</p></li><li><p>如果 S-SDD 的基本文法可以使用LR分析技术，那么它的SDT可以在LR语法分析中实现</p></li><li><p>扩展栈：</p><table><thead><tr class="header"><th style="text-align: center;">状态</th><th style="text-align: center;">符号</th><th style="text-align: center;">属性</th></tr></thead><tbody></tbody></table></li><li><p>如果L-SDD 的基本文法可以使用LL分析技术【LL文法判定】，那么它的SDT可以在LL或LR语法分析中实现</p></li><li><p>如果选用非递归LL实现，扩展语法分析栈：</p><table><thead><tr class="header"><th style="text-align: center;">action</th><th style="text-align: center;">A</th><th style="text-align: center;">Asyn</th></tr></thead><tbody></tbody></table><p>A的继承属性在A中</p></li><li><p>如果选用递归LL实现：继承属性是形参，综合属性的返回值</p></li></ul><h4 id="中间代码生成">中间代码生成🐧</h4><ul><li>局部变量存储分配：对于声明语句，从类型表达式可以知道该类型<strong>在运行时刻所需的存储单元数量</strong>称为类型的宽度。在<strong>编译时刻</strong>，可以使用类型的宽度为每一个名字<strong>分配一个相对地址</strong>。名字的类型和相对地址信息保存在相应的符号表记录中</li><li>逻辑运算符优先级：not &gt; and &gt; or</li></ul><h4 id="运行存储分配">运行存储分配👽</h4><ul><li><p>活动记录结构：</p><table><tbody><tr class="odd"><td style="text-align: center;">实参</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">返回值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">控制链</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">访问链</td><td style="text-align: center;">访问存放于其他活动记录的非局部数据</td></tr><tr class="odd"><td style="text-align: center;">保存的机器状态</td><td style="text-align: center;">返回地址和寄存器中内容</td></tr><tr class="even"><td style="text-align: center;">局部变量</td><td style="text-align: center;">该过程中声明的数据</td></tr><tr class="odd"><td style="text-align: center;">临时变量</td><td style="text-align: center;"></td></tr></tbody></table></li><li><p>栈式存储分配可以保证它的非局部变量的相对地址总是固定的，和过程调用序列无关</p></li><li><p>活动树：用来描述程序运行期间控制进入和离开各个活动情况的树</p></li><li><p>每个活跃的活动都有一个位于控制栈中的活动记录</p></li><li><p>当一个过程是递归的时候，常常会有该过程的多个活动记录同时出现在栈中</p></li><li><p>top_sp指向活动记录中局部数据开始的位置</p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205181113824.png" alt="" style="zoom:67%;" /></p><ul><li>符号表作用：辅助代码生成、一致性检查</li></ul><h4 id="代码优化">代码优化🐇</h4><ul><li>未经声明错误是语义分析检测出的（还有重复定值）；未经定值是数据流分析检测出的</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205181145527.png" alt="" style="zoom:67%;" /></p><h4 id="代码生成">代码生成🌞</h4><ul><li>代码生成器主要任务：<ul><li>指令选择</li><li>寄存器分配和指派</li><li>指令排序</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205181204936.png" alt="" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指012-剪绳子I</title>
    <link href="/post/40d8cce9.html"/>
    <url>/post/40d8cce9.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指012-剪绳子i">剑指012-剪绳子I</h3><span id="more"></span><p>题目： 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0],k[1]...k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><code>示例 1:</code> <figure class="highlight tap"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs tap">输入: 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1<br></code></pre></td></tr></table></figure></p><p><code>示例 2:</code> <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: 10<br>输出: 36<br>解释:<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+ 4,<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 4 </span>= 36<br></code></pre></td></tr></table></figure></p><p><code>提示:</code> <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>&lt;= n &lt;= <span class="hljs-number">58</span><br></code></pre></td></tr></table></figure></p><p>解法1： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> cuttingRope(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt; n+<span class="hljs-number">1</span>;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; i;j++) &#123;<br>                <span class="hljs-type">int</span> tmp = Math.max(dp[j] * (i-j),j * (i-j));<br>                dp[i] = Math.max(tmp,dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>考察点： <code>动态规划</code>，这道题看似可能要使用贪心，但是如果使用动态规划的话会简单很多，状态转移方程还是挺好理解的。二重<code>for</code>循环每一次都可以得到当前<code>dp[i]</code>的最大值。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指011-机器人的运动范围</title>
    <link href="/post/2d6dab51.html"/>
    <url>/post/2d6dab51.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指011-机器人的运动范围">剑指011-机器人的运动范围</h3><span id="more"></span><p>题目： 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><code>示例 1:</code> <figure class="highlight excel"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">2</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></p><p><code>示例 2:</code> <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p><p><code>提示:</code> <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n,m &lt;= <span class="hljs-number">100</span><br><span class="hljs-symbol">0 </span>&lt;= k &lt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></p><p>解法1： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> movingCount(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-built_in">new</span> <span class="hljs-type">boolean</span>[m][n];<br>        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>        //向右<br>        <span class="hljs-type">int</span>[] dx = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>        //向上<br>        <span class="hljs-type">int</span>[] dy = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>        queue.offer(<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] tx = queue.poll();<br>            <span class="hljs-type">int</span> x = tx[<span class="hljs-number">0</span>],y = tx[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">index</span> &lt; <span class="hljs-number">2</span>; <span class="hljs-keyword">index</span>++) &#123;<br>                <span class="hljs-type">int</span> xx = x+dx[<span class="hljs-keyword">index</span>];<br>                <span class="hljs-type">int</span> yy = y+dy[<span class="hljs-keyword">index</span>];<br>                <span class="hljs-keyword">if</span>(xx &gt;= m || xx &lt; <span class="hljs-number">0</span> || yy &gt;= n || yy &lt; <span class="hljs-number">0</span> || getSum(xx) + getSum(yy) &gt; k || visited[xx][yy]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                visited[xx][yy] = <span class="hljs-keyword">true</span>;<br>                res++;<br>                queue.offer(<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;xx,yy&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> getSum(<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-type">int</span> ma = x / <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> mb = x % <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> res = ma+mb;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>考察点： <code>BFS</code>，使用一个<code>queue</code>不断向右，向上搜索即可。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指010-矩阵中的路径</title>
    <link href="/post/bb8e4fc0.html"/>
    <url>/post/bb8e4fc0.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指010-矩阵中的路径">剑指010-矩阵中的路径</h3><span id="more"></span><p>题目： 给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果<code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/word2.jpg" /></p><p><code>示例 1:</code> <figure class="highlight prolog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure></p><p><code>示例 2:</code> <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]], word = <span class="hljs-string">&quot;abcd&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure></p><p><code>提示:</code> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> board.length &lt;<span class="hljs-operator">=</span> <span class="hljs-number">200</span><br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> board[i].length &lt;<span class="hljs-operator">=</span> <span class="hljs-number">200</span><br>board 和 word 仅由大小写英文字母组成<br></code></pre></td></tr></table></figure></p><p>解法： <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">String</span> <span class="hljs-type">word</span>)</span> </span>&#123;<br>        <span class="hljs-type">char</span>[] words = <span class="hljs-type">word</span>.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board, words, i, j, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">char</span>[] <span class="hljs-type">word</span>, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= board.length || i &lt; <span class="hljs-number">0</span> || j &gt;= board[<span class="hljs-number">0</span>].length || j &lt; <span class="hljs-number">0</span> || board[i][j] != <span class="hljs-type">word</span>[k]) <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-type">word</span>.length - <span class="hljs-number">1</span>) <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        board[i][j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-type">boolean</span> res = <span class="hljs-built_in">dfs</span>(board, <span class="hljs-type">word</span>, i + <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || <span class="hljs-built_in">dfs</span>(board, <span class="hljs-type">word</span>, i - <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || <br>                      <span class="hljs-built_in">dfs</span>(board, <span class="hljs-type">word</span>, i, j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>) || <span class="hljs-built_in">dfs</span>(board, <span class="hljs-type">word</span>, i , j - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>);<br>        board[i][j] = <span class="hljs-type">word</span>[k];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>考察点： <code>DFS+剪枝</code>，非常巧妙的一个递归算法，最后一个参数<code>k</code>指的是当前搜索到<code>word</code>的第几位，最妙的在于<code>board[i][j] = '\0';</code>，访问过的标记空字符串，“ ”是空格 '\0'是空字符串，不一样的！比如当前为A，没有标记找过，且A是word中对应元素，则此时应该找A下一个元素，假设是B，在dfs（B）的时候还是要搜索B左边的元素（假设A在B左边），所以就是ABA（凭空多出一个A，A用了2次，不可以），如果标记为空字符串就不会有这样的问题，因为他们值不相等AB != ABA。其他都挺好理解。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指009-旋转数组的最小数字</title>
    <link href="/post/2a3800c3.html"/>
    <url>/post/2a3800c3.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指009-旋转数组的最小数字">剑指009-旋转数组的最小数字</h3><span id="more"></span><p>题目： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。   注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。</p><p><code>示例 1:</code> <figure class="highlight accesslog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs accesslog">输入：numbers = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p><p><code>示例 2:</code> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：numbers = <span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></p><p><code>提示:</code> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">n</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> numbers.length<br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> n &lt;<span class="hljs-operator">=</span> <span class="hljs-number">5000</span><br>-<span class="hljs-number">5000</span> &lt;<span class="hljs-operator">=</span> numbers[i] &lt;<span class="hljs-operator">=</span> <span class="hljs-number">5000</span><br>numbers 原来是一个升序排序的数组，并进行了 <span class="hljs-number">1</span> 至 n 次旋转<br></code></pre></td></tr></table></figure></p><p>解法： <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> high = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-keyword">int</span> pivot = low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[pivot] &lt; numbers[high]) &#123;<br>                high = pivot;<br>            &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(numbers[pivot] &gt; numbers[high])</span> </span>&#123;<br>                low = pivot + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[low];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>考察点： 本题需要使二分法，但是可能是自己对旋转数组的性质没太搞懂，现记录一下： 注意是<code>numbers[pivot]</code>和<code>numbers[high]</code>之间进行比较！！！ 如果是<code>numbers[pivot] &lt; numbers[high]</code>： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/2.png" /> 如果是<code>numbers[pivot] &gt; numbers[high]</code>： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/3.png" /> 如果是<code>numbers[pivot] = numbers[high]</code>： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/4.png" /> 但是暂时自己没太明白以上情况是如何得出。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指008-青蛙跳台阶问题</title>
    <link href="/post/62554f35.html"/>
    <url>/post/62554f35.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指008-青蛙跳台阶问题">剑指008-青蛙跳台阶问题</h3><span id="more"></span><p>题目： 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><code>示例 1:</code> <figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></p><p><code>示例 2:</code> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">7</span><br>输出：<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure></p><p><code>示例 3:</code> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p><p><code>提示:</code> <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= n &lt;= <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></p><p>解法： <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">MOD</span> = <span class="hljs-number">1000000007</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> numWays(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span> || n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span>[] dp = new <span class="hljs-built_in">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>;i &lt; dp.length;i++) &#123;<br>            dp[i] = (dp[i-<span class="hljs-number">1</span>]%<span class="hljs-built_in">MOD</span>) + (dp[i-<span class="hljs-number">2</span>]%<span class="hljs-built_in">MOD</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (dp[n]%<span class="hljs-built_in">MOD</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>考察点： 本题也是动态规划中的经典题目，用一个数组<code>dp</code>存储<code>F(1) ~ F(n-1)</code>的值，就可以简单实现本题，需要注意的是模操作不要忘记，因为结果会超过<code>Integer.MAX_VALUE</code>。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件过程与工具</title>
    <link href="/post/f6d9959d.html"/>
    <url>/post/f6d9959d.html</url>
    
    <content type="html"><![CDATA[<p><strong>本文章主要基于 哈尔滨工业大学 范国祥老师 软件工程与工具课程</strong></p><span id="more"></span><h1 id="软件过程与工具">软件过程与工具</h1><h2 id="概述">1.概述</h2><h3 id="软件的基本概念">1.1 软件的基本概念</h3><ul><li>1.1.1 什么是软件<ul><li>软件：一组对象或项目所形成的一个“配置”，由<strong>程序、文档和数据</strong>构成。</li><li>“变化”是永恒的主题</li></ul></li><li>1.1.2 软件的发展<ul><li>面向构件的软件 = 构件 + 框架</li><li>面向服务的软件 = 服务 + 消息 + 总线</li></ul></li></ul><h3 id="软件工程的基本概念">1.2 软件工程的基本概念</h3><ul><li>1.2.1 软件工程产生的历史根源</li><li>1.2.2 软件工程的基本概念</li><li>1.2.3 软件工程的知识体系</li></ul><h3 id="软件工程工具">1.3 软件工程工具</h3><ul><li>1.3.1 CASE工具</li></ul><h2 id="软件过程核心思想">2.软件过程核心思想</h2><h3 id="软件工程的本质不同抽象层次之间的映射与转换">2.1 软件工程的本质：不同抽象层次之间的映射与转换</h3><ul><li><p>任何软件系统开发的共同本质在于：<strong>从现实空间的需求到计算机空间的软件代码之间的映射与转换</strong></p></li><li><p>单步映射与多步映射</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337499.png" /></p><p>如上图所示，黑色虚线是正确的实现途径，红色是实际的实现途径（单步映射），蓝色也是实际的实现途径（多步映射）</p><ul><li>软件工程本质：用严格的规范和管理手段来缩小偏差，通过牺牲“时间”来提高“质量”</li></ul></li><li><p>软件工程的两个映射</p><ol type="1"><li>概念映射：问题空间的概念与解空间的模型化概念之间的映射</li></ol><ul><li>“学生” <span class="math inline">\(\rightarrow Class Student (No, Name, Dept, Grade)\)</span></li></ul><ol start="2" type="1"><li>业务逻辑映射：问题空间的处理逻辑与解空间处理逻辑之间的映射</li></ol><ul><li><p>计算某班学生平均分数$$</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">calculateAverageScore</span> <span class="hljs-params">(Struct [] scores)</span> <br>&#123;<br>    检索;<br>    计算平均分算法;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>软件工程：不同抽象层次之间的映射过程</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337315.png" style="zoom:70%;" /></p><p>现实空间的需求<span class="math inline">\(\rightarrow\)</span> 需求规约<span class="math inline">\(\rightarrow\)</span> 设计规约<span class="math inline">\(\rightarrow\)</span> 代码</p></li></ul><h3 id="软件工程所关注的目标">2.2 软件工程所关注的目标</h3><ul><li><p>软件工程所关注的对象</p><ul><li><p>产品：各个抽象层次的产出物</p></li><li><p>过程：在各个抽象层次之间进行映射和转换</p><p>“产品与过程二相性”：要把二者结合起来去考虑，而不能忽略其中任何一方</p></li></ul></li><li><p>软件工程所关注的目标</p><ol type="1"><li>功能性需求：软件所实现的功能达到它的设计规范和满足用户需求的程度<ul><li>完备性、正确性（描述软件在需求范围之内的行为）、健壮性（描述软件在需求范围之外的行为）、可靠性</li></ul></li><li>非功能性需求：系统能够完成所期望的工作的性能与质量<ul><li>效率、可用性、可维护性、可移植性、清晰性、安全性、兼容性、经济性、商业质量</li></ul></li><li>不同目标之间的关系：折中</li></ol></li></ul><h3 id="软件开发中的多角色">2.3 软件开发中的多角色</h3><h3 id="软件工程-最佳实践">2.4 软件工程 = 最佳实践</h3><p><del>（当你把所有错误都犯过之后，你就是正确的了）</del></p><h3 id="软件工程的四个核心理论概念">2.5 软件工程的四个核心理论概念</h3><ul><li>分治</li><li>复用</li><li>折中</li><li>演化<ul><li>软件系统在其生命周期中面临各种变化</li><li>可修改性、可维护性、可扩展性</li></ul></li></ul><h2 id="软件过程模型">3.软件过程模型</h2><h3 id="软件过程">3.1 软件过程</h3><ul><li><p>黑盒过程和白盒过程</p><p>将整个软件开发过程看成一个黑盒，而在实际软件开发中要在黑盒中留出白盒进行反馈（<span class="math inline">\(feedback\)</span>）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337643.png"  style="zoom:80%;" /></p></li></ul><h3 id="典型软件过程模型">3.2 典型软件过程模型</h3><h4 id="瀑布模型">3.2.1 瀑布模型</h4><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337802.png" style="zoom:80%;" /></p><p>过程：从上一项活动接收该项活动的工作对象作为输入，利用这一输入实施该项活动应完成的内容给出该项活动的工作成果，并作为输出传给下一项活动。同时评审该项活动的实施，若确认，则继续下一项活动；否则返回前面，甚至更前面的活动（但是这种回溯非常困难）</p><p>每个阶段都有里程碑和提交物。</p><ul><li>优点：追求效率、能够逐步稳定的使项目向前发展</li><li>缺点：过于理想化、快速建立起来的系统结构可能会在后续的持续更改中导致软件质量低下、客户只有在末期才能得到可执行程序</li><li>适合场景：软件项目较小，各模块间接口定义非常清晰；需求在项目开始之前已经被全面的了解，产品的定义非常稳定；需求在开发中不太可能发生重大改变</li></ul><p>瀑布模型太理想化，太单纯，已不再适合现代的软件开发模式，在大型系统开发中已经很少使用。</p><h4 id="增量过程模型">3.2.2 增量过程模型</h4><p>无须等到所有需求都出来才进行开发，只要某个需求的核心部分出来，即可进行开发；可能迫切需要为用户迅速提供一套功能有限的软件产品，然后在后续版本中再细化和扩展功能。</p><ul><li><p>增量模型</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337609.png" style="zoom:60%;" /></p><p><strong>本质：以迭代的方式运用瀑布模型</strong></p><p>当使用增量模型时，<strong>第1个增量往往是核心的产品</strong>，即第1个增量实现了基本的需求，但很多补充的特征还没有发布。客户对每一个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。<strong>增量模型强调每一个增量均发布一个可操作的产品。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">例：开发一个类似于Word的字处理软件<br><span class="hljs-code">增量1：提供基本的文件管理、编辑和文档生成功能</span><br><span class="hljs-code">增量2：提供高级的文档编辑功能</span><br><span class="hljs-code">增量3：实现拼写和语法检查功能</span><br><span class="hljs-code">增量4：完成高级的页面排版功能</span><br></code></pre></td></tr></table></figure><ul><li>优点：能够快速推出软件产品，满足客户需求，对客户有一定的镇定作用、不用一下子投入太多资源。灵活性比较高</li><li>缺点：由于软件其他构件是后期加入的，容易导致由于构件之间的不稳定从而使系统崩溃。</li></ul></li><li><p>快速应用程序开发(RAD)</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337170.png" style="zoom:80%;" /></p><ul><li>优点：<strong>侧重于短开发周期</strong>（一般为60~90天）的增量过程模型，是瀑布模型的高速变体，通过<strong>基于构件的构建方法</strong>实现快速开发；<strong>多个团队并行进行开发</strong>，但启动时间有先后，先启动团队的提交物将作为后启动团队的输入</li><li>缺点：</li><li><strong>需要大量的人力资源</strong>来创建多个相对独立的RAD团队；如果<strong>没有在短时间内为急速完成整个系统做好准备</strong>，RAD项目将会失败；如果<strong>系统不能被合理的模块化</strong>，RAD将会带来很多问题；<strong>技术风险很高的情况下</strong>（采用很多新技术、软件需与其他已有软件建立集成等等），不宜采用RAD</li></ul></li><li><p>增量模型和RAD模型区别：增量模型要求后来的增量不能对之前的系统结构进行破坏</p></li></ul><h4 id="演化过程模型">3.2.3 演化过程模型</h4><p>需求的变更频繁，要求在非常短的期限内实现，以充分满足客户/用户要求、及时投入市场</p><p>本质：循环、反复、不断调整当前系统以适应需求变化</p><p>由于构建产品所需的周期数据不确定，给项目管理带来困难；演化速度太快，项目陷入混乱；演化速度太慢，影响生产率；为追求软件的高质量而牺牲了开发速度、灵活性和可扩展性</p><ul><li><p>快速原型法</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337551.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337539.png" style="zoom:80%;" /></p><ul><li><p>原型的分类</p><ul><li><p>抛弃式原型</p><p>最初的原型在完成并得到用户认可之后，将不会作为交付给用户的最终系统的一部分，而是被抛弃，其目的只是为了收集与验证需求</p><p><strong>该类原型是不可执行的</strong></p></li><li><p>演化式模型</p><p>最初构造的原型将具备较高的质量，包含了系统的核心功能，然后通过收集需求对其进行不断的改善和精化</p><p><strong>该类原型是可执行的，将成为最终系统的一部分</strong></p></li></ul></li><li><p>优点：提高和改善客户/用户的参与程度，最大程度的响应用户需求的变化</p></li><li><p>缺点：设计原型时未考虑整体软件质量和长期的可维护性，系统结构较差；混淆原型系统和最终系统；额外的开发费用</p></li></ul></li><li><p>螺旋模型</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337809.png" style="zoom:70%;" /></p><p>制定计划<span class="math inline">\(\rightarrow\)</span> 风险分析<span class="math inline">\(\rightarrow\)</span>实施工程<span class="math inline">\(\rightarrow\)</span>客户评价<span class="math inline">\(\rightarrow\)</span>制定计划<span class="math inline">\(\rightarrow\)</span>...</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">例：<br>第1圈：开发出产品的规格说明<br>第2圈：开发产品的原型系统<br>第3~n圈：不断的迭代，开发不同的软件版本<br>根据每圈交付后用户的反馈来调整预算、进度、需要迭代的次数<br></code></pre></td></tr></table></figure><p><strong>与增量、RAD等的最大区别在于重视风险评估</strong></p><ul><li>出发点：开发过程中及时识别和分析风险，并采取适当措施以消除或减少风险带来的危害</li><li>优点：结合了原型的迭代性质与瀑布模型的系统性和可控性，是一种<strong>风险驱动型的过程模型</strong></li><li>缺点：周期长，成本高，软件开发人员应该擅长寻找可能的风险</li></ul></li></ul><h4 id="其他过程模型">3.2.4 其他过程模型</h4><ul><li>形式化过程</li><li>软件复用过程</li></ul><h3 id="案例分析">3.3 案例分析</h3><h2 id="敏捷方法与过程">4.敏捷方法与过程</h2><h4 id="敏捷过程模型">4.1 敏捷过程模型</h4><p>开发过程中<strong>“变化”</strong>是无处不在的，要将<strong>“变化”</strong>的意识贯穿在每一项开发活动中。</p><p><strong>“小步快跑，及时反馈”</strong></p><p>本质：<strong>以快速的增量和迭代方式进行软件开发</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337761.png" style="zoom:75%;" /></p><p>敏捷过程中最重要的因素：<strong>人</strong></p><h4 id="极限编程xp">4.2 极限编程(XP)</h4><p><span class="math inline">\(planning(用户故事User\ story)\rightarrow design(测试驱动的开发TDD)\rightarrow coding(结对编程Pair\ programming)\)</span></p><p>$ test(持续集成Continuous instegration)$</p><ul><li><p>XP planning</p><p>用户故事：<strong>客户</strong>为用户故事指定<strong>优先级</strong>，<strong>XP团队</strong>为用户故事指定<strong>成本</strong></p><p>将若干个用户故事指定为<strong>下一次发布的增量</strong></p><p>规划<strong>整体进度</strong></p></li><li><p>XP design</p><p>遵循<span class="math inline">\(KIS(Keep\ It\ Simple)\)</span>原则</p><p>设计模型：面向对象方法，<span class="math inline">\(CRC\)</span>卡片</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337682.png" style="zoom:70%;" /></p><p>遇到困难问题：创建原型</p><p>对设计方案不断<strong>重构</strong></p></li><li><p>XP coding &amp; test</p><p>测试驱动的开发<span class="math inline">\((TDD):\)</span></p><ul><li><p>编码前设计<strong>单元测试用例</strong></p></li><li><p><strong>结对编程</strong></p><ul><li><p>驾驶员：控制键盘输入的人</p></li><li><p>领航员：起到领航，提醒的作用</p></li><li><p>驾驶员和领航员不断轮换角色，不宜连续工作超过一小时；领航员要控制时间</p></li><li><p>主动参与、只有水平上的差距，没有级别上的差异</p></li><li><p>程序各方面的质量取决于<strong>一对程序员中各方面水平较高的那一位</strong></p></li></ul></li></ul></li></ul><p>何以谓“极限”：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337950.png" style="zoom:80%;" /></p><h4 id="scrum">4.3 Scrum</h4><p>整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个<span class="math inline">\(Sprint\)</span>，每个<span class="math inline">\(Sprint\)</span>的建议长度是2到4周</p><p>使用产品列表<span class="math inline">\(Product\ Backlog\)</span>来管理需求，产品列表<span class="math inline">\(Product\ Backlog\)</span>是一个按照商业价值排序的需求列表，列表条目的体现形式通常为用户故事</p><p>先开发对于用户具有较高价值的需求</p><p>在<span class="math inline">\(Sprint\)</span>中，<span class="math inline">\(Scrum\)</span>团队从产品列表<span class="math inline">\(Product\ Backlog\)</span>中挑选最高优先级的需求进行开发；挑选的需求在<span class="math inline">\(Sprint\)</span>计划会议上经过讨论、分析和估算得到相应的任务列表(<span class="math inline">\(Sprint\ backlog\)</span>)</p><p>在每个迭代结束时，<span class="math inline">\(Scrum\)</span>团队将提交潜在可交付的产品增量</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211210103202604.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338325.png" style="zoom:55%;" /></p><p><span class="math inline">\(Scrum\)</span>中的六项活动</p><ul><li><span class="math inline">\(Sprint\)</span> (冲刺)：代表一个1-4周的迭代</li><li>发布计划会议<span class="math inline">\((Release\ Planning\ Meeting)\rightarrow\ Product\ Backlog\)</span></li><li><span class="math inline">\(Sprint\)</span>计划会议<span class="math inline">\((Sprint\ Planning\ Meeting) \rightarrow\ Sprint\ Backlog\)</span></li><li>每日站会<span class="math inline">\((Daily\ Scrum\ Meeting)\)</span></li><li><span class="math inline">\(Sprint\)</span>评审会<span class="math inline">\((Sprint\ Review\ Meeting)\)</span></li><li><span class="math inline">\(Sprint\)</span>回顾会议<span class="math inline">\((Sprint\ Retrospective\ Meeting)\)</span></li></ul><p>每日站会：</p><ul><li>我昨天做了什么<span class="math inline">\((What\ have\ you\ done\ since\ yesterday? )\)</span></li><li>我今天要做什么<span class="math inline">\((What\ are\ you\ planning\ to\ do\ today? )\)</span></li><li>我碰到了哪些问题<span class="math inline">\((Do\ you\ have\ any\ problems\ that\ would\ prevent\ you\ from\ accomplishing\ your\ goal\ ?)\)</span></li></ul><p><span class="math inline">\(Sprint\ Burndown\ chart\)</span>：燃尽图，用于表示剩余工作量的工作图表，由横轴（X）和纵轴（Y）组成，横轴表示时间，纵轴表示工作量。这种图表可以直观的预测何时工作将全部完成。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338703.png" style="zoom:60%;" /></p><h4 id="与传统开发过程模型的对比">4.4 与传统开发过程模型的对比</h4><ul><li>瀑布模型<ul><li>将全部需求以整体方式向前推进，无迭代<br /></li><li>基本模型</li></ul></li><li>增量模型<ul><li>将需求分成多份，串行推进，无迭代</li><li>串行的瀑布</li></ul></li><li>RAD模型<ul><li>将需求分成多份，并行推进，无迭代</li><li>并行的瀑布</li></ul></li><li>原型模型<ul><li>迭代</li><li>基本模型</li></ul></li><li>螺旋模型<ul><li>按瀑布阶段划分，各阶段分别迭代(原型+风险分析)</li><li>原型+瀑布</li></ul></li><li>敏捷模型<ul><li>将需求分成尽量小的碎片，以碎片为单位进行高速迭代</li><li>增量+迭代</li></ul></li></ul><h4 id="敏捷案例分析">4.5 敏捷案例分析</h4><h4 id="总结">4.6总结</h4><ul><li><span class="math inline">\(XP\)</span>与<span class="math inline">\(Scrum\)</span>区别<ul><li>迭代长度的不同。<span class="math inline">\(XP\)</span>的一个<span class="math inline">\(Sprint\)</span>的迭代长度大致为1~2周, 而<span class="math inline">\(Scrum\)</span>的迭代长度一般为 2~ 4周。</li><li>在迭代中, 是否允许修改需求。<span class="math inline">\(XP\)</span>在一个迭代中，如果一个用户故事还没有实现， 则可以考虑用另外的需求将其替换， 替换的原则是需求实现的时间量是相等的。 而<span class="math inline">\(Scrum\)</span>是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来，并有<span class="math inline">\(Scrum\ Master\)</span>严格把关，不允许开发团队收到干扰。</li><li>在迭代中，用户故事是否严格按照优先级别来实现。<span class="math inline">\(XP\)</span>是务必要遵守优先级别的。 但<span class="math inline">\(Scrum\)</span>在这点做得很灵活， 可以不按照优先级别来做。</li><li>软件的实施过程中，是否采用严格的工程方法，保证进度或者质量。<span class="math inline">\(Scrum\)</span>没有对软件的整个实施过程开出严格工程实践的处方，要求开发者自觉保证；但<span class="math inline">\(XP\)</span>对整个流程方法定义非常严格，规定需要采用<span class="math inline">\(TDD\)</span>, 自动测试，结对编程，简单设计，重构等约束团队的行为。</li></ul></li></ul><h2 id="软件项目管理">5.软件项目管理</h2><p>软件项目的特征：</p><ul><li>不可见性</li><li>不确定性</li><li>多变化性</li><li>高技能及其高流通性</li></ul><h4 id="软件项目管理的案例">5.1 软件项目管理的案例</h4><p>软件项目管理的<span class="math inline">\(4P\)</span></p><ul><li>人员</li><li>产品</li><li>过程</li><li>项目</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338571.png"/></p><h4 id="人员people">5.2 人员(People)</h4><p>软件开发团队的组织方式：</p><ul><li>一窝蜂模式</li><li>主治医师模式<ul><li>明星模式</li></ul></li><li>社区模式<ul><li>开源项目</li></ul></li><li>交响乐团模式<ul><li>“工厂” <span class="math inline">\(\rightarrow\)</span> “规格严格”</li></ul></li><li>爵士乐模式<ul><li>类似于一群天才构成的敏捷团队<span class="math inline">\(\rightarrow\)</span>“功夫到家”</li></ul></li><li>功能团队模式</li><li>官僚模式</li></ul><p>大型项目的技术管理组织结构</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338920.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338516.png"  style="zoom:80%;" /></p><h4 id="产品product">5.3 产品(Product)</h4><p>确定软件范围<span class="math inline">\(\rightarrow\)</span>分治</p><p>产品结构分解<span class="math inline">\(PBS\)</span></p><ul><li>通过分层的树型结构来定义和组织<strong>项目范围内的所有产出物(产品)</strong>，自顶向下，逐级细分</li></ul><h4 id="过程process">5.4 过程(Process)</h4><p>选择合适的软件过程模型<span class="math inline">\(\rightarrow\)</span>根据所选的过程模型，对其进行适应性修改<span class="math inline">\(\rightarrow\)</span>确定过程中所包含的工作任务列表</p><p>工作结构分解<span class="math inline">\(WBS\)</span></p><ul><li>通过分层的树型结构来定义和组织<strong>工作任务之间的分解关系</strong>，自顶向下，逐级细分</li></ul><h4 id="项目project">5.5 项目(Project)</h4><p><span class="math inline">\(W^{5}HH\)</span>原则</p><ul><li><span class="math inline">\(Why\)</span> 为什么要开发这个系统？</li><li><span class="math inline">\(What\)</span> 将要做什么？</li><li><span class="math inline">\(When\)</span> 什么时候做？</li><li><span class="math inline">\(Who\)</span> 某功能由谁来做？</li><li><span class="math inline">\(Where\)</span> 机构组织位于何处？</li><li><span class="math inline">\(How\)</span> 如何完成技术与管理工作？</li><li><span class="math inline">\(How\ much\)</span> 各种资源分别需要多少？</li></ul><h4 id="可行性分析与估算">5.6 可行性分析与估算</h4><h4 id="项目进度计划与监控">5.7 项目进度计划与监控</h4><p>甘特图；描述任务的进度安排</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338913.png" style="zoom:80%;" /></p><p>下图是一张项目进度跟踪甘特图：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338810.png" style="zoom:80%;" /></p><p><span class="math inline">\(T_{x}\)</span>标识<span class="math inline">\(task\)</span>，<span class="math inline">\(M_{x}\)</span>标识里程碑，白色标识各项目计划开始/结束日期，白色 + 蓝色标识各项目实际开始/结束日期。</p><p><span class="math inline">\(XP/Scrum\)</span>敏捷开发中的进度计划与监控</p><ul><li><p>以“迭代”为单位：每次迭代包含多少个用户故事或用例</p></li><li><p>每次迭代为30天左右</p></li><li><p>针对每个用户故事，团队成员联合估算和协商开发代价(时间)</p></li><li><p>使用任务墙(<span class="math inline">\(Task\ Board\)</span>)/燃尽图(<span class="math inline">\(Burndown\ Chart\)</span>)等作为进度监控工具，评估迭代的当前进展情况</p></li></ul><h2 id="软件演化与配置管理">6.软件演化与配置管理</h2><h4 id="软件演化">6.1 软件演化</h4><p>软件演化的<span class="math inline">\(Lehman\)</span>定律</p><ul><li><p>持续变化：现实世界的系统要么变得越来越没有价值，要么进行持续不断的变化以适应环境的变化；环境变化产生软件修改，软件修改又继续促进环境变化</p></li><li><p>复杂度逐渐增大：当系统逐渐发生变化时，其结构和功能将变得越来越复杂，并逐渐难以维护并失去控制，直至无法继续演化，从而需要大量额外的资源和维护工作来保持系统的正常运行；软件修改会引入新的错误，造成故障率的升高</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211211095223736.png" style="zoom:80%;" /></p></li></ul><p>软件演化的处理策略：</p><ul><li>软件维护：为了修改软件缺陷或增加新的功能而对软件进行的变更；软件变更通常发生在局部，不会改变整个结构</li><li>软件再工程：为了避免软件退化而对软件的一部分进行重新设计、编码和测试，提高软件的可维护性和可靠性等</li><li><strong>前者力度小</strong></li></ul><h4 id="软件维护">6.2 软件维护</h4><p>软件维护类型</p><ul><li>纠错性维护（开发中有错误）</li><li>适应性维护（外部环境和数据环境变化）</li><li>完善性维护（新的需求和要求）【占比最大】</li><li>预防性维护（减少或避免前三类维护所做的维护）</li></ul><p>软件维护内容：</p><ul><li>程序维护</li><li>数据维护</li><li>硬件维护</li></ul><h4 id="软件配置管理scm">6.3 软件配置管理(SCM)</h4><p><span class="math inline">\(SCI\)</span>：软件配置项，软件配置的基本单位（文件）</p><p><span class="math inline">\(SCM\)</span>贯穿整个软件生命周期与软件工程过程</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338393.png" style="zoom:75%;" /></p><p><span class="math inline">\(SCM\)</span>目标：当变更发生时，能够提高适应变更的容易程度，并且能够减少所花费的工作量</p><p><span class="math inline">\(SCM\)</span>基本元素：</p><ul><li><p>配置项<span class="math inline">\((CI)\)</span></p><p>软件过程的输出信息可以分为三个主要类别：程序、文档，数据。</p><p>软件配置项<span class="math inline">\(SCI\)</span>：上述三项的总称，包含了所有在软件中产生的信息，<strong>是软件全生命周期内受管理和控制的基本单位</strong>，大到整个系统，小到某个硬件设备或软件模块</p><p><span class="math inline">\(SCI\)</span>具有唯一的名称和多个属性</p><p><span class="math inline">\(CI\)</span>之间<strong>依赖关系</strong>：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338465.png" style="zoom:80%;" /></p><p>对每一个<span class="math inline">\(CI\)</span>建立一个演变图，以记录对象的变更历史</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338247.png" style="zoom:80%;" /></p></li><li><p>基线<span class="math inline">\((Baseline)\)</span></p><p>在软件配置项成为基线之前，可以迅速而随意的进行变更，一旦成为基线，<strong>变更时需要遵循正式的评审流程才可以变更</strong>，因此，基线可看作是软件开发过程中的“里程碑”</p><p>基线是在某个时间点上对产品属性的一致描述，它是定义变化的基础</p><p><span class="math inline">\(Version \geqslant Release \geqslant Baseline \geqslant Milestone \geqslant checkpoint\)</span></p><p><span class="math inline">\(Version\)</span>：对外发布版本</p><p><span class="math inline">\(Release\)</span>：不一定要对外发布，但对外发布版本一定是<span class="math inline">\(Release\)</span></p><p><span class="math inline">\(Baseline\)</span>：不能改动</p><p><span class="math inline">\(Milestone\)</span>：里程碑</p><p><span class="math inline">\(checkpoint\)</span>：检查点，最为灵活</p></li><li><p>配置管理数据库<span class="math inline">\((CMDB)\)</span></p><p>也称为<span class="math inline">\(SCM\)</span>中心存储库，用于保存与软件相关的所有配置项的信息以及配置项之间关系的数据库</p><p><span class="math inline">\(\alpha 测试\)</span>：内部单用户在开发环境测试</p><p><span class="math inline">\(\beta 测试\)</span>：多用户在开发环境测试</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338613.png"  style="zoom:80%;" /></p></li><li><p>最终硬件库<span class="math inline">\((DHS)\)</span></p></li><li><p>最终软件库<span class="math inline">\((DSL)\)</span></p></li></ul><h4 id="持续集成">6.4 持续集成</h4><p>敏捷开发的一项重要实践</p><p>集成：集成测试【集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。一些局部反映不出来的问题，在全局上很可能暴露出来。）】</p><p>所有的开发人员需要在本地机器上做本地构建，然后再提交到版本控制库中，从而确保他们的变更不会导致持续集成失败，开发人员每天至少向版本控制库中提交一次代码，开发人员每天至少需要从版本控制库中更新一次代码到本地机器。需要有专门的集成服务器来执行集成构建，每天要执行多次构建，每次构建都要<span class="math inline">\(100 \%\)</span>通过，每次构建都可以生成可发布的产品，<strong>修复失败的构建是优先级最高的事情</strong></p><h4 id="本地-vs-分布式-版本控制系统">6.5 本地 vs 分布式 版本控制系统</h4><ul><li><p>本地版本控制系统(<span class="math inline">\(Local\ VCS\)</span>)</p><p>采用简单的数据库或文件系统来记录本地文件的历次更新差异</p></li><li><p>集中化版本控制系统<span class="math inline">\((Centralized\ VCS)\)</span></p><p>有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的开发者通过客户端连到这台服务器，取出最新的文件或者提交更新</p><p>缺点：单点故障，可靠性</p></li><li><p>分布式版本控制系统<span class="math inline">\((Distributed\ VCS)\)</span></p><p>客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来</p><p>任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p><p>每一次的提取操作，实际上都是一次对代码仓库的完整备份</p></li></ul><h4 id="git的基本思想">6.6 Git的基本思想</h4><p><span class="math inline">\(git\)</span>关注文件数据整体是否发生变化而不是文件内容</p><ul><li><p>传统思路：存储每个文件与初始版本的差异</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338587.png" /></p></li><li><p><span class="math inline">\(git\)</span>思路：存储项目随时间变化的快照（在本地磁盘保留项目的完整历史，以空间换时间）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338023.png" /></p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211211134742881.png" style="zoom:40%;" /></p><ul><li><span class="math inline">\(workspace\)</span>工作目录【已修改<span class="math inline">\(modified\)</span>】</li><li><span class="math inline">\(staging\)</span>暂存区（本地不占内存）【已暂存<span class="math inline">\(stages\)</span>】：本质上是一个文件，保存了下次要提交的文件列表信息</li><li><span class="math inline">\(local\ repository\)</span>本地仓库【已提交<span class="math inline">\(committed\)</span>】</li><li><span class="math inline">\(remote\ repository\)</span>远程仓库</li></ul><p><span class="math inline">\(git\)</span>工作流程</p><ul><li>在工作目录中修改某些文件</li><li>对修改后的文件进行快照，然后保存到暂存区域</li><li>提交更新，将保存在暂存区域的文件快照永久转储到Git目录中</li></ul><h4 id="基本git指令">6.7 基本Git指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git status<br>哪些更新未暂存？哪些更新已暂存？<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git diff<br>比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容（修改之后但未加入暂存）<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git diff --cached<br>比较的是暂存区域内的文件的更改（修改之后加入缓存但尚未提交）<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git diff HEAD<br>查看已缓存和未缓存的所有差异<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338492.png" style="zoom:70%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git commit -a<br>跳过git add<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset<br>git add的反向操作,使得暂存区与仓库版本一致<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338369.png" style="zoom:80%;" /></p><p>更改一次<span class="math inline">\(commit\)</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">1.git commit --amend<br>2.git reset HEAD^<br>^表示上一次提交<br></code></pre></td></tr></table></figure><h4 id="git远程仓库指令">6.8 Git远程仓库指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git">git fetch<br>从远程仓库抓取数据到本地，获取本地仓库尚未拥有的全部更新<br>如果本地仓库有了不同的修改，则需要手工将本地修改与远程仓库的修改合并起来<br>git merge<br>分支合并<br>git pull = git fetch + git merge<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338982.png" style="zoom:70%;" /></p><h4 id="git分支指令">6.9 Git分支指令</h4><p><span class="math inline">\(git\)</span>分支本质：指向<span class="math inline">\(commit\)</span>对象的可变指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout -b xxx = git branch xxx + git checkout xxx<br>创建分支并跳转<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/techflow/p/13876755.html"><span class="math inline">\(git\)</span>分支</a></p><h4 id="远程分支">6.10 远程分支</h4><p>远程仓库只能看，不能修改</p><h4 id="使用git进行协同开发的实例">6.11 使用Git进行协同开发的实例</h4><h2 id="uml及建模工具">7. UML及建模工具</h2><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338391.png" style="zoom:80%;" /></p><p>UML中事物：</p><ul><li>结构事物</li><li>行为事物</li><li>分组事物<ul><li>包（只存在于开发阶段）</li></ul></li><li>注释事物</li></ul><p>UML中关系：</p><ul><li><p>关联</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338747.png" /></p></li><li><p>依赖</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339834.png" /></p></li><li><p>泛化</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339535.png" /></p></li><li><p>实现</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339262.png" /></p></li><li><p>聚合</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339198.png" /></p></li></ul><h4 id="用例图">7.1 用例图</h4><p>用例图分类：<strong>业务用例图、系统用例图</strong></p><p>用例图组成：<strong>参与者<span class="math inline">\(Actor\)</span>，用例<span class="math inline">\(Use\ Case\)</span>，关联关系<span class="math inline">\(Association\)</span>，包含关系<span class="math inline">\(Include\)</span>，扩展关系<span class="math inline">\(Extend\)</span>，泛化关系<span class="math inline">\(Generalization\)</span></strong></p><ul><li><p>参与者</p><ul><li>参与者对系统而言总是外部的</li><li>分为启动者（消费者）和支持者（商家）</li><li>参与者之间可以有泛化关系</li></ul></li><li><p>用例</p><ul><li><p>区分用例和事件流：用例处于系统的需求分析阶段，避免考虑细节性问题；事件流描述系统“做什么”，会有更多的细节，也是在需求分析阶段。</p></li><li><p>用例对应有事件流文件</p><p>举例：<strong>用例名称：学生选课</strong></p><p><strong>简要描述：把具有选课资格的某一学生加到该课程的选课名单中</strong></p><p><strong>前提条件：学生已注册，选过该课程的先导课程并获得学分</strong></p><p><strong>后置条件：如果学生具有注册资格，并且该课程仍有空位，则学生注册到该课程</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339512.png" style="zoom:60%;" /></p><p>👆🏻一个用例对应的事件流文件</p></li></ul></li><li><p>关联关系</p><ul><li>参与者与用例之间的关系</li></ul></li><li><p>包含关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211213201926513.png" style="zoom:70%;" /></p><ul><li>用户用例执行，提供者用例必须执行</li></ul></li><li><p>扩展关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339441.png" style="zoom:70%;" /></p><ul><li>没有基础用例，扩展用例也是完整的用例</li><li>基础用例被执行时，一般不会涉及扩展用例，只有特定的条件发生，扩展用例才可能被执行，这是与包含关系的差别</li></ul></li><li><p>泛化关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339556.png" style="zoom:70%;" /></p><ul><li>子用例表示父用例的特殊形式</li><li>一个用例（父用例）可以被特别地列举为一个或多个子用例</li><li>泛化关系是一般和特殊的关系</li></ul></li><li><p>用例是有粒度的，用例的粒度指的是用例所包含的系统服务或功能单元的多少。</p><ul><li>用例的粒度越大，用例包含的功能越多，反之则包含的功能越少。</li><li><strong>步骤不是用例</strong></li><li>用例识别的标准：<span class="math inline">\(actor\)</span>与系统之间的一次独立交互</li></ul></li><li><p>注意用例的边界</p></li><li><p>用例是<span class="math inline">\(actor\)</span>与系统之间的交互，<span class="math inline">\(actor\)</span>与<span class="math inline">\(actor\)</span>在现实中的交互不应包含在<span class="math inline">\(use\ case\)</span></p></li><li><p>注意区分<span class="math inline">\(actor\)</span>和系统</p></li><li><p>我们要开发的系统（软件）是业务组织里面的一个业务对象，系统<strong>用例就是这个业务对象对外提供的服务</strong></p></li></ul><h4 id="活动图">7.2 活动图</h4><p>活动图描述活动的顺序，展现从一个活动到另一个活动的控制流，本质是一种<strong>流程图</strong>，着重表现从一个活动到另一个活动的控制流。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214141101491.png"  style="zoom:80%;" /></p><p>活动图元素：</p><ul><li><p>动作状态</p><p><span class="math inline">\(Action\)</span> 节点</p><p>原子（无法分解），不可中断（一旦开始，一直运行到结束），瞬时，可以有入转换，至少有一条出转换</p><p><strong>不能有</strong>入口动作和出口动作，<strong>不能有</strong>内部转移</p></li><li><p>活动状态</p><p><span class="math inline">\(Activity\)</span>节点</p><p>非原子运行（可以分解），活动状态的内部活动可以用另一个<strong>活动图</strong>来表示，可以有入口动作和出口动作，可以有内部转移</p><p><strong>动作状态是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态</strong></p></li><li><p>开始点&amp;结束点</p><p>$$ 表示开始</p><p>$$ 表示子流程结束</p><p>$$ 表示整个活动结束</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339185.png"  style="zoom:60%;" /></p><p>等价于：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339939.png" style="zoom:60%;" /></p></li><li><p>分支与合并</p><p>$$ 节点</p></li><li><p>分叉与汇合</p><p>分叉用将控制流分为两个或者多个<strong>并发</strong>运行的分支；汇合用于同步这些<strong>并发</strong>分支，以达到共同完成一项事务的目的</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339135.png" style="zoom:67%;" /></p></li><li><p>泳道</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339325.png" style="zoom:50%;" /></p></li><li><p>对象流</p><p>对象流是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或动作对对象的影响；可以理解为数据流</p></li></ul><p>活动图 <span class="math inline">\(VS\)</span> 状态图</p><p><strong>活动图</strong>着重表现从一个活动到另一个活动的控制流，是<strong>内部处理驱动的流程</strong>；<strong>状态图</strong>着重描述从一个状态到另一个状态的流程，主要有<strong>外部事件的参与</strong></p><p>活动图 <span class="math inline">\(VS\)</span> 流程图</p><p><strong>流程图</strong>着重描述处理过程，它的主要控制结构是顺序、分支和循环，各个处理之间有严格的顺序和时间关系；<strong>活动图</strong>描述的则是对象活动的顺序关系所遵循的规则，它着重表现的是系统的行为，而非系统的处理过程；<strong>活动图能够表示并发活动的情形，流程图不能</strong></p><h4 id="类图对象图">7.3 类图/对象图</h4><p>描述类、接口及他们之间关系的图</p><p>显示系统各个类的<strong>静态结构</strong></p><p>类图的元素</p><ul><li><p>类</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214155332101.png" style="zoom:70%;" /></p><p>类属性可见性：</p><p><span class="math inline">\(public \mapsto +\)</span></p><p><span class="math inline">\(private \mapsto -\)</span></p><p><span class="math inline">\(protected \mapsto\#\)</span></p><p><span class="math inline">\(package \mapsto\)</span> ~</p></li><li><p>接口</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214160404753.png" style="zoom:80%;" /></p></li><li><p>依赖关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339425.png" style="zoom:70%;" /></p></li><li><p>泛化关系</p><p><span class="math inline">\(is\ a\ kind\ of\)</span></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339243.png" style="zoom:60%;" /></p></li><li><p>关联关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339923.png" style="zoom:60%;" /></p><ul><li><p>关联的名称不是必需的</p></li><li><p>关联的角色</p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214161919998.png" style="zoom:60%;" /></p><ul><li>关联的多重性</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339601.png" style="zoom:60%;" /></p><ul><li><p>聚合关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214162140753.png" style="zoom:60%;" /></p><p>整体和部分 <span class="math inline">\(has\ a\)</span></p></li><li><p>组合关系</p><p>一种特殊的聚合关系--&gt;强聚合</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340625.png" style="zoom:60%;" /></p><p><strong>成员对象的生命周期取决于聚合的生命周期</strong></p><p>聚合不仅控制着成员对象的行为，而且控制着成员对象的<strong>创建和析构</strong></p></li></ul></li><li><p>实现关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340457.png" style="zoom:80%;" /></p></li></ul><h4 id="序列图协作图">7.4 序列图/协作图</h4><p>交互图：描述系统中对象之间消息通信的图，包括：序列图，协作图</p><p>序列图用来描述系统中对象间通过消息进行交互，它强调消息在时间轴上的先后顺序：纵轴是时间轴，时间沿竖线向下延伸；横轴代表了在交互中的各独立的对象</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340272.png" style="zoom:80%;" /></p><p>序列图用来描述<strong>用例的实现</strong>，标识了消息发生交互的先后顺序，<strong>明确类的职责</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340372.png" style="zoom:70%;" /></p><p>序列图组成：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340467.png" style="zoom:70%;" /></p><ul><li><p>对象</p><p>创建对象的两种表示方法：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214190345889.png" style="zoom:67%;" /></p><p>注销对象：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340653.png" style="zoom:67%;" /></p></li><li><p>生命线</p></li><li><p>消息</p><p>对象之间某种形式的通信；可以是<strong>信号</strong>，也可以是<strong>调用</strong>；可以用于在对象间传递参数</p><p>消息分类：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340425.png" style="zoom:67%;" /></p></li><li><p>激活</p></li></ul><p>用例图、类图，序列图关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340337.png" style="zoom:80%;" /></p><p><span class="math inline">\(BCE\)</span>模式</p><p>边界类（<span class="math inline">\(Boundary\)</span>）：边界类用来<strong>隔离系统内部和外部</strong>，负责接收参与者的消息</p><p>控制类（<span class="math inline">\(Control\)</span>）：控制类对应用例，用来控制用例执行期间的复杂运算或者业务逻辑；<strong>在分析阶段，通常针对一个用例生成一个控制类</strong></p><p>实体类（<span class="math inline">\(Entity\)</span>）：对应于类图中领域概念中的类；封装了数据结构和数据存储有关的类</p><p>边界类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340947.png" style="zoom:80%;" /></p><p>控制类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340254.png" style="zoom:80%;" /></p><p>实体类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340303.png" style="zoom:80%;" /></p><p>原则：</p><ul><li>针对每一个用例，可以对应生成一个控制类</li><li>参与者对象只能跟边界对象互动</li><li>实体对象不能发送消息给边界对象和控制对象</li><li>特别情况，如只是对数据进行增加、删除、修改和查询操作也可以不设置控制对象，让边界对象直接发送消息给实体对象，以提高执行速度</li></ul><p>一个序列图可以描述多个场景</p><p>组合片段：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340021.png" style="zoom:70%;" /></p><p>操作符分类：</p><ul><li><p><span class="math inline">\(opt\)</span>：包含一个可能发生或可能不发生的序列，可以在临界条件中指定序列发生的条件</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340371.png"  style="zoom:70%;" /></p></li><li><p><span class="math inline">\(alt\)</span>：可以在每个片段中设置一个临界条件来指示该片段可以运行的条件； else 的指示其他任何临界条件都不为true时应运行的片段；如果所有临界条件都为false并且没有else，则不执行任何片段</p></li><li><p><span class="math inline">\(loop\)</span>：片段重复一定次数，可以在临界条件中指示片段重复的条件</p></li><li><p><span class="math inline">\(break\)</span>：如果执行此片段，则放弃序列的其余部分，可以使用临界来指示发生中断的条件</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342515.png" style="zoom:70%;" /></p></li><li><p><span class="math inline">\(par\)</span>：并行处理，片段中的事件可以交错</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342987.png" style="zoom:70%;" /></p></li><li><p><span class="math inline">\(critical\)</span>：指示此片段中的消息不得与其他消息交错，通常是一些原子性操作</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342038.png" style="zoom:70%;" /></p></li><li><p><span class="math inline">\(ref\)</span>：用来在一个交互图中，引用其他的交互图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342976.png" style="zoom:90%;" /></p></li></ul><p>协作图组成：</p><ul><li>对象</li><li>链</li><li>消息</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342783.png" style="zoom:80%;" /></p><p>序列图和协作图是等价的，可以从一种形式的图转换为另一种形式的图而不丢失任何信息</p><h4 id="状态图">7.5 状态图</h4><p>状态图主要用于描述<strong>一个对象</strong>在其生存期间的<strong>动态行为</strong>，表现为<strong>一个对象所经历的状态序列</strong>，引起状态转移的<strong>事件</strong>（<span class="math inline">\(Event\)</span>），以及因状态转移而伴随的<strong>动作</strong>（<span class="math inline">\(Action\)</span>）</p><p>状态图元素：</p><ul><li><p>状态</p><p>状态指在对象的生命周期中的某个条件或者状况；在此期间对象将满足<strong>某些条件、执行某些活动或等待某些事件</strong></p><ul><li>初始状态 $$</li><li>终止状态 $$</li></ul></li><li><p>转移</p><p>对象在源状态中执行一定的动作，并在某个特定事件（<strong>触发事件</strong>）发生而且某个特定的<strong>警界条件</strong>满足时进入<strong>目标状态</strong>；状态可以有返回自身状态的转移（<strong>自身转移</strong>） <span class="math inline">\(\rightarrow\)</span></p></li><li><p>动作</p><p>原子操作</p></li><li><p>组合状态</p><p>含有子状态的状态</p></li><li><p>进入节点&amp;退出节点</p><p>进入节点 $$：不需要初始化，直接通过进入节点进入状态</p><p>退出节点 $$ ：从子状态转移到外部状态</p></li><li><p>历史状态</p><p>记住从组合状态中退出时所处的子状态</p></li><li><p>并发</p><p>组合状态在某一时刻同时到达多个子状态</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342111.png"  style="zoom:70%;" /></p></li></ul><h4 id="组件图">7.6 组件图</h4><h4 id="部署图">7.7 部署图</h4><h2 id="需求获取与分析">8.需求获取与分析</h2><h4 id="软件需求与需求获取">8.1 软件需求与需求获取</h4><h5 id="软件需求的定义">8.1.1 软件需求的定义</h5><p><strong>对用户需求的管理水平是决定软件成败的重要原因</strong></p><p>需求用于表达：“做什么”，不是表达：“怎么做”</p><h5 id="需求的分类">8.1.2 需求的分类</h5><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342633.png" style="zoom:60%;" /></p><ul><li><p>业务需求</p><p>客户对于系统的高层次目标要求<span class="math inline">\(high-level\ objectives\)</span>) ，定义了项目的远景和范畴(<span class="math inline">\(vision\ and\ scope\)</span>)</p></li><li><p>用户需求</p><p>从用户角度描述的<strong>系统功能需求与非功能需求</strong>，通常只涉及系统的<strong>外部行为</strong>而不涉及内部特性</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342566.png" style="zoom:60%;" /></p><ul><li><p>功能需求</p><p>系统应提供的功能或服务</p></li><li><p>非功能需求</p><p>对<strong>质量和性能</strong>的额外要求</p><ul><li>速度、存储空间、可用性、可靠性、容错性（一般用一些可度量的特性来描述）</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342423.png" style="zoom:60%;" /></p><ul><li><p>约束条件</p><p>法律法规、硬件/资源限制、开发语言</p></li><li><p>业务规则</p><p><strong>内部执行逻辑</strong></p><p>“如果...，那么...”</p></li><li><p>外部接口需求</p></li></ul><h5 id="好的需求与坏的需求">8.1.3 好的需求与坏的需求</h5><p>产生不合格需求的原因：</p><ul><li>无足够用户参与</li><li>用户需求的不断增加</li><li>模棱两可的需求</li><li>不必要的特性</li><li>过于精简的规格说明</li><li>忽略的用户分类</li><li>不准确的计划</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342635.png" style="zoom:70%;" /></p><h5 id="需求工程">8.1.4 需求工程</h5><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342624.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342468.png" style="zoom:65%;" /></p><h5 id="需求获取方法">8.1.5 需求获取方法</h5><p>需求获取的基本步骤：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342373.png" style="zoom:60%;" /></p><p>第1步：<strong>了解相关背景和领域/行业的知识</strong>，确定产品所期望的<strong>用户类</strong></p><p>第2步：与客户企业或组织的<strong>高层人员进行交流</strong>，了解实际用户任务和目标以及这些任务所支持的<strong>业务需求</strong></p><p>第3步：与客户企业或组织的<strong>底层人员进行交流</strong>，获取每个用户类的详细的<strong>用户需求</strong></p><p>第4步：整理需求纪要，<strong>发现新问题</strong>，并重复1-3步</p><p>第5步：<strong>需求分类和组织</strong>，以区别<strong>功能需求、非功能需求、约束条件、业务规则、外部接口需求</strong>、建议解决方法和附加信息</p><p>第6步：<strong>优先排序和冲突解决</strong></p><p>第7步：得到最终需求清单，并与客户做最终<strong>签字确认</strong></p><p>需求获取中的问题：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342857.png" style="zoom:70%;" /></p><p>需求获取技术</p><ul><li><p>收集现有纸面材料</p><ul><li>收集现有的报表、表格和过程描述</li><li>收集现有的工作流程图</li><li>分发和收集需求收集表</li></ul></li><li><p>面对面访谈</p><p>问题分类：</p><p>上下文无关问题：充分理解用户的问题，不涉及具体的解决方案</p><p>解决方案相关的问题：通过这类问题，探寻特定的解决方案并得到用户的认可</p></li><li><p>需求研讨会</p><p><span class="math inline">\(JAD\)</span>会议</p></li><li><p>现场观察/体验</p><p>被动观察：用户实地工作，需求分析人员在旁边看</p><p>主动观察：需求分析人员直接参与到用户的实际工作</p></li><li><p>头脑风暴</p></li></ul><p>对客户输入进行分类：</p><ul><li>业务需求：描述客户可以从产品中得到的<strong>资金、市场或其它业务利润的需求</strong></li><li>业务规则：一些活动只能<strong>在特定的条件下，由一些特定的人来完成时</strong>，该用户可能在描述一个业务规则</li><li>功能需求：用户应该能<span class="math inline">\(&lt;执行某些功能&gt;\)</span>或者系统应该<span class="math inline">\(&lt;具有某些行为&gt;\)</span></li><li>非功能需求</li><li>外部接口序需求：从<span class="math inline">\(&lt;某些设备&gt;\)</span>读取信号；给<span class="math inline">\(&lt;一些其他系统&gt;\)</span>发送信息；以<span class="math inline">\(&lt;某种格式&gt;\)</span>读取文件；能控制<span class="math inline">\(&lt;一些硬件&gt;\)</span></li><li>约束条件：必须使用<span class="math inline">\(&lt;一个特定的数据库产品或语言&gt;\)</span>；不能申请多于<span class="math inline">\(&lt;一定数量的内存&gt;\)</span>；操作必须与<span class="math inline">\(&lt;其它系统&gt;\)</span>相同；必须与<span class="math inline">\(&lt;其它应用程序&gt;\)</span>一致</li><li>数据定义</li></ul><h4 id="用户故事与用例建模">8.2 用户故事与用例建模</h4><h5 id="敏捷开发中的用户故事user-story">8.2.1 敏捷开发中的“用户故事”（User Story）</h5><p>在敏捷开发中，需求表述为一组“用户故事”；在传统的<span class="math inline">\(OO\)</span>分析与设计方法中，需求被表述为一组“用例”</p><p>组成部分：卡片、交谈、确认</p><p><span class="math inline">\(As\ a\ [user\ role],I\ want\ to\ [goal]\,so\ I\ can\ [reason]\ \ \ \rightarrow\ Who/What/Why\)</span></p><p>好的用户故事具备的特征： <span class="math inline">\(INVEST\)</span></p><p><span class="math inline">\(Independent、Negotiable(可讨论的)、Valuable、Estimable、Small、Testable\)</span></p><p><span class="math inline">\(TDD\)</span>：写代码前先写测试</p><h5 id="面向对象方法中的用例use-case">8.2.2 面向对象方法中的“用例”（Use Case）</h5><h5 id="用例建模的基本过程">8.2.3 用例建模的基本过程</h5><ol type="1"><li><p>识别并描述参与者（Actor）</p><p>特殊Actor：系统时钟</p></li><li><p>识别用例</p></li><li><p>识别参与者与角色之间的通讯关联（Association）</p></li><li><p>给出用例详细描述</p><p>事件流</p><ul><li>常规流</li><li>备选流（extend可以看成是备选流）</li></ul></li><li><p>细化用例模型（extend、include、泛化）</p><p>Actor之间存在泛化关系</p></li></ol><p>用例识别标准：actor与系统之间的一次独立交互</p><p>用例是actor与系统之间的交互，actor与actor在现实中的交互（讨价还价）不应包含在用例中</p><p>注意区分actor和系统，系统自己做的事情，不是独立的用例</p><h5 id="用例模型的提交物">8.2.4 用例模型的提交物</h5><h5 id="活动图-泳道图">8.2.5 活动图 &amp; 泳道图</h5><h4 id="需求的结构化分析">8.3 需求的结构化分析</h4><h5 id="结构化方法vs面向对象方法">8.3.1 结构化方法vs面向对象方法</h5><p>结构化方法：复杂世界<span class="math inline">\(\rightarrow\)</span>复杂处理过程（事情的发生发展），设计一系列功能解决</p><p>面向对象方法：任何系统都是由能够完成一组相关任务的对象构成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342199.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342024.png" style="zoom:65%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342738.png" style="zoom:67%;" /></p><h5 id="需求的结构化分析方法">8.3.2 需求的结构化分析方法</h5><p>结构化分析：帮助开发人员定义系统需要做什么（处理需求），系统需要存储和使用哪些数据（数据需求），系统需要什么样的输入和输出以及如何把这些功能结合在一起来完成任务</p><p>结构化分析方法：</p><ul><li>数据流图（<span class="math inline">\(DFD\)</span>）</li><li>实体-关系图（<span class="math inline">\(ERD,IDEF1X\)</span>）</li></ul><h5 id="数据流图dfd">8.3.3 数据流图（DFD）</h5><p>数据流图：用处理、外部实体、数据流以及数据存储来表示系统需求的图表</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342161.png" style="zoom:60%;" /></p><p>从外部实体发出的“数据流”可以是：1.外部实体发出的“处理请求”，即一个事件 2.外部实体给出的“输入数据”</p><p>指向“外部实体”的“数据流”一般是“处理”的反馈或处理结果</p><p>DFD图可以描述高层次的具有高度概括的系统处理也可以描述低层次的具有更详细分解的系统处理</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342013.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342258.png" style="zoom:67%;" /></p><ul><li><p>关联图：在<strong>单个处理符号</strong>中概括系统内所有处理活动的DFD</p><p><strong>关联图在表达系统边界时用处很大</strong>，系统的范围是通过单个的处理和外部实体所表示的事物来定义的；</p><p><strong>数据存储不画在关联图</strong>中是因为它本身被认为是系统内部的内容</p><p>当一个系统响应事件较多时，常常将系统分成多个子系统，并为每个子系统创建一张关联图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343220.png" style="zoom:70%;" /></p></li><li><p>DFD片段：用一个单一处理符号表示系统响应一个事件的DFD</p><p>在DFD片段中，展示了<strong>处理、外部实体和内部数据存储</strong>之间的交互细节</p><p>每个DFD片段仅显示要响应该事件的相关的那些数据存储</p><p><strong>一个DFD片段是为事件表中的每一个事件创建的</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343251.png" style="zoom:70%;" /></p></li><li><p>DFD的0层图：将一个系统或子系统的所有DFD片段组合到一个单个的DFD图中，这样的DFD图称为<strong>事件分离的系统模型/0层图</strong></p><p><strong>0层DFD图：“处理”的编号为<span class="math inline">\(i\)</span></strong></p></li><li><p>DFD层次：一个DFD片段中的<strong>处理</strong>也可以包含多个更小的<strong>处理</strong>，有时分析员需要将该DFD片段进一步细化，生成更详细层次的DFD图</p><p>1层DFD图：将0层DFD中的处理进一步细化等到的DFD图“处理”的编号为“<span class="math inline">\(i.j\)</span>”</p><p>2层DFD图：将1层DFD中的处理进一步细化等到的DFD图 “处理”的编号为“<span class="math inline">\(i.j.k\)</span>”</p></li></ul><p>如何画一个好的DFD图：</p><ul><li><p>最小化复杂度：采用分层结构将DFD划分为小的且相对独立的子集这样可以逐级阅读、考察DFD</p><p><strong>单个DFD图中不应有超过7±2个处理，单个DFD中不应超过7±2个数据流进出同一个处理/数据存储</strong></p><p>接口最小化：DFD中各个元素之间的连接数越少越好</p></li><li><p>保持数据流一致：</p><p><strong>一个“处理”和该“处理”被详细分解后在数据流内容上应该一致</strong></p><p><strong>对一个“处理”，有数据流入则必须有相对应的数据流出</strong></p><p><strong>对一个“处理”，有数据流出则必须有相对应的数据流入</strong></p></li><li><p><strong>黑洞</strong>：带有输入数据的但并不用其产生输出数据的处理或数据存储</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343749.png" style="zoom:50%;" /></p></li><li><p><strong>奇迹</strong>：没有足够数据元素作为输入或产生来源的一个处理或数据存储</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343727.png" style="zoom:50%;" /></p></li><li><p>典型错误：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343082.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343139.png" style="zoom:60%;" /></p></li></ul><p>在传统方法中，DFD图一般描述3种元素：处理【使用DFD】，（数据流，数据存储）【使用DD】</p><p>DFD细节描述：决策表、决策树</p><h5 id="数据字典dd">8.3.4 数据字典（DD）</h5><p>数据字典是数据分析的描述模型，包括：</p><ul><li><p>数据项定义：定义特定数据项的组成和意义</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343555.png" style="zoom:60%;" /></p></li><li><p>数据结构定义：定义有数据项组成的表达数据的基本数据</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343415.png"  style="zoom:60%;" /></p></li><li><p>数据流描述：描述数据流的数据构成，并指明其来源或去向</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343471.png" style="zoom:60%;" /></p></li><li><p>数据存储描述：描述保存在存储介质上的数据文件或数据库表的格式和内容</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343049.png" style="zoom:60%;" /></p></li><li><p>数据处理（广义DD）：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343127.png" style="zoom:60%;" /></p></li></ul><h5 id="数据分析erdidef1x">8.3.5 数据分析（ERD、IDEF1X）</h5><p>实体关系图（<span class="math inline">\(ERD\)</span>）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343154.png"  style="zoom:80%;" /></p><p>关联实体：解决上述问题的人为增加的数据实体，它一定包含两端数据实体的关键字</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343157.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343885.png" style="zoom:80%;" /></p><h4 id="面向对象的分析">8.4 面向对象的分析</h4><h5 id="面向对象的分析方法概述">8.4.1 面向对象的分析方法概述</h5><p>面向对象的分析模型由三个独立模型构成（分为3个阶段）：</p><ul><li>功能模型：从用户角度获取功能需求，由<strong>用例模型</strong>表示</li><li>静态结构模型：描述系统的概念实体，由<strong>类图</strong>表示</li><li>动态结构模型：描述对象之间的交互行为，由<strong>时序图和协作图</strong>表示</li></ul><p>静态结构模型&amp;动态结构模型建立与实现技术无关的系统逻辑结构</p><h5 id="建立静态结构模型">8.4.2 建立静态结构模型</h5><p>静态结构模型</p><ul><li><p>边界类</p><p>用户界面、系统接口、设备接口</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343809.png" style="zoom:80%;" /></p></li><li><p>控制类</p><p>对用例行为的封装，一般一个用例对于一个控制类</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343423.png" style="zoom:100%;" /></p></li><li><p>实体类</p><p>“事物”</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343679.png" style="zoom:100%;" /></p><p>三种类之间是“关联”关系</p><p><strong>一个边界类</strong>可以<strong>与多个控制类</strong>相关联</p><p><strong>一个控制类</strong>可以与<strong>多个边界类</strong>相关联、与<strong>多个实体类</strong>关联</p><p><strong>一个实体类</strong>可以与<strong>多个控制类</strong>相关联</p><ul><li><p>除非系统需要在各用例中管理和维护该角色的信息(不是指ID、密码)，否则只需将其作为actor，无需作为实体类</p></li><li><p><span class="math inline">\(actor\)</span>自己做的动作，都是边界类的操作，与控制类和实体类无关</p></li><li><p>实体类操作分两类：</p><ol type="a"><li><p><span class="math inline">\(new()、destroy()\)</span></p></li><li><p>对该实体内部的一个或多个属性的CRUD（增删改查）操作 — <strong>是自己的属性，不是其他实体的！</strong>因此，对用例中actor所发出的每个动作，需要仔细分析它对哪些实体类的哪些属性做CRUD</p></li></ol></li></ul><p>如果操作CRUD的对象不是该实体类的属性，则说明该操作应移动到相应的实体类中。</p><p>若某操作op会CRUD多个实体类的属性，通常可以把这个操作分解为多个小粒度操作，每个小操作放在专门的实体类中，如果没办法分解，则使用控制类加以完成。</p></li></ul><p>关系：泛化、关联、组合、聚合、依赖</p><ul><li><p>分析类图：主要区分边界类、控制类、实体类</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343643.png" style="zoom:70%;" /></p></li><li><p>领域类图：主要区分泛化、关联、组合、聚合、依赖</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343837.png" style="zoom:70%;" /></p></li></ul><h5 id="建立动态行为模型">8.4.3 建立动态行为模型</h5><p>见7.4</p><h5 id="案例分析-1">8.4.4 案例分析</h5><ol type="1"><li><p>角色识别</p></li><li><p>用例识别</p></li><li><p>建立用例模型</p></li><li><p>对用例图进行精化</p><p>（针对每个用例）</p></li><li><p>撰写用例描述</p></li><li><p>绘制用例的活动（泳道）图</p></li><li><p>识别分析类（边界类、控制类、实体类）</p></li><li><p>识别每个类的属性和方法</p></li><li><p>建立分析类图</p></li><li><p>建立领域类图</p></li><li><p>建立时序图</p></li></ol><h2 id="软件设计">9.软件设计</h2><h4 id="结构化设计">9.1 结构化设计</h4><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343353.png" style="zoom:70%;" /></p><p>自动化系统边界划分：将数据流图分为手工处理部分和系统能自动完成的部分</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343277.png" style="zoom:70%;" /></p><p>结构图创建方法：</p><ul><li><p>DFD片段</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343667.png" style="zoom:70%;" /></p></li><li><p>DFD分解图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343962.png" style="zoom:70%;" /></p></li><li><p>DFD重组</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343136.png" style="zoom:70%;" /></p></li><li><p>结构图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344086.png" style="zoom:70%;" /></p></li></ul><p>变换型结构的数据流图呈一种线性状态，它所描述的工作可表示为输入、主处理及输出。</p><p>事务型结构的数据流图则呈束状，即一束数据流平行流人或流出，可能同时有几个事务要求处理。</p><p>DFD到系统结构图转换的模式：</p><ul><li>事务型</li><li>复杂变换型</li></ul><p>结构图：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344018.png" style="zoom:60%;" /></p><p><strong>三种转换</strong>【重中之重】</p><p><strong>见<span class="math inline">\(PPT\)</span></strong></p><p><a href="https://www.it610.com/article/1864147.htm">转换</a></p><h4 id="面向对象设计">9.2 面向对象设计</h4><p>结构化方法：分析阶段与设计阶段分得特别清楚，分别使用两套完全不同的建模符号和建模方法</p><p>面向对象设计（<span class="math inline">\(OOD\)</span>）：<span class="math inline">\(OO\)</span>各阶段均采用统一的“对象”概念，各阶段之间的区分变得不明显，形成“无缝”连接</p><p>系统设计（<strong>概要设计</strong>）<span class="math inline">\(\ \rightarrow\ \)</span>对象设计（<strong>详细设计</strong>）</p><p>子系统的划分应该符合<strong>高内聚低耦合</strong>的原则</p><p>类与类之间存在的“聚合、组合、关联、依赖”关系导致包与包之间存在依赖关系，即“包的依赖”(<span class="math inline">\(dependency\)</span>)；类与类之间的存在的“继承”关系导致包与包之间存在继承关系，即“包的泛化”(<span class="math inline">\(generalization\)</span>)</p><p>对象设计基本步骤</p><ol type="1"><li>创建初始的设计类</li><li>细化属性</li><li>细化操作</li><li>定义状态</li><li>细化依赖关系</li><li>细化关联关系</li><li>细化泛化关系</li></ol><h4 id="数据库设计">9.3 数据库设计</h4><p>数据库系统 = 数据库（DB） + 数据库管理系统（DBMS）</p><p>数据库设计任务：</p><ul><li>逻辑设计：设计<span class="math inline">\(ER\)</span>模型</li><li>物理设计：在具体的数据库系统中实现<span class="math inline">\(ER\)</span>模型</li></ul><p>数据库<strong>逻辑模型设计</strong>：ERD图</p><p><span class="math inline">\(3NF\)</span>范式：</p><ul><li><span class="math inline">\(1NF\)</span>：没有重复的属性或属性组（同样的东西不能重复拥有）</li><li><span class="math inline">\(2NF\)</span>：是<span class="math inline">\(1NF\)</span>且每个非主属性均函数依赖于主属性（主键）（领导在，他就在，找到领导就能找到他）</li><li><span class="math inline">\(3NF\)</span> ：是<span class="math inline">\(2NF\)</span>且非主属性间均不存在函数依赖（领导只有一个，不能有多级领导）</li></ul><p>根据ERD设计物理数据库</p><ol type="1"><li>为每个实体创建一个二维表</li><li>为每个字段选择适当的数据类型和取值范围</li><li>定义每个表的主键</li><li>针对1：M关联关系的子表添加外键</li><li>定义完整型约束</li></ol><p>分析类图映射到ERD</p><p>本质：把<strong>每一个类，类之间的关系</strong>分别映射到一张表或多张表</p><ul><li><p>一类一表</p></li><li><p>不管是<span class="math inline">\(1\ :\ 1，1\ :\ n，m\ :\ n\)</span>的关联关系 ，均可以：A，B分别映射为独立的数据表，然后再加入一张新表来存储二者之间的关联</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344870.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344820.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344920.png" style="zoom:67%;" /></p></li><li><p>聚合/组合关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344279.png" style="zoom:67%;" /></p></li><li><p>泛化关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344472.png" style="zoom:67%;" /></p></li></ul><h4 id="用户界面设计">9.4 用户界面设计</h4><ul><li><span class="math inline">\(CUI\)</span>：字符用户界面</li><li><span class="math inline">\(GUI\)</span>：图形用户界面 <span class="math inline">\(\rightarrow\ WIMP\)</span></li><li><span class="math inline">\(MUI\)</span>：多通道用户界面</li></ul><p>缺省设计方法：</p><ul><li>用户操作设定缺省值（也可以作为强制值输入）</li><li>经验值作为缺省值</li><li>统计方法确定出现几率大的值作为缺省值</li><li>统计方法确定出现几率大的值作为缺省值</li><li>最近使用值作为缺省值</li><li>输入数据的上下文关联缺省值</li><li>当前状态值可作为缺省值</li><li>当前状态值可作为缺省值</li><li>正常操作序列选项作为缺省值</li><li>树状隶属关系约束选项列表</li><li>智能焦点</li></ul><h2 id="软件测试">10.软件测试</h2><h4 id="软件测试基础">10.1 软件测试基础</h4><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344061.png" style="zoom:60%;" /></p><p>上面的<span class="math inline">\(Venn\ Diagram\)</span>可以理解测试</p><p>测试可以证明“程序有错”，不能证明“程序正确”</p><h4 id="测试过程">10.2 测试过程</h4><p>软件测试的<span class="math inline">\(V\)</span>模型</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344859.png" style="zoom:60%;" /></p><h4 id="测试方法分类">10.3 测试方法分类</h4><ul><li><p>单元测试</p><p><strong>开发人员</strong>执行</p><p>驱动模块：模仿被测模块的上一级模块</p><p>桩模块：模拟被测单元需调用的其他函数接口</p></li><li><p>集成测试</p><p>测试的对象是模块间的接口</p><ul><li><p>整体集成</p><p>将所有模块按设计要求一次全部组装起来，然后进行整体测试</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344081.png" style="zoom:60%;" /></p></li><li><p>增量集成</p><p>逐步将新模块加入并测试</p><ul><li><p>自顶向下增量集成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345446.png" style="zoom:60%;" /></p><p>深度优先：A,B,E,C,D,F</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344771.png" style="zoom:80%;" /></p><p>广度优先：A,B,C,D,E,F</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345884.png" style="zoom:80%;" /></p><p><strong>所需桩模块巨大</strong></p><p>较少需要驱动模块</p></li><li><p>自底向下增量集成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345781.png" style="zoom:80%;" /></p><p><strong>不用桩模块</strong></p><p>难以尽早建立信心</p></li><li><p>三明治集成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345073.png" style="zoom:60%;" /></p></li></ul></li></ul></li><li><p>确认测试</p><p>是否满足软件需求说明书中的确认标准</p></li><li><p>系统测试</p></li><li><p>验收测试</p><p>以用户为主的测试</p><p><span class="math inline">\(\alpha\)</span>测试：由用户在开发环境下进行的测试</p><p><span class="math inline">\(\beta\)</span>测试：由软件的多个用户在实际使用环境下进行测试</p></li><li><p>回归测试</p></li></ul><h4 id="黑盒测试">10.4 黑盒测试</h4><h5 id="黑盒测试概述">10.4.1 黑盒测试概述</h5><p>通常在软件接口处进行</p><p>原理：任何程序都可以看成是将输入定义域取值映射到输出值域的函数</p><p>不可能穷举所有的情况</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345324.png" style="zoom:67%;" /></p><h5 id="等价类划分方法">10.4.2 等价类划分方法</h5><p>确定等价类的六大原则</p><ul><li>在输入条件规定了取值范围或值的个数的情况下，则可以确立1个有效等价类和2个无效等价类</li><li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立1个有效等价类和1个无效等价类</li><li>在输入条件是一个布尔量的情况下，可确定1个有效等价类和1个无效等价类</li><li>在规定了输入数据的一组值(假定n个)、并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和1个无效等价类</li><li>在规定了输入数据必须遵守的规则的情况下，可确立1个有效等价类(符合规则)和n个无效等价类(从不同角度违反规则)</li><li>在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步的划分为更小的等价类</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345728.png" style="zoom:80%;" /></p><h5 id="边界值方法">10.4.3 边界值方法</h5><p>原则</p><ul><li>如果输入条件规定了值的范围，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据</li><li>如果输入条件规定了值的个数，则用最大个数、最小个数、比最小个数少1,比最大个数多1的数据作为测试数据</li><li>将原则1和原则2应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值</li><li>如果程序的规格说明给出的输入域或输出域是有序集合，则应选取集合的第一个元素和最后一个元素作为测试用例</li><li>如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例</li><li>分析规格说明，找出其它可能的边界条件</li></ul><h4 id="白盒测试">10.5 白盒测试</h4><h5 id="白盒测试概述">10.5.1 白盒测试概述</h5><p><strong>白盒测试用例中的输入数据从程序结构导出，但期望输出务必从需求规格中导出</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345499.png" style="zoom:70%;" /></p><h5 id="白盒测试的覆盖标准">10.5.2 白盒测试的覆盖标准</h5><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345445.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345190.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345956.png" style="zoom:80%;" /></p><ul><li><p>语句覆盖</p><p>使每条语句至少被执行一次</p></li><li><p>判定覆盖</p><p>使程序中的每个分支至少都通过一次</p></li><li><p>条件覆盖</p><p>使判定中的<strong>每个条件（不用考虑整体的结果）</strong>获得各种可能的结果</p><p><strong>条件覆盖并不能完全包含判定覆盖，也可能不包含语句覆盖</strong></p></li><li><p>判定/条件覆盖</p><p>使判定中的每个条件取得各种可能的结果，并使得每个分支取得各种可能的结果</p><p>不一定查出逻辑表达式的所有错误</p></li><li><p>条件组合覆盖</p><p>使得每个判定中多个条件的各种取值的可能组合都至少出现一次</p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345199.png" style="zoom:70%;" /></p><h5 id="基本路径法">10.5.3 基本路径法</h5><p>路径测试：设计足够多的测试用例，覆盖被测试对象的所有可能路径</p><p>基本路径测试：保证测试中程序的每一个基本独立路径至少执行一次</p><ol type="1"><li>程序的控制流图：描述程序控制流的一种图示方法</li><li>程序圈复杂度：<span class="math inline">\(McCabe\)</span>复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界</li><li>导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果</li><li>准备测试用例：确保基本路径集中的每一条路径的执行</li></ol><ul><li><p>程序流图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345315.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345807.png" alt="image-20211225011427561" style="zoom:60%;" /></p><p>如果判断中的条件表达式是由一个或多个逻辑运算符 (<span class="math inline">\(OR, AND, NAND, NOR\)</span>) 连接的复合条件表达式，则需要改为一系列只有单条件的嵌套的判断</p><p>独立路径：一条程序执行的路径，至少包含一条在定义该路径之前的其他基本路径不曾用过得边</p><p>圈复杂度：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345553.png" style="zoom:80%;" /></p><p><strong>某些独立路径不能以独立的方式被测试(即穿越路径所需的数据组合不能形成程序的正常流)；在这种情况下，这些路径必须作为另一个路径测试的一部分来进行测试</strong></p><p>“圈复杂度”表示：<strong>只要最多V(G)个测试用例就可以达到基本路径覆盖，但并非一定要设计V(G)个用例</strong></p><p>但是：<strong>测试用例越简化，代表测试越少、可能发现的错误就越少</strong></p></li></ul><h5 id="循环测试法">10.5.4 循环测试法</h5><h5 id="xunit白盒测试">10.5.5 xUnit白盒测试</h5>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件过程与工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指007-斐波那契数列</title>
    <link href="/post/f1ba416b.html"/>
    <url>/post/f1ba416b.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指007-斐波那契数列">剑指007-斐波那契数列</h3><span id="more"></span><p>题目： 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： <figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>,   <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(N)</span></span> = <span class="hljs-built_in">F</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1</span>.<br>斐波那契数列由 <span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 开始，之后的斐波那契数就是由之前的两数相加而得出。<br></code></pre></td></tr></table></figure> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><code>示例 1:</code> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p><p><code>示例 2:</code> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></p><p><code>提示:</code> <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= n &lt;= <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></p><p>解法： <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">MOD</span> =  <span class="hljs-number">1000000007</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> fib(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span>[] dp = new <span class="hljs-built_in">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt; dp.length; i++) &#123;<br>            dp[i] = (dp[i-<span class="hljs-number">1</span>]%<span class="hljs-built_in">MOD</span>) + (dp[i-<span class="hljs-number">2</span>]%<span class="hljs-built_in">MOD</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n]%<span class="hljs-built_in">MOD</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>考察点： 本题是动态规划中的经典题目，用一个数组<code>dp</code>存储<code>F(1) ~ F(n-1)</code>的值，就可以简单实现本题，需要注意的是模操作不要忘记，因为结果会超过<code>Integer.MAX_VALUE</code>。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指006-用两个栈实现队列</title>
    <link href="/post/63c22084.html"/>
    <url>/post/63c22084.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指006-用两个栈实现队列">剑指006-用两个栈实现队列</h3><span id="more"></span><p>题目： 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code>操作返回 -1 )</p><p><code>示例 1:</code> <figure class="highlight prolog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure></p><p><code>示例 2:</code> <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[null,<span class="hljs-number">-1</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure></p><p><code>提示:</code> <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> values &lt;<span class="hljs-operator">=</span> <span class="hljs-number">10000</span><br>最多会对 appendTail、deleteHead 进行 <span class="hljs-number">10000</span> 次调用<br></code></pre></td></tr></table></figure></p><p>解法： <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">class</span> CQueue &#123;<br><br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack1;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack2;<br>    <br>    <span class="hljs-keyword">public</span> CQueue() &#123;<br>        stack1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> appendTail(<span class="hljs-keyword">int</span> value) &#123;<br>        stack1.<span class="hljs-keyword">push</span>(value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> deleteHead() &#123;<br>        <span class="hljs-keyword">if</span>(stack1.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!stack1.isEmpty()) &#123;<br>            stack2.<span class="hljs-keyword">push</span>(stack1.<span class="hljs-keyword">pop</span>());<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = stack2.<span class="hljs-keyword">pop</span>();<br>        <span class="hljs-keyword">while</span>(!stack2.isEmpty()) &#123;<br>            stack1.<span class="hljs-keyword">push</span>(stack2.<span class="hljs-keyword">pop</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue obj = new CQueue();</span><br><span class="hljs-comment"> * obj.appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><br><span class="hljs-comment"> */</span><br>  <br></code></pre></td></tr></table></figure></p><p>考察点： 实际就是使用两个<code>栈</code>实现队列的功能，用<code>stack1</code>进行入队，每一次出队时，先检查<code>stack1</code>中有无数据，若没有说明此时队列为空，然后将<code>stack1</code>和<code>stack2</code>的数据交换，此时应该出队的数据就是<code>stack2</code>的栈顶数据，此时<code>stack2</code>出栈就实现了出队的操作，然后将<code>stack2</code>的数据再压入<code>stack1</code>栈即可。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指005-重建二叉树</title>
    <link href="/post/bb318033.html"/>
    <url>/post/bb318033.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指005--重建二叉树">剑指005--重建二叉树</h3><span id="more"></span><p>题目： 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><code>示例 1:</code> <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251357137.jpeg" /></p><figure class="highlight sas"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">Input</span>: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br><span class="hljs-keyword">Output</span>: [3,9,20,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,15,7]<br></code></pre></td></tr></table></figure><p><code>示例 2:</code> <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: preorder = <span class="hljs-comment">[-1]</span>, inorder = <span class="hljs-comment">[-1]</span><br>Output: <span class="hljs-comment">[-1]</span><br></code></pre></td></tr></table></figure></p><p>解法： <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> TreeNode buildTree(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder) &#123;<br>          <span class="hljs-keyword">return</span> build(preorder,<span class="hljs-number">0</span>,preorder.length<span class="hljs-number">-1</span>,inorder,<span class="hljs-number">0</span>,inorder.length<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    private TreeNode build(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> lp, <span class="hljs-type">int</span> rp, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> li, <span class="hljs-type">int</span> ri) &#123;<br>        <span class="hljs-keyword">if</span>(lp &gt; rp) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> r_vl = preorder[lp];<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = li;i &lt;= ri;i++) &#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == r_vl) &#123;<br>                <span class="hljs-keyword">index</span> = i;<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> left_len = <span class="hljs-keyword">index</span>-li+<span class="hljs-number">1</span>;<br>        TreeNode root = <span class="hljs-built_in">new</span> TreeNode(r_vl);<br>        root.left = build(preorder, lp+<span class="hljs-number">1</span>,lp+left_len<span class="hljs-number">-1</span> , inorder, li, <span class="hljs-keyword">index</span><span class="hljs-number">-1</span>);<br>        root.right = build(preorder, lp+left_len, rp, inorder, <span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>, ri);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure></p><p>考察点： 这道题主要考察的是二叉树的递归，因为对于<code>前序遍历是根-左-右的顺序，中序遍历是左-根-右</code>，递归的关键在于<code>找到根的位置(preorder[lp])以及左子树的长度(left_len)</code>，有了这两个值我们只要注意边界便可以构造出递归函数的参数。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指004-从尾到头打印链表</title>
    <link href="/post/8575b41e.html"/>
    <url>/post/8575b41e.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指004-从尾到头打印链表">剑指004-从尾到头打印链表</h3><span id="more"></span><p>题目： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251357444.png" /></p><p>解法： <figure class="highlight gradle"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack();<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>) &#123;<br>            stack.<span class="hljs-keyword">push</span>(head.val);<br>            head = head.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[stack.<span class="hljs-keyword">size</span>()];<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>            res[i++] = stack.<span class="hljs-keyword">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure></p><p>考察点： 根据题目中所叙述要反向打印，所以想到<code>stack</code>数据结构，<code>push</code>和<code>pop</code>操作即可实现。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指003-替换空格</title>
    <link href="/post/64838390.html"/>
    <url>/post/64838390.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指003-替换空格">剑指003-替换空格</h3><span id="more"></span><p>题目： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251357685.png" /></p><p>解法： <figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String replace<span class="hljs-constructor">Space(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> len = s.length<span class="hljs-literal">()</span>;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27; &#x27;</span>) &#123;<br>                sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>            &#125;<br>        &#125;<br>        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>考察点： 字符串。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指002-二维数组中的查找</title>
    <link href="/post/b3736825.html"/>
    <url>/post/b3736825.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指002--二维数组中的查找">剑指002--二维数组中的查找</h3><span id="more"></span><p>题目： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204262035071.png" /></p><p>解法： <figure class="highlight aspectj"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-keyword">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> n = matrix.length;<br>        <span class="hljs-keyword">int</span> m = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> nn = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> mm = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = matrix[nn][mm];<br>        <span class="hljs-keyword">while</span>(res != <span class="hljs-keyword">target</span> &amp;&amp; nn &gt;= <span class="hljs-number">0</span> &amp;&amp; mm &lt; m) &#123;<br>            <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-keyword">target</span>) &#123;<br>                nn--;<br>                <span class="hljs-keyword">if</span>(nn &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                res = matrix[nn][mm];<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(res &lt; <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>                mm++;<br>                <span class="hljs-keyword">if</span>(mm &gt;= m) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                res = matrix[nn][mm];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>考察点： 根据题目中递增的描述，不难发现从左下角的顶点开始分析可以极大的简化，如果比<code>target</code>小，则<code>nn--</code>，如果比<code>target</code>大，则<code>mm++</code>，注意边界条件即可。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC学习</title>
    <link href="/post/1c335eca.html"/>
    <url>/post/1c335eca.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对JDBC进行相关总结</p><span id="more"></span><p><span class="math inline">\(JDBC\)</span>是SUN公司定义的一套接口，因为每一个数据库的底层实现原理都不一样，所以需要引入这一套规范。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251400895.png" /></p><p>首先引入依赖，可以下载对应<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">jar包</a>,具体步骤这里不再详说。 接下来到了具体JDBC代码的编写，主要分为以下6步。 <strong>1.注册驱动</strong>（告诉<span class="math inline">\(java\)</span>程序，即将连接的是哪个公司的数据库） 这一步最原始的写法是： <figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>    Driver driver = <span class="hljs-keyword">new</span> com.mysql.cj.jdbc.<span class="hljs-constructor">Driver()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>register<span class="hljs-constructor">Driver(<span class="hljs-params">driver</span>)</span>;<br>&#125; catch (SQLException e) &#123;<br>    e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 通过Driver类获取到JDBC驱动。而查看<code>com.mysql.cj.jdbc.Driver</code>的源码 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.mysql.cj.jdbc;<br><br><span class="hljs-keyword">import</span> java.sql.<span class="hljs-type">DriverManager</span>;<br><span class="hljs-keyword">import</span> java.sql.<span class="hljs-type">SQLException</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-title">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>&#123;<br>    public <span class="hljs-type">Driver</span>() <span class="hljs-keyword">throws</span> <span class="hljs-type">SQLException</span> &#123;<br>    &#125;<br><br>    static &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DriverManager</span>.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-type">Driver</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">SQLException</span> var1) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 可以看到有一个静态代码块完成了<code>registerDriver</code>的工作，所以我们只需要使用反射机制即可： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)</span>;<br>&#125; catch (ClassNotFoundException e) &#123;<br>    e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></td></tr></table></figure> <strong>2.获取连接</strong>（表示<span class="math inline">\(JVM\)</span>的进程和数据库进程之间的通道打开了，这属于进程之间的通信，比较重量级，使用完需要关闭） 这里使用如下方法进行连接的获取： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>get<span class="hljs-constructor">Connection(<span class="hljs-string">&quot;jdbc:mysql://ip:port/dbname&quot;</span>,<span class="hljs-params">user</span>,<span class="hljs-params">passwd</span>)</span>;<br></code></pre></td></tr></table></figure> 比如我的ip就用本地<code>localhost</code>或者<code>127.0.0.1</code>，<code>port</code>一般使用3306，<code>dbname</code>、<code>user</code>和<code>passwd</code>根据自己的数据库修改即可。 <strong>3.获取数据库对象</strong>（专门执行<span class="math inline">\(SQL\)</span>语句的对象） 可以使用<code>Statement</code>来获取数据库对象： <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Statement stmt <span class="hljs-operator">=</span> conn.createStatement()<span class="hljs-comment">;</span><br>String sql <span class="hljs-operator">=</span> <span class="hljs-string">&quot;....&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure> 注意这里的sql语句定义在stmt之后,如果使用<code>Statement</code>的话，可能会遇到sql注入问题，具体可以参考：<a href="https://www.jianshu.com/p/643866408bb7">SQL注入</a>这篇博客，所以我们一般使用<code>PreparedStatement</code>获取数据库对象： <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String sql <span class="hljs-operator">=</span> <span class="hljs-string">&quot;....&quot;</span><span class="hljs-comment">;</span><br>PreparedStatement ps <span class="hljs-operator">=</span> conn.prepareStatement(sql)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure> 注意这里的sql语句定义在ps之前,可以看看源码 <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">PreparedStatement</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Statement</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure> <code>PreparedStatement</code>继承自<code>Statement</code>，它也是一个接口。解决sql注入问题的关键在于不让用户输入的语句参与sql语句的编译过程，<code>PreparedStatement</code>的原理是预先对sql语句的框架进行预编译，然后再给sql语句传值。 在sql语句里需要的值先用<code>?</code>替换，具体使用可以参见下一部分。 <strong>Tips</strong>：当然这里说一句<code>Statement</code>和<code>PreparedStatement</code>各有各的用处，并不是一股脑就用<code>PreparedStatement</code>的，以下情况一般使用<code>Statement</code>：(1).业务逻辑需要sql注入；(2).需要sql语句拼接。 <strong>4.执行<span class="math inline">\(SQL\)</span>语句</strong>（<span class="math inline">\(DQL，DML\)</span>） 以下为原表 <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401265.png" /></p><ul><li><p>增 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String sql = <span class="hljs-string">&quot;insert into sc value(?,?,?)&quot;</span>;<br>ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>ps.set<span class="hljs-constructor">String(1,<span class="hljs-string">&quot;12345678&quot;</span>)</span>;<br>ps.set<span class="hljs-constructor">String(2,<span class="hljs-string">&quot;222&quot;</span>)</span>;<br>ps.set<span class="hljs-constructor">String(3,<span class="hljs-string">&quot;96&quot;</span>)</span>;<br><span class="hljs-built_in">int</span> count = ps.execute<span class="hljs-constructor">Update()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(count);<br></code></pre></td></tr></table></figure> 以下为运行结果： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401211.png" /> 以下为现在的表： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401993.png" /></p></li><li><p>删 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String sql = <span class="hljs-string">&quot;delete from sc where s_id = ?&quot;</span>;<br>ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>ps.set<span class="hljs-constructor">String(1,<span class="hljs-string">&quot;12345678&quot;</span>)</span>;<br><span class="hljs-built_in">int</span> count = ps.execute<span class="hljs-constructor">Update()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(count);<br></code></pre></td></tr></table></figure> 以下为运行结果： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401860.png" /> 以下为现在的表： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401617.png" /></p></li><li><p>改 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String sql = <span class="hljs-string">&quot;update sc set score = ? where s_id = 98020101&quot;</span>;<br>ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>ps.set<span class="hljs-constructor">String(1,<span class="hljs-string">&quot;90&quot;</span>)</span>;<br><span class="hljs-built_in">int</span> count = ps.execute<span class="hljs-constructor">Update()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(count);<br></code></pre></td></tr></table></figure> 以下为运行结果： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401487.png" /> 以下为现在的表： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401601.png" /></p></li><li><p>查 <figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select s_id,c_id,score from sc where score &gt; ?&quot;</span>;<br><span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-variable">conn</span>.<span class="hljs-property">prepareStatement</span>(<span class="hljs-variable">sql</span>);<br><span class="hljs-variable">ps</span>.<span class="hljs-property">setString</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;85&quot;</span>);<br><span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-variable">ps</span>.<span class="hljs-property">executeQuery</span>();<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-string">&quot;s_id<span class="hljs-char escape_">\t</span>c_id<span class="hljs-char escape_">\t</span>score&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-variable">rs</span>.<span class="hljs-property">next</span>()) &#123;<br>    <span class="hljs-title class_">String</span> <span class="hljs-variable">sid</span> <span class="hljs-operator">=</span> <span class="hljs-variable">rs</span>.<span class="hljs-property">getString</span>(<span class="hljs-string">&quot;s_id&quot;</span>);<br>    <span class="hljs-title class_">String</span> <span class="hljs-variable">cid</span> <span class="hljs-operator">=</span> <span class="hljs-variable">rs</span>.<span class="hljs-property">getString</span>(<span class="hljs-string">&quot;c_id&quot;</span>);<br>    <span class="hljs-title class_">String</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-variable">rs</span>.<span class="hljs-property">getString</span>(<span class="hljs-string">&quot;score&quot;</span>);<br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">sid</span> <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\t</span>&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">cid</span> <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\t</span>&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">score</span>);<br>&#125;<br></code></pre></td></tr></table></figure> 以下为运行结果： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251402376.png" /></p></li></ul><p><strong>5.处理查询结果集</strong>（只有执行<span class="math inline">\(DQL\)</span>语句后需要） <span class="math inline">\(DML\)</span>一语句一般返回<code>int</code>类型的量，而<span class="math inline">\(DQL\)</span>语句返回一个<span class="math inline">\(ResultSet\)</span>类型的量。 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//if DML</span><br><span class="hljs-built_in">int</span> res = ps.execute<span class="hljs-constructor">Update()</span>;<br></code></pre></td></tr></table></figure></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//if DQL</span><br>ResultSet rs = ps.execute<span class="hljs-constructor">Query()</span>;<br><span class="hljs-keyword">while</span> (rs.next<span class="hljs-literal">()</span>) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(1)</span>);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(2)</span>);<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>但是上面这种可能没有灵活性，所以有以下写法： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//if DQL</span><br>ResultSet rs = ps.execute<span class="hljs-constructor">Query()</span>;<br><span class="hljs-keyword">while</span> (rs.next<span class="hljs-literal">()</span>) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(<span class="hljs-params">col_name1</span>)</span>);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(<span class="hljs-params">col_name2</span>)</span>);<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure> 上面的<code>col_name1</code>,<code>col_name2</code>都是列名，这样也更加具有灵活性。</p><p><strong>6.释放资源</strong> 根据开启的顺序反向关闭<code>conn</code>，<code>ps</code>，<code>rs</code> <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss">if (rs != null) &#123;<br>    try &#123;<br>        rs<span class="hljs-selector-class">.close</span>();<br>    &#125; catch (SQLException e) &#123;<br>        e<span class="hljs-selector-class">.printStackTrace</span>();<br>    &#125;<br>&#125;<br>if (ps != null) &#123;<br>    try &#123;<br>        ps<span class="hljs-selector-class">.close</span>();<br>    &#125; catch (SQLException e) &#123;<br>        e<span class="hljs-selector-class">.printStackTrace</span>();<br>    &#125;<br>&#125;<br>if (conn != null) &#123;<br>    try &#123;<br>        conn<span class="hljs-selector-class">.close</span>();<br>    &#125; catch (SQLException e) &#123;<br>        e<span class="hljs-selector-class">.printStackTrace</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>接下来，可以对以上内容进行封装 封装一个工具类<code>DBUtil</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装JDBC工具类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fly-beep</span><br><span class="hljs-comment"> */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBUtil</span> &#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取数据库连接对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 连接对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment">       */</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sct&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;333&quot;</span>);<br>         &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭各种已经建立的资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ps</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rs</span><br><span class="hljs-comment">       */</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Connection conn,Statement ps,ResultSet rs)</span> &#123;<br>        <span class="hljs-keyword">if</span> (rs != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ps != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ps.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>       &#125;<br>         &#125;<br>         <br></code></pre></td></tr></table></figure></p><p>具体使用如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询以王开头的学生学号和姓名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fly-beep</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jdbcTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            conn = DBUtil.getConnection();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select s_id,s_name from student where s_name like ?&quot;</span>;<br>            ps = conn.prepareStatement(sql);<br>            ps.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;王%&quot;</span>);<br>            rs = ps.executeQuery();<br>            System.out.println(<span class="hljs-string">&quot;s_id&quot;</span> + <span class="hljs-string">&quot;\t\t&quot;</span> + <span class="hljs-string">&quot;s_name&quot;</span>);<br>            <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>                System.out.println(rs.getString(<span class="hljs-string">&quot;s_id&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span> + rs.getString(<span class="hljs-string">&quot;s_name&quot;</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            DBUtil.close(conn,ps,rs);<br>        &#125;<br>    &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure></p><p>查询结果如下： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251402843.png" /></p><p>JDBC执行事务操作 JDBC中的事务是自动提交的，只要执行任意一条<code>DML</code>语句，则自动提交一次。而我们可以使用conn的<code>setAutoCommit</code>函数取消这种自动提交机制。 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>    .....<br>    conn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>get<span class="hljs-constructor">Connection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sct&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;333&quot;</span>)</span>;<br>    <span class="hljs-comment">//取消自动提交事务</span><br>    conn.set<span class="hljs-constructor">AutoCommit(<span class="hljs-params">false</span>)</span>;<br>    String sql1 = <span class="hljs-string">&quot;&quot;</span>;<br>    String sql2 = <span class="hljs-string">&quot;&quot;</span>;<br>    .....<br><br>    ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql1</span>)</span>;<br>    ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql2</span>)</span>;<br>    .....<br>    <br>    <span class="hljs-comment">//运行到这说明没有问题，提交事务</span><br>    conn.commit<span class="hljs-literal">()</span>;<br>&#125; catch (Exception e) &#123;<br>    <span class="hljs-keyword">if</span>(conn != null) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//回滚事务</span><br>            conn.rollback<span class="hljs-literal">()</span>;<br>        &#125; catch (SQLException ex) &#123;<br>            ex.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 以上即为JDBC部分的全部内容！</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指001--数组中的重复数字</title>
    <link href="/post/25ec103e.html"/>
    <url>/post/25ec103e.html</url>
    
    <content type="html"><![CDATA[<h3 id="剑指001--数组中的重复数字">剑指001--数组中的重复数字</h3><span id="more"></span><p>题目： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/HMkDaZdG76ytCwe.png" /></p><p>解法： <figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[len];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++) &#123;<br>            res[nums[i]]++;<br>            <span class="hljs-keyword">if</span>(res[nums[i]] &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>考察点： 注意题目中所说的<code>数组 nums 里的所有数字都在 0～n-1 的范围内</code>就可以很快分析出这种做法，创建一个大小为<code>n</code>的数组即可。</p>]]></content>
    
    
    <categories>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postgresql安装pg_hint_plan插件</title>
    <link href="/post/72be2669.html"/>
    <url>/post/72be2669.html</url>
    
    <content type="html"><![CDATA[<p>解决<span class="math inline">\(postgresql\)</span>安装pg_hint_plan插件的相关问题</p><span id="more"></span><p>前言：由于项目需要，我需要使用<span class="math inline">\(postgresql\)</span>中的pg_hint_plan插件进行相关的分析，但是在安装中网上却并未找到很有效的相关资料，现总结如下：</p><p>本机配置： <span class="math inline">\(CentOs\ 7.6\)</span></p><h2 id="安装postgresql">安装<span class="math inline">\(postgresql\)</span></h2><p>参考<a href="https://www.postgresql.org/download/linux/redhat/">官网</a>上的描述，主要使用以下代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">sudo yum install -y https:<span class="hljs-regexp">//</span>download.postgresql.org<span class="hljs-regexp">/pub/</span>repos<span class="hljs-regexp">/yum/</span>reporpms<span class="hljs-regexp">/EL-7-x86_64/</span>pgdg-redhat-repo-latest.noarch.rpm<br>sudo yum install -y postgresql14-server<br>sudo <span class="hljs-regexp">/usr/</span>pgsql-<span class="hljs-number">14</span><span class="hljs-regexp">/bin/</span>postgresql-<span class="hljs-number">14</span>-setup initdb<br>sudo systemctl enable postgresql-<span class="hljs-number">14</span><br>sudo systemctl start postgresql-<span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><p>初始化数据库： <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/usr/</span>pgsql-<span class="hljs-number">14</span><span class="hljs-regexp">/bin/</span>postgresql-<span class="hljs-number">14</span>-setup initdb<br></code></pre></td></tr></table></figure></p><p>设置开机启动： <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo systemctl <span class="hljs-built_in">enable</span> postgresql-14<br></code></pre></td></tr></table></figure></p><p>启动postgresql服务 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> systemctl start postgresql-<span class="hljs-number">14</span><br></code></pre></td></tr></table></figure></p><p>设置数据库密码 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">su postgres<br>psql<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> postgres <span class="hljs-keyword">with</span> <span class="hljs-keyword">password</span> <span class="hljs-string">&#x27;yourpwd&#x27;</span><br></code></pre></td></tr></table></figure></p><p>开启远程访问 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/pgsql/</span><span class="hljs-number">14</span><span class="hljs-regexp">/data/</span>postgresql.conf<br></code></pre></td></tr></table></figure></p><p>找到下面的listen_address: <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">listen_address</span> = <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure></p><p>增加信任连接 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">vi /var/lib/pgsql/<span class="hljs-number">14</span>/data/pg_hba.conf<br></code></pre></td></tr></table></figure></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># IPv4 local connections:</span><br><span class="hljs-attribute">host</span>    <span class="hljs-literal">all</span>             <span class="hljs-literal">all</span>             <span class="hljs-number">0.0.0.0</span>/<span class="hljs-number">0</span>               trust<br></code></pre></td></tr></table></figure><p>重启服务 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">systemctl</span> restart postgresql-<span class="hljs-number">14</span><br></code></pre></td></tr></table></figure></p><p>添加端口号并重启防火墙 <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">zone=public</span> <span class="hljs-literal">--</span><span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">port=5432/tcp</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanent</span><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">reload</span><br></code></pre></td></tr></table></figure></p><p>这时候可以检查一下： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">rpm -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> postgresql<br></code></pre></td></tr></table></figure></p><p>命令行会输出以下信息： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">postgresql14</span>-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-libs-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-server-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br></code></pre></td></tr></table></figure></p><p>并且保证此时在root的权限下直接输入： <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">su postgres</span><br></code></pre></td></tr></table></figure></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">su postgres</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">psql</span><br></code></pre></td></tr></table></figure><p>此时可以成功打开postgres即可！</p><h2 id="安装postgresql-devel">安装<span class="math inline">\(postgresql-devel\)</span></h2><p>这一步可以说是最坑的了，因为一般安装postgresql时只会安装 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">postgresql14</span>-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-libs-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-server-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br></code></pre></td></tr></table></figure></p><p>这三个包，但是这时的postgresql是<strong>没有C/C++环境</strong>的，而我们如果想要安装pg_hint_plan的话是需要的，所以我们需要安装<span class="math inline">\(postgresql-devel\)</span>。</p><p>直接运行： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> postgresql14-devel<br></code></pre></td></tr></table></figure></p><p>这时输入： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">rpm -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> postgresql<br></code></pre></td></tr></table></figure></p><p>命令行会输出以下信息： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">postgresql14</span>-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-libs-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-devel-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-server-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br></code></pre></td></tr></table></figure></p><h2 id="安装pg_hint_plan插件">安装pg_hint_plan插件</h2><p>从<a href="https://github.com/ossc-db/pg_hint_plan/tags">官网</a>按照对应PG14版本的pg_hint_plan的<span class="math inline">\(.tar.gz\)</span>文件。</p><p>我下载的是pg_hint_plan-REL14_1_4_0.tar.gz</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">tar -zxvf pg_hint_plan-REL14_1_4_0.tar.gz<br>make<br>make install<br></code></pre></td></tr></table></figure><p>但是这时会遇到另一个坑了，以上代码是作者写在<span class="math inline">\(README.md\)</span>中的下载方法，但是这时你需要设置路径，所以应该执行以下代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">tar -zxvf pg_hint_plan-REL14_1_4_0.tar.gz<br>export <span class="hljs-type">PATH</span>=&quot;$PATH:/usr/pgsql-14/bin&quot;<br>make<br>make install<br></code></pre></td></tr></table></figure><p>这时就没问题了！</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251402401.png" /></p><hr /><p>参考链接：</p><ul><li><a href="https://www.postgresql.org/download/linux/redhat/">https://www.postgresql.org/download/linux/redhat/</a></li><li><a href="https://centos.pkgs.org/7/postgresql-14-aarch64/postgresql14-devel-14.2-1PGDG.rhel7.aarch64.rpm.html">https://centos.pkgs.org/7/postgresql-14-aarch64/postgresql14-devel-14.2-1PGDG.rhel7.aarch64.rpm.html</a></li><li><a href="https://stackoverflow.com/questions/4293111/postgresql-pg-config-bash-pg-config-command-not-found">https://stackoverflow.com/questions/4293111/postgresql-pg-config-bash-pg-config-command-not-found</a></li><li><a href="https://github.com/ossc-db/pg_hint_plan/tags">https://github.com/ossc-db/pg_hint_plan/tags</a></li><li><a href="https://github.com/ossc-db/pg_hint_plan/issues/57">https://github.com/ossc-db/pg_hint_plan/issues/57</a></li><li><a href="https://osdn.net/projects/pghintplan/howto/install">https://osdn.net/projects/pghintplan/howto/install</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/post/63785.html"/>
    <url>/post/63785.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇文章">第一篇文章</h1><hr /><p>写这篇文章主要是要警示自己：<strong>绝知此事要躬行</strong> <span id="more"></span></p><hr /><p>下面放一些自己喜欢的句子：</p><hr /><p>苦难既然把我推到了悬崖的边缘，那么就让我在这悬崖边坐下来，顺便看看悬崖下的流岚雾霭，唱支歌给你听。</p><hr /><p>酒一杯，敬温华不练剑， 酒二杯，敬李淳罡为后辈开山， 酒三杯，敬曹官子一人攻城， 酒四杯，敬黄三甲为万世开太平， 酒五杯，敬李义山为北凉谋生路， 酒六杯，敬洪洗象为红颜修正道， 酒七杯，敬李玉斧为后世关天门， 酒八杯，敬徐凤年为中原百姓守国门， 酒九杯，敬中原宗师拒北城悍然赴死。</p><hr /><p>最后，Saber镇站：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/Saber.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
