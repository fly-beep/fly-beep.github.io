<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SQL必知必会笔记（三）</title>
    <link href="/post/5c6fe708.html"/>
    <url>/post/5c6fe708.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对<a href="https://time.geekbang.org/column/intro/100029501">SQL必知必会</a>的内容进行总结</p><span id="more"></span><h1 id="sql必知必会笔记三">SQL必知必会笔记（三）</h1><h3 id="代价统计">代价统计🎓</h3><p>查询优化器的目的就是生成最佳的执行计划，而生成最佳执行计划的策略通常有以下两种方式。</p><ul><li>基于规则的优化器 RBO</li><li>基于代价的优化器 CBO</li><li>RBO 的方式更像是一个出租车老司机，凭借自己的经验来选择从 A 到 B 的路径。而 CBO 更像是手机导航，通过数据驱动，来选择最佳的执行路径。</li></ul><h3 id="查询优化">查询优化🐉</h3><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/%E4%B8%8B%E8%BD%BD.png" /></p><ul><li><p>慢查询可以帮我们定位执行慢的 SQL 语句。我们可以通过设置 long_query_time 参数定义“慢”的阈值，如果 SQL 执行时间超过了 long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。</p></li><li><p>EXPLAIN 查看对应 SQL 语句的执行计划，或者使用 show profile 查看 SQL 中每一个步骤的时间成本。这样我们就可以了解 SQL 查询慢是因为执行时间长，还是等待时间长。</p></li><li><p>EXPLAIN中type的含义：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528145128812.png" /></p><ul><li>all 是最坏的情况，因为采用了全表扫描的方式。</li><li>index 和 all 差不多，只不过 index 对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大。</li><li>range 表示采用了索引范围扫描。尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式。</li><li>index_merge 说明查询同时使用了两个或以上的索引，最后取了交集或者并集。</li><li>ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀。</li><li>eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。</li><li>const 类型表示我们使用了主键或者唯一索引（所有的部分）与常量值进行比较。<ul><li>const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中。</li></ul></li><li>system 类型一般用于 MyISAM 或 Memory 表，属于 const 类型的特例，当表只有一行时连接类型为 system。</li><li>效率从低到高依次为 all &lt; index &lt; range &lt; index_merge &lt; ref &lt; eq_ref &lt; const/system。我们在查看执行计划的时候，通常希望执行计划至少可以使用到 range 级别以上的连接方式，如果只使用到了 all 或者 index 连接方式，我们可以从 SQL 语句和索引设计的角度上进行改进。</li><li>如果两表关联查询，可以这样理解：<ol type="1"><li>ref - 双层循环，直到找出所有匹配。</li><li>eq_ref - 双层循环，借助索引的唯一性，找到匹配就马上退出内层循环。</li><li>const: 单层循环。</li></ol></li></ul></li><li><p>查看当前会话所有开销：<code>show profiles</code>、查看上一个查询的开销 <code>show profile;</code> 、查看指定的 Query ID 的开销 <code>show profile for query ID_num</code> 、命令将被弃用，可以从 information_schema 中的 profiling 数据表进行查看。</p></li></ul><h3 id="主从同步">主从同步🐷</h3><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220529162228714.png" /></p><p>在实际工作中，我们常常将Redis作为缓存与MySQL配合来使用，当有数据访问请求的时候，首先会从缓存中进行查找，如果存在就直接取出，如果不存在再访问数据库，这样就提升了读取的效率，也减少了对后端数据库的访问压力。可以说使用Redis这种缓存架构是高并发架构中非常重要的一环。</p><p>我们也可以对 MySQL做主从架构并且进行读写分离，让主服务器(Master）处理写请求，从服务器(Slave)处理读请求，这样同样可以提升数据库的并发处理能力。</p><p>主从同步</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先需要考虑的应该是如何优化 SQL 和索引，这种方式简单有效，其次才是采用缓存的策略，比如使用 Redis，通过 Redis 高性能的优势将热点数据保存在内存数据库中，提升读取的效率，最后才是对数据库采用主从架构，进行读写分离。</p><p>作用：</p><ul><li><p>提高数据库的吞吐量</p></li><li><p>读写分离</p><p>我们可以通过主从复制的方式来同步数据，然后通过读写分离提高数据库并发处理能力。</p><p>简单来说就是同一份数据被放到了多个数据库中，其中一个数据库是 Master主库，其余的多个数据库是Slave从库。当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库中进行读取，也就是采用读写分离的方式。互联网的应用往往是—些“读多写少”的需求，采用读写分离的方式，可以实现更高的并发访问。原本所有的读写压力都由一台服务器承担，现在有多个“兄弟”帮忙处理读请求，这样就减少了对后端大哥(Master)的压力。同时，我们还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器上，让读取更加顺畅。读取顺畅的另一个原因，就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。</p></li><li><p>数据备份</p><p>我们通过主从复制将主库上的数据复制到了从库上，相当于是一种热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务。</p></li><li><p>高可用性</p><p>数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现故障或宕机的情况下，可以切换到从服务器上，保证服务的正常运行。</p></li></ul><p>主从同步原理</p><ul><li><p>主从同步的原理主要基于Binlog日志进行数据同步。在主从复制过程中，会基于三个线程操作，一个主库线程，两个从库线程。【主从复制就是主从同步】</p></li><li><p>二进制日志转储线程（Binlog dump thread）是一个主库线程。</p><p>当从库线程连接的时候，主库可以将二进制日志发送给从库，当主库读取事件的时候，会在 Binlog 上加锁，读取完成之后，再将锁释放掉。</p><p>从库 I/O 线程会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地形成中继日志（Relay log）。</p><p>从库 SQL 线程会读取从库中的中继日志，并且执行日志中的事件，从而将从库中的数据与主库保持同步。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220529202152025.png" /></p><p>主从同步的内容就是二进制日志（Binlog），它虽然叫二进制日志，实际上存储的是一个又一个事件（Event），这些事件分别对应着数据库的更新操作，比如 INSERT、UPDATE、DELETE 等。</p><p>进行主从同步的内容是二进制日志，它是一个文件，在进行网络传输的过程中就一定会存在延迟（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的数据不一致性问题。比如我们对一条记录进行更新，这个操作是在主库上完成的，而在很短的时间内（比如 100ms）又对同一个记录进行了读取，这时候从库还没有完成数据的更新，那么我们通过从库读到的数据就是一条旧的记录。</p></li></ul><p>解决主从同步数据一致性问题</p><ul><li><p>异步复制</p><p>客户端提交 COMMIT 之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而 Binlog 还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/1664bdb81d017359a126030ee08e0a85.png" /></p></li><li><p>半同步复制</p><p>在客户端提交 COMMIT 之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了 Binlog，并且写入到中继日志中，再返回给客户端。这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/08566325d0933775d13196330596a1a1.jpg" /></p></li><li><p>组复制（MGR）</p><p>基于 Paxos 协议的状态机复制。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/39cc2dd2a96e27dbdef3dc87aa8d15ab.png" /></p><p>首先我们将多个节点共同组成一个复制组，在执行读写（RW）事务的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于（N/2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对只读（RO）事务则不需要经过组内同意，直接 COMMIT 即可。</p></li></ul><h3 id="redis简介">Redis简介👻</h3><p>Redis速度快的原因</p><ul><li>C 语言编写，底层代码执行效率高，依赖性低，而且系统的兼容性好，稳定性高。</li><li>基于内存，可以避免磁盘 I/O。</li><li>数据结构结构简单，Redis 采用 Key-Value 方式进行存储，也就是使用 Hash 结构进行操作，数据的操作复杂度为 O(1)。</li><li>单进程单线程模型，避免了上下文切换和不必要的线程之间引起的资源竞争。</li><li>多路 I/O 复用技术。这里的多路指的是多个 socket 网络连接，复用指的是复用同一个线程。采用多路 I/O 复用技术的好处是可以在同一个线程中处理多个 I/O 请求，尽量减少网络 I/O 的消耗，提升使用效率。</li></ul><table><thead><tr class="header"><th style="text-align: center;">数据类型</th><th style="text-align: center;">可以存储的值</th><th style="text-align: center;">操作</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">string</td><td style="text-align: center;">字符串、整数或者浮点数</td><td style="text-align: center;">对整个字符串或者字符串的其中一部分执行操作，对整数和浮点数执行自增或者自减操作</td></tr><tr class="even"><td style="text-align: center;">list</td><td style="text-align: center;">列表</td><td style="text-align: center;">从两端压入或者弹出元素 对单个或者多个元素进行修剪，只保留一个范围内的元素</td></tr><tr class="odd"><td style="text-align: center;">set</td><td style="text-align: center;">无序集合</td><td style="text-align: center;">添加、获取、移除单个元素，检查一个元素是否存在于集合中， 计算交集、并集、差集， 从集合里面随机获取元素</td></tr><tr class="even"><td style="text-align: center;">hash</td><td style="text-align: center;">包含键值对的无序散列表</td><td style="text-align: center;">添加、获取、移除单个键值对，获取所有键值对， 检查某个键是否存在</td></tr><tr class="odd"><td style="text-align: center;">zset</td><td style="text-align: center;">有序集合</td><td style="text-align: center;">添加、获取、删除元素， 根据分值范围或者成员来获取元素，计算一个键的排名</td></tr></tbody></table><ul><li><p>字符串（string）：key-value</p><p><code>set key xxx</code></p><p><code>get key</code></p></li><li><p>列表（list）：双向链表</p><p><code>lpush listname xxx yyy zzz</code></p><p><code>rpush listname xxx yyy zzz</code></p><p><code>lrange listname start end</code></p></li><li><p>无序集合（set）</p><p><code>sadd setname xxx yyy zzz</code></p><p><code>srem setname xxx yyy</code> 【删除xxx和yyy】</p><p><code>smembers setname</code> 【获取所有元素】</p><p><code>sismember setname xxx</code> 【判断xxx是否在set中】</p></li><li><p>哈希（hash）：key-field-value</p><p><code>hset user username zhangfei</code></p><p><code>hget user username</code></p></li><li><p>有序集合（zset）： zset是在集合的基础上增加了一个分数属性，这个属性在添加修改元素的时候可以被指定。每次指定后，zset都会按照分数来进行自动排序，也就是说我们在给集合 key 添加 member 的时候，可以指定 score。</p><p><code>zadd zsetname score1 xxx score2 yyy</code></p><p><code>zscore zsetname xxx</code></p><p><code>zrem zsetname xxx</code></p><p><code>zrange zsetname start end [WITHSCORES]</code> 【从小到大】</p><p><code>zrevrange zsetname start end [WITHSCORES]</code>【从大到小】</p></li></ul><p>基于直接连接的弊端，Redis 提供了连接池的机制，这个机制可以让我们事先创建好多个连接，将其放到连接池中，当我们需要进行 Redis 操作的时候就直接从连接池中获取，完成之后也不会直接释放掉连接，而是将它返回到连接池中。连接池机制可以避免频繁创建和释放连接，提升整体的性能。</p><p>在连接池的实例中会有两个 list，保存的是连接池中可以使用的连接集合（<code>_available_connections</code>）和正在使用的连接集合（<code>_in_use_connections</code>）。</p><p>Redis事务相关</p><ul><li><p>Redis 不支持事务的回滚机制（Rollback），这也就意味着当事务发生了错误（只要不是语法错误），整个事务依然会继续执行下去，直到事务队列中所有命令都执行完毕。因为支持回滚会对 Redis 的简单性和性能产生重大影响。</p></li><li><p>Redis 是内存数据库，与基于文件的 RDBMS 不同，通常只进行内存计算和操作，无法保证持久性。</p></li><li><p>持久化方法：</p><ol type="1"><li><p>RDB</p><p>把当前进程的数据生成快照保存到磁盘上，触发 RDB 持久化的方式分为手动触发和自动触发。因为持久化操作与命令操作不是同步进行的，所以无法保证事务的持久性。</p></li><li><p>AOF</p><p>采用日志的形式记录每个写操作，弥补了 RDB 在数据一致性上的不足，但是采用 AOF 模式，就意味着每条执行命令都需要写入文件中，会大大降低 Redis 的访问性能。启用 AOF 模式需要手动开启，有 3 种不同的配置方式，默认为 everysec，也就是每秒钟同步一次。其次还有 always 和 no 模式，分别代表只要有数据发生修改就会写入 AOF 文件，以及由操作系统决定什么时候记录到 AOF 文件中。</p></li></ol></li><li><p>命令</p><ol type="1"><li>MULTI：开启一个事务；</li><li>EXEC：事务执行，将一次性执行事务内的所有命令；</li><li>DISCARD：取消事务；</li><li>WATCH：监视一个或多个键，如果事务执行前某个键发生了改动，那么事务也会被打断；</li><li>UNWATCH：取消 WATCH 命令对所有键的监视。</li></ol></li><li><p>Redis 实现事务是基于 COMMAND 队列，如果 Redis 没有开启事务，那么任何的 COMMAND 都会立即执行并返回结果。如果 Redis 开启了事务，COMMAND 命令会放到队列中，并且返回排队的状态 QUEUED，只有调用 EXEC，才会执行 COMMAND 队列中的命令。</p></li><li><p>MULTI 后不能再执行 WATCH 命令</p></li><li><p>如果在执行命令过程中有语法错误，Redis 也会报错，整个事务也不会被执行，Redis 会忽略运行时发生的错误，不会影响到后面的执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#开启事务</span></span><br>127.0.0.1:6379&gt; multi <br>OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#添加命令入队</span></span><br>127.0.0.1:6379&gt; set k1 v1 <br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3 <br>QUEUED<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#提示编译型异常</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#代码语法出现错误</span></span><br>127.0.0.1:6379&gt; getset k3<br>(error) ERR wrong number of arguments for &#x27;getset&#x27; command<br>127.0.0.1:6379&gt; set k4 v4 <br>QUEUED<br>127.0.0.1:6379&gt; set k5 v5<br>QUEUED<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#提交事务</span></span><br>127.0.0.1:6379&gt; exec<br>(error) EXECABORT Transaction discarded because of previous errors.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#尝试获取值</span></span><br>127.0.0.1:6379&gt; get k1 <br>(nil)<br>127.0.0.1:6379&gt; get k2 <br>(nil)<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#开启事务</span></span><br>127.0.0.1:6379&gt; multi <br>OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#添加命令入队</span></span><br>127.0.0.1:6379&gt; set v1 sss<br>QUEUED<br>127.0.0.1:6379&gt; incr v1 <br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2 <br>QUEUED<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#执行事务</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#逻辑异常的命令不被执行,其他命令正常执行</span></span><br>127.0.0.1:6379&gt; exec<br>1) OK<br>2) (error) ERR value is not an integer or out of range<br>3) OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#尝试获取值</span></span><br>127.0.0.1:6379&gt; get k1<br>(nil)<br>127.0.0.1:6379&gt; get k2<br>&quot;v2&quot;<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure></li><li><p>在 Redis 中不存在悲观锁，事务处理要考虑到并发请求的情况，我们需要通过 WATCH+MULTI 的方式来实现乐观锁，如果监视的 KEY 没有发生变化则可以顺利执行事务，否则说明事务的安全性已经受到了破坏，服务器就会放弃执行这个事务，直接向客户端返回空回复（nil），事务执行失败后，我们可以重新进行尝试。</p></li></ul><p>Redis使用Lua</p><ul><li>Lua 是一个小巧的脚本语言，采用标准 C 语言编写，一个完整的 Lua 解析器大小只有 200 K。它可以嵌入到各种应用程序中，提供灵活的扩展和定制功能。</li><li><code>EVAL script numkeys key [key ...] arg [arg ...]</code><ol type="1"><li>script，代表的是 Lua 的脚本内容。</li><li>numkeys，代表后续参数 key 的个数。</li><li>key 就是我们要操作的键，可以是多个键。我们在 Lua 脚本中可以直接使用这些 key，直接通过<code>KEYS[1]</code>、<code>KEYS[2]</code>来获取，默认下标是从 1 开始。</li><li>arg，表示传入到 Lua 脚本中的参数，就像调用函数传入的参数一样。在 Lua 脚本中我们可以通过<code>ARGV[1]</code>、<code>ARGV[2]</code>来进行获取，同样默认下标从 1 开始。</li></ol></li><li>在命令中调用 Lua 脚本：<code>redis-cli --eval lua_file key1 key2 , arg1 arg2 arg3</code></li></ul><p>Redis VS MongoDB</p><ul><li>Redis 是 Key-Value 数据库，数据存放在内存中，查询和写入都是在内存中进行操作。MongoDB 面向文档数据库，功能强大，是非关系型数据库中最像 RDBMS 的，处理增删改查也可以增加条件。</li><li>Redis 将数据放在内存中，通过 RDB 或者 AOF 方式进行持久化。而 MongoDB 实际上是将数据存放在磁盘上的，只是通过 mmap 调用，将数据映射到内存中，可以将 mmap 理解为加速的方式。</li><li>将 MongoDB 归为数据库，而将 Redis 归为缓存。</li><li>Redis 就像一架飞机，查询以及写入性能极佳，但是存储的数据规模有限。MongoDB 就像高铁，在处理货物（数据）的功能上强于 Redis，同时能承载的数据量远高于 Redis，但是查询及写入的效率不及 Redis。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git笔记</title>
    <link href="/post/d9283bc6.html"/>
    <url>/post/d9283bc6.html</url>
    
    <content type="html"><![CDATA[<p>不再过多赘述一些git的基础，主要记录一些常用的内容。</p><span id="more"></span><h1 id="git笔记">git笔记</h1><h3 id="重命名">重命名🚲</h3><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">git mv 旧名称 新名称<br></code></pre></td></tr></table></figure><h3 id="log">log🦔</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">让每次commit的<span class="hljs-built_in">log</span>变为一行</span><br>git log --oneline<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示离当前最近的3次commit的<span class="hljs-built_in">log</span></span><br>git log -n3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示所有<span class="hljs-built_in">log</span></span><br>git log --all<br><span class="hljs-meta prompt_"># </span><span class="language-bash">以图示的形式显示<span class="hljs-built_in">log</span></span><br>git log --graph<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注：上述四种可以组合起来使用</span><br></code></pre></td></tr></table></figure><h3 id="git分析">.git分析🏜️</h3><p>我们每一次创建使用git时，都要先使用<code>git init</code> 生成一个<code>.git</code> 文件</p><p>主要分析以下文件：HEAD、config、refs、objects</p><ul><li>HEAD</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> HEAD</span><br>ref: refs/heads/master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">HEAD标识当前HEAD指针指向的位置</span><br></code></pre></td></tr></table></figure><ul><li><p>config</p><p><code>config</code> 文件中保存一些配置信息</p></li><li><p>refs</p><p>refs中有两个文件：heads和tags</p><ul><li><p>heads存放当前所有的分支（开发空间）</p></li><li><p>tags存放当前所有的里程碑（开发节点）</p></li></ul></li><li><p>objects</p><p>比如下面场景，可以发现objects里存放着对象的哈希值：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>2d/  4b/  7a/  7e/  info/  pack/<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> 2d</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>af48b0ad1bb55884b00ab716f96985bd0aa25c<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git cat-file -t 2daf48b0ad1bb55884b00ab716f96985bd0aa25c</span><br>commit<br></code></pre></td></tr></table></figure><ul><li>git查看对象类型和内容：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git cat-file -t(看类型) 哈希值 <br>git cat-file -p(看内容) 哈希值<br></code></pre></td></tr></table></figure><h3 id="git文件组织模式">git文件组织模式🤹🏻</h3><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220526002402886.png" style="zoom:50%;" /></p><p>一个commit只对应一棵树，文件夹是一棵树，blob是文件，blob只看内容不看文件名，只要文件内容相同就是一个blob。</p><h3 id="commit操作">commit操作⚜️</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改commit的message</span><br>git rebase -i 哈希值 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改对应的pick为r</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并commit指令</span><br>git rebase -i 哈希值 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改对应的pick为s</span><br></code></pre></td></tr></table></figure><h3 id="差异比较">差异比较🪂</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">比较HEAD和暂存区差异:</span><br>git diff --cached<br><span class="hljs-meta prompt_"># </span><span class="language-bash">比较工作区和暂存区差异:</span><br>git diff<br>git diff -- 文件名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果HEAD和暂存区都变了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">变更暂存区内容，使其和HEAD一致:</span><br>git reset HEAD <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>git reset HEAD -- 文件名1 文件名2 ...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果工作区和暂存区都变了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">变更工作区内容，使其和暂存区一致:</span> <br>git checkout -- 文件名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">变更暂存区内容，使其和工作区一致:</span><br>git reset HEAD <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>git reset HEAD -- 文件名1 文件名2 ...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">消除最近几次commit</span><br>git reset --hard 哈希值<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看指定文件间差异</span><br>git diff branch1 branch2 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>git diff branch1 branch2 -- 文件名<br></code></pre></td></tr></table></figure><h3 id="保存当前状态">保存当前状态🤴🏻</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 保存当前状态，并且恢复到上一次commit的时候</span><br>git stash<br><span class="hljs-meta"># 查看当前stash</span><br>git stash list<br><span class="hljs-meta"># 恢复，但不弹出(git stash list不会删除)</span><br>git stash apply<br><span class="hljs-meta"># 恢复，但弹出(git stash list会删除)</span><br>git stash <span class="hljs-keyword">pop</span><br></code></pre></td></tr></table></figure><h3 id="gitignore用法">.gitignore用法🦹🏻</h3><p>在.gitignore中写入相应格式，则git不会将其进行管理，举个例子：Java的.gitignore文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Compiled class file</span><br>*.class<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Log file</span><br>*.log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">BlueJ files</span><br>*.ctxt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Mobile Tools <span class="hljs-keyword">for</span> Java (J2ME)</span><br>.mtj.tmp/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Package Files <span class="hljs-comment">#</span></span><br>*.jar<br>*.war<br>*.nar<br>*.ear<br>*.zip<br>*.tar.gz<br>*.rar<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br>hs_err_pid*<br>replay_pid*<br></code></pre></td></tr></table></figure><h3 id="开发流程">开发流程👑</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在github建立仓库</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">与远端建立连接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里的origin可以随意起名</span><br>git remote add origin xxx/xxx.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地进行代码编写</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从本地进行push</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 如果push所有分支</span><br>git push origin --all<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 如果push一个分支（以master分支为例）</span><br>git push origin master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要是报错</span><br> ! [rejected]        master -&gt; master (fetch first)<br>error: failed to push some refs to &#x27;github.com:xxx/xxx.git&#x27;<br>hint: Updates were rejected because the remote contains work that you do<br>hint: not have locally. This is usually caused by another repository pushing<br>hint: to the same ref. You may want to first integrate the remote changes<br>hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.<br>hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">说明远端本身就有内容（可能是创建仓库时候创建了README、gitignore、license之类的）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时需要先pull或者先fetch+merge</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. pull</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. fetch+merge</span><br>git fetch origin<br>git merge --allow-unrelated-histories origin/master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时再进行push即可</span><br>git push origin --all(master)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要是多人协作开发，一人一个分支</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">远端已经建立了多个分支，比如我要做的分支名为 mybranch</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">clone</span>远端仓库</span><br>git clone xxx/xxx.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前所有分支(显示本地和远端)</span><br>git branch -av<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建并切换到一个自己的分支</span><br>git checkout -b xxx/xxx(自己本地分支名) origin/mybranch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地进行代码编写</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提交代码即可</span><br>git add -u<br>git commit -m&quot;xxx&quot;<br>git push<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">不同人修改不同文件</span><br>git pull<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地进行代码编写</span><br>git push<br><span class="hljs-meta prompt_"># </span><span class="language-bash">报错</span><br>git fetch origin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">和当前远端的mybranch进行合并</span><br>git merge origin/mybrach<br>git push<br><span class="hljs-meta prompt_"># </span><span class="language-bash">成功push</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不同人修改相同文件不同区域</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同上</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git merge 可以自动进行合并</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不同人修改相同文件相同区域</span><br>git pull<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地进行代码编写</span><br>git push<br><span class="hljs-meta prompt_"># </span><span class="language-bash">报错</span><br>git pull<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开有问题的文件，git用&gt;&gt;&gt;&gt;HEAD之类的符号标识出了冲突的地方，进行修改即可</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提交代码即可</span><br>git add -u<br>git commit -m&quot;xxx&quot;<br>git push<br></code></pre></td></tr></table></figure><p>如果和远端发生了冲突（本地编写代码后git push 报错），可以先进行git pull ，如果git 可以帮助你来修复，打开相应文件，git会标识出冲突的地方；如果git 不能帮助你修复，则可以git status，可以看到当前状态，你可以和其他人协商，然后一个一个文件进行 git add 或 git rm即可。</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL必知必会笔记（二）</title>
    <link href="/post/1171445a.html"/>
    <url>/post/1171445a.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对<a href="https://time.geekbang.org/column/intro/100029501">SQL必知必会</a>的内容进行总结</p><span id="more"></span><h1 id="sql必知必会笔记二">SQL必知必会笔记（二）</h1><h3 id="索引">索引🎳</h3><ul><li><p>索引的价值是帮我们从海量数据中找到想要的数据，如果数据量少，那么是否使用索引对结果的影响并不大。另外，当数据重复度大，比如高于 10% 的时候，也不需要对这个字段使用索引。</p></li><li><p>从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引和全文索引。</p><p>普通索引是基础的索引，没有任何约束，主要用于提高查询效率。</p><p>唯一索引就是在普通索引的基础上增加了数据唯一性的约束，在一张数据表里可以有多个唯一索引。</p><p>主键索引在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL+UNIQUE，一张表里最多只有一个主键索引。</p><p>全文索引用的不多，MySQL 自带的全文索引只支持英文。我们通常可以采用专门的全文搜索引擎，比如ES(ElasticSearch) 和 Solr。</p></li><li><p>按照物理实现方式，索引可以分为 2 种：聚集索引和非聚集索引。我们也把非聚集索引称为二级索引或者辅助索引。</p><p>聚集索引可以按照主键来排序存储数据，这样在查找行的时候非常有效。聚集索引指表中数据行按索引的排序方式进行存储，对查找行很有效。只有当表包含聚集索引时，表内的数据行才会按找索引列的值在磁盘上进行物理排序和存储。每一个表只能有一个聚集索引，因为数据行本身只能按一个顺序存储。</p><p>在数据库系统会有单独的存储空间存放非聚集索引，这些索引项是按照顺序存储的，但索引项指向的内容是随机存储的。也就是说系统会进行两次查找，第一次先找到索引，第二次找到索引对应的位置取出数据行。非聚集索引不会把索引指向的内容像聚集索引一样直接放到索引的后面，而是维护单独的索引表（只维护索引，不维护索引指向的数据），为数据检索提供方便。</p><ol type="1"><li>聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储顺序。</li><li>一个表只能有一个聚集索引，因为只能有一种排序存储的方式，但可以有多个非聚集索引，也就是多个索引目录提供数据检索。</li><li>使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。</li></ol></li><li><p>按照字段个数进行划分，索引可以分成单一索引和联合索引。</p><p>索引列为一列时为单一索引；多个列组合在一起创建的索引叫做联合索引。</p><p>联合索引存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。即如果设置索引为(x,y,z)，而我的查询条件是y（不与 (x,y,z) 最左匹配），此时联合查询就会失效。</p><p>查询“z=7 AND y=8 AND x=9”的时候，如果三个字段 x、y、z 在条件查询的时候是乱序的，但采用的是等值查询（=）或者是 IN 查询，那么 MySQL 的优化器可以自动帮我们调整为可以使用联合索引的形式。</p><p>当我们查询“x=9 AND y&gt;8 AND z=7”的时候，如果建立了 (x,y,z) 顺序的索引，这时候 z 是用不上索引的。这是因为 MySQL 在匹配联合索引最左前缀的时候，如果遇到了范围查询，比如（&lt;）（&gt;）和 between 等，就会停止匹配。索引列最多作用于一个范围列，对于后面的 Z 来说，就没法使用到索引了。</p></li><li><p>Hash索引 VS B+索引：</p><ol type="1"><li>Hash 索引不能进行范围查询，而 B+ 树可以。这是因为 Hash 索引指向的数据是无序的，而 B+ 树的叶子节点是个有序的链表。</li><li>Hash 索引不支持联合索引的最左侧原则（即联合索引的部分索引无法使用），而 B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</li><li>Hash 索引不支持 ORDER BY 排序，因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用，而 B+ 树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，我们也无法用 Hash 索引进行模糊查询，而 B+ 树使用 LIKE 进行模糊查询的时候，LIKE 后面前模糊查询（比如 % 开头）的话就可以起到优化作用。</li></ol><p>对于等值查询来说，通常 Hash 索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到 Hash 冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。</p><p>B+ 树索引的使用面会更广，不过也有一些场景采用 Hash 索引效率更高，比如在键值型（Key-Value）数据库中，Redis 存储的核心就是 Hash 表。MySQL 中的 Memory 存储引擎支持 Hash 存储，如果我们需要用到查询的临时表时，就可以选择 Memory 存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，采用 Hash 索引是个不错的选择。 MySQL 的 InnoDB 存储引擎还有个“自适应 Hash 索引”的功能，就是当某个索引值使用非常频繁的时候，它会在 B+ 树索引的基础上再创建一个 Hash 索引，这样让 B+ 树也具备了 Hash 索引的优点。</p></li><li><p>适合创建索引的情况：</p><ul><li>字段的数值有唯一性的限制，比如用户名</li><li>频繁作为 WHERE 查询条件的字段，尤其在数据表大的情况下</li><li>需要经常 GROUP BY 和 ORDER BY 的列，如果同时有，建立联合索引。</li><li>UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引（更新列与WHERE条件列不是一列）</li><li>DISTINCT 字段需要创建索引</li><li>做多表 JOIN 连接操作时，创建索引需要注意以下的原则<ul><li>连接表的数量尽量不要超过 3 张</li><li>对 WHERE 条件创建索引</li><li>对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致</li></ul></li></ul></li><li><p>不能创建索引的情况：</p><ul><li>WHERE 条件（包括 GROUP BY、ORDER BY）里用不到的字段不需要创建索引</li><li>如果表记录太少，比如少于 1000 个，那么是不需要创建索引的</li><li>字段中如果有大量重复数据，也不用创建索引</li><li>频繁更新的字段不一定要创建索引</li></ul></li><li><p>索引失效：</p><ul><li>索引进行了表达式计算，则会失效</li><li>对索引使用函数，也会造成失效</li><li>在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。</li><li>当我们使用 LIKE 进行模糊查询的时候，后面不能是 %</li><li>索引列与 NULL 或者 NOT NULL 进行判断的时候也会失效</li><li>在使用联合索引的时候要注意最左原则</li></ul></li><li><p>索引片是 SQL 查询语句在执行中需要扫描的一个索引片段，根据包含的匹配列的数量不同，将索引分成窄索引（比如包含索引列数为 1 或 2）和宽索引（包含的索引列数大于 2）。需要说明的是，每个非聚集索引保存的数据都会存储主键值，然后通过主键值，来回表查找相应的数据，因此每个索引都相当于包括了主键。【所以如果是非聚集索引窄索引和宽索引在计算时需要+1】</p></li><li><p>回表指的就是数据库根据索引找到了数据行之后，还需要通过主键再次到数据表中读取数据的情况。</p></li><li><p>宽索引可以避免回表的情况发生，通过宽索引将 SELECT 中需要用到的列（主键列可以除外）都设置在宽索引中，这样就避免了回表扫描的情况，从而提升 SQL 查询效率。</p></li><li><p>过滤因子：在 WHERE 条件语句中，每个条件都称为一个谓词，谓词的选择性也等于满足这个条件列的记录数除以总记录数的比例。联合过滤因子有更高的过滤能力，这里还需要注意一个条件，那就是条件列的关联性应该尽量相互独立，否则如果列与列之间具有相关性，联合过滤因子的能力就会下降很多。</p></li><li><p>过滤因子决定了索引片的大小（注意这里不是窄索引和宽索引），过滤因子的条件过滤能力越强，满足条件的记录数就越少，SQL 查询需要扫描的索引片也就越小。</p></li><li><p>使得SQL查询效率最大化的设计（三星索引）：</p><ol type="1"><li>在 WHERE 条件语句中，找到所有等值谓词中的条件列，将它们作为索引片中的开始列；（最小化碎片，过滤因子降低）</li><li>将 GROUP BY 和 ORDER BY 中的列加入到索引中；（避免排序，索引自带排序）</li><li>将 SELECT 字段中剩余的列加入到索引片中。（避免回表）</li></ol></li><li><p>三星索引的弊端：</p><ul><li>采用三星索引会让索引片变宽，这样每个页能够存储的索引数据就会变少，从而增加了页加载的数量。</li><li>增加了索引维护的成本。</li></ul></li><li><p>自适应 Hash 索引（系统会根据情况自动完成）</p><p>如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到 Hash 表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。</p><p>自适应 Hash 索引只保存热数据（经常被使用到的数据），并非全表数据。因此数据量并不会很大，因此自适应 Hash 也是存放到缓冲池中，这样也进一步提升了查找效率。</p><p>InnoDB 中的自适应 Hash 相当于“索引的索引”，采用 Hash 索引存储的是 B+ 树索引中的页面的地址。采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p></li></ul><h3 id="数据库存储结构">数据库存储结构🎑</h3><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527162015622.png" /></p><ul><li><p>一个页中可以存储多个行记录，数据库管理存储空间的基本单位是页。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527162603016.png" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527165533715.png" /></p><ul><li>在文件头中有两个字段，分别是 FIL_PAGE_PREV 和 FIL_PAGE_NEXT，它们的作用相当于指针，分别指向上一个数据页和下一个数据页。<strong>连接起来的页相当于一个双向的链表</strong>，需要说明的是采用链表的结构让数据页之间不需要是物理上的连续，而是逻辑上的连续。</li><li>文件尾的校验方式就是采用 Hash 算法进行校验。</li><li>当有新的记录插入时，会从空闲空间中进行分配用于存储新记录</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527170207669.png" /></p><ul><li><p>页目录起到了记录的索引作用，在页中，<strong>记录是以单向链表的形式进行存储的</strong>。在页目录中提供了二分查找的方式，用来提高记录的检索效率。</p><ol type="1"><li>将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li><li>第 1 组，也就是最小记录所在的分组只有 1 个记录；最后一组，就是最大记录所在的分组，会有 1-8 条记录；其余的组记录数量在 4-8 条之间。这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会尽量平分。</li><li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li></ol><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527180809501.png" /></p><p>页目录存储的是槽，槽相当于分组记录的索引。我们通过槽查找记录，实际上就是在做二分查找。通过对槽从最小到最大记录进行编号，划定二分法的查询范围，并按照（low+high）/2的槽中提取数据与需查询数据比对，判定下一步的最低最高值，如果＞目前槽中数据，则下一步low为当前槽的序号，high为最大记录的槽序号，如果&lt;目前槽中数据，则反之。从而逐步逼近，最终定位到需查询数据对应槽。</p></li></ul></li><li><p>区（Extent）是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB=1MB。</p></li><li><p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64 个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p></li><li><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p></li><li><p>在一棵 B+ 树中，每个节点都是一个页，每次新建节点的时候，就会申请一个页空间。同一层上的节点之间，通过页的结构构成一个双向的链表（页文件头中的两个指针字段）。非叶子节点，包括了多个索引行，每个索引行里存储索引键和指向下一层页面的页面指针。最后是叶子节点，它存储了关键字和行记录，在节点内部（也就是页结构的内部）记录之间是一个单向的链表，但是对记录进行查找，则可以通过页目录采用二分查找的方式来进行。</p></li></ul><h3 id="缓冲池">缓冲池🌸</h3><p>磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池，这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I/O 的时间。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p>当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做 checkpoint 的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p><p>如果缓冲池中没有该页数据，读取数据方式：</p><ul><li><p>内存读取</p><p>如果该数据存在于内存中，直接读取即可。【1ms】</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527192120706.png" /></p></li><li><p>随机读取</p><p>如果数据没有在内存中，就需要在磁盘上对该页进行查找。【10ms】</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527192220693.png" /></p></li><li><p>顺序读取</p><p>批量读取，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘 I/O 操作了。</p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528151618933.png" /></p><p>缓冲池的作用就是提升 I/O 效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘 I/O 操作。</p><p>查看SQL语句查询成本：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进行查询</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SELECT name FROM student <span class="hljs-built_in">where</span> <span class="hljs-built_in">id</span>=1;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看SQL语句查询成本</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SHOW STATUS LIKE <span class="hljs-string">&#x27;last_query_cost&#x27;</span>;</span><br></code></pre></td></tr></table></figure><h3 id="锁">锁🐸</h3><ul><li><p>按照锁粒度划分：</p><ul><li>行锁</li><li>页锁</li><li>表锁</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528094225897.png" /></p></li><li><p>从数据库管理的角度对锁进行划分</p><ul><li>共享锁 加锁： <code>LOCK TABLE product_comment READ;</code> 解锁： <code>UNLOCK TABLE;</code> 给某一行加锁： <code>SELECT * FROM product_comment WHERE user_id = 912178 LOCK IN SHARE MODE</code></li><li>排它锁 加锁： <code>LOCK TABLE product_comment WRITE;</code> 解锁： <code>UNLOCK TABLE;</code> 给某一行加锁： <code>SELECT * FROM product_comment WHERE user_id = 912178 FOR UPDATE;</code></li><li>意向锁，简单来说就是给更大一级别的空间示意里面是否已经上过锁。如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。同理，事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录，不能对整个表进行全表扫描。</li><li>当有多个事务对同一数据获得读锁的时候，可能会出现死锁的情况。</li><li>避免死锁的方法：<ol type="1"><li>如果事务涉及多个表，操作比较复杂，那么可以尽量一次锁定所有的资源，而不是逐步来获取，这样可以减少死锁发生的概率；</li><li>如果事务需要更新数据表中的大部分数据，数据表又比较大，这时可以采用锁升级的方式，比如将行级锁升级为表级锁，从而减少死锁产生的概率；</li><li>不同事务并发读写多张数据表，可以约定访问表的顺序，采用相同的顺序降低死锁发生的概率。</li></ol></li></ul></li><li><p>从程序员的角度进行划分</p><ul><li><p>乐观锁</p><p>乐观锁（Optimistic Locking）认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者时间戳机制实现。</p><ul><li><p>版本号机制</p><p>在表中设计一个版本字段 version，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p></li><li><p>时间戳机制</p><p>在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p></li></ul></li><li><p>悲观锁</p><p>悲观锁（Pessimistic Locking）也是一种思想，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528100720437.png" /></p></li><li><p>乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p></li><li><p>悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读 - 写和写 - 写的冲突。</p></li><li><p>乐观锁和悲观锁并不是锁，而是锁的设计思想。</p></li></ul></li></ul><h3 id="mvcc">MVCC🏗️</h3><ul><li><p>MVCC 是通过数据行的多个版本管理来实现数据库的并发控制，简单来说它的思想就是保存数据的历史版本。这样我们就可以通过比较版本号决定数据是否显示出来，读取数据的时候不需要加锁也可以保证事务的隔离效果。</p><p>MVCC用在已提交读和可重复读的隔离级别下。</p><p>通过 MVCC 可以解决以下几个问题：</p><ol type="1"><li>读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li><li>降低了死锁的概率。这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li><li>解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li></ol><p>快照读：快照读读取的是快照数据。不加锁的简单的 SELECT 都属于快照读。</p><p>当前读：当前读读取最新数据，而不是历史版本的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><p>InnoDB中MVCC的实现：</p><ul><li><p>事务版本号：每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。</p></li><li><p>InnoDB 的叶子段存储了数据页，数据页中保存了行记录，而在行记录中有一些重要的隐藏字段，如下图所示：</p><ol type="1"><li>db_row_id：隐藏的行 ID，用来生成默认聚集索引。如果我们创建数据表的时候没有指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率。</li><li>db_trx_id：操作这个数据的事务 ID，也就是最后一个对该数据进行插入或更新的事务 ID。</li><li>db_roll_ptr：回滚指针，也就是指向这个记录的 Undo Log 信息。</li></ol><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528110000422.png" /></p></li><li><p>Undo Log ：InnoDB 将行记录快照保存在了 Undo Log 里，我们可以在回滚段中找到它们</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528110224364.png" /></p><p>回滚指针将数据行的所有快照记录都通过链表的结构串联了起来，每个快照的记录都保存了当时的 db_trx_id，也是那个时间点操作这个数据的事务 ID。这样如果我们想要找历史快照，就可以通过遍历回滚指针的方式进行查找。</p></li><li><p>Read View：在 MVCC 机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在 Undo Log 里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到 Read View 了，它帮我们解决了行的可见性问题。Read View 保存了当前事务开启时所有活跃（还没有提交）的事务列表，换个角度你可以理解为 Read View 保存了不应该让这个事务看到的其他的事务 ID 列表。</p><p>Read View 中的几个重要属性：</p><ol type="1"><li>trx_ids，系统当前正在活跃的事务 ID 集合。</li><li>low_limit_id，活跃的事务中最大的事务 ID。</li><li>up_limit_id，活跃的事务中最小的事务 ID。</li><li>creator_trx_id，创建这个 Read View 的事务 ID。</li></ol><p>假设当前有事务 creator_trx_id 想要读取某个行记录，这个行记录的事务 ID 为 trx_id，那么会出现以下几种情况。</p><p>如果 trx_id &lt; 活跃的最小事务 ID（up_limit_id），也就是说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是可见的。</p><p>如果 trx_id &gt; 活跃的最大事务 ID（low_limit_id），这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见。</p><p>如果 up_limit_id &lt; trx_id &lt; low_limit_id，说明该行记录所在的事务 trx_id 在目前 creator_trx_id 这个事务创建的时候，可能还处于活跃的状态，因此我们需要在 trx_ids 集合中进行遍历，如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见。否则，如果 trx_id 不存在于 trx_ids 集合中，证明事务 trx_id 已经提交了，该行记录可见。</p></li><li><p>当查询一条记录的时候，系统如何通过多版本并发控制技术找到它：</p><ol type="1"><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>获取 Read View；</li><li>查询得到的数据，然后与 Read View 中的事务版本号进行比较；</li><li>如果不符合 Read View 规则，就需要从 Undo Log 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ol></li><li><p>MVCC 是通过 Undo Log + Read View 进行数据读取，Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见。</p></li><li><p>在隔离级别为读已提交（Read Commit）时，一个事务中的每一次 SELECT 查询都会获取一次 Read View。这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p></li><li><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View。</p><p>但是如果在两个快照读之间存在一个当前读，可能也会出现幻读的情况。</p></li></ul><p>InnoDB 解决幻读方法：</p><ul><li><p>在可重复读的情况下，InnoDB 可以通过 Next-Key 锁 +MVCC 来解决幻读问题。</p></li><li><p>快照读用MVCC，当前读用Next-Key。</p></li><li><p>InnoDB 三种行锁的方式：</p><ol type="1"><li>记录锁：针对单个行记录添加锁。</li><li>间隙锁（Gap Locking）：可以帮我们锁住一个范围（索引之间的空隙），但不包括记录本身。采用间隙锁的方式可以防止幻读情况的产生。</li><li>Next-Key 锁：帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁 + 记录锁，可以解决幻读的问题。</li></ol></li><li><p>在读已提交的情况下，InnoDB 只采用记录锁，不能解决幻读问题。</p></li><li><p>对比：</p><p>读已提交：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528113304621.png" /></p><p>出现幻读：事务A会读到新插入的数据，是因为这里使用了记录锁，只锁住了单条记录</p><p>可重复读：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528113413860.png" /></p><p>这是因为采用了 Next-Key 锁，会将 height&gt;2.08 的范围都进行锁定，就无法插入符合这个范围的数据了。然后事务 A 重新进行条件范围的查询，就不会出现幻读的情况。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL必知必会笔记（一）</title>
    <link href="/post/2167a882.html"/>
    <url>/post/2167a882.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对<a href="https://time.geekbang.org/column/intro/100029501">SQL必知必会</a>的内容进行总结</p><span id="more"></span><h1 id="sql必知必会笔记一">SQL必知必会笔记（一）</h1><h3 id="sql语言分类">SQL语言分类🥡</h3><ol type="1"><li>DDL，英文叫做 Data Definition Language，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。</li><li>DML，英文叫做 Data Manipulation Language，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。</li><li>DCL，英文叫做 Data Control Language，数据控制语言，我们用它来定义访问权限和安全级别。</li><li>DQL，英文叫做 Data Query Language，数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道，因此学会编写正确且高效的查询语句，是学习的重点。</li></ol><h3 id="大小写问题">大小写问题🌵</h3><ol type="1"><li>表名、表别名、字段名、字段别名等都小写；</li><li>SQL 保留字、函数名、绑定变量等都大写。</li></ol><p>Oracle执行SQL语句过程</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231433971.png" /></p><p>共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？</p><p>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。</p><p>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。</p><p>要避免硬解析，尽量使用软解析。在 Oracle 中，绑定变量是它的一大特色。绑定变量就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，并且使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，因此是否需要绑定变量还需要视情况而定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql">select * from player where player_id = 10001;<br>=&gt;<br>select * from player where player_id := player_id;<br></code></pre></td></tr></table></figure><h3 id="mysql执行sql语句过程">MYSQL执行SQL语句过程🏵️</h3><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231438888.png" style="zoom:80%;" /></p><p>SQL层结构：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231449401.png"  style="zoom:67%;" /></p><p>因为查询缓存往往效率不高，所以在 MySQL 8.0 之后就抛弃了缓存查询。</p><p>MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎。</p><p><strong>不同的 DBMS 的 SQL 的执行原理是相通的</strong>，只是在不同的软件中，各有各的实现路径。</p><h3 id="设计数据表原则">设计数据表原则🥒</h3><p>三少一多</p><ol type="1"><li>数据表的个数越少越好</li><li>数据表中的字段个数越少越好</li><li>数据表中联合主键的字段个数越少越好</li><li>使用主键和外键越多越好</li></ol><h3 id="常见约束">常见约束🥶</h3><p>主键约束、外键约束、唯一性约束、非空约束、CHECK约束、DEFAULT约束</p><h3 id="select语句">SELECT语句🥐</h3><ul><li>DISTINCT 需要放到所有列名的前面、DISTINCT 其实是对后面所有列名的组合进行去重</li><li><code>SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...</code></li><li>执行顺序：<code>FROM(包括join) &gt; WHERE &gt; GROUP BY &gt; HAVING &gt; SELECT 的字段 &gt; DISTINCT &gt; ORDER BY &gt; LIMIT</code></li><li>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</li><li>在 MySQL InnoDB 存储引擎中，<code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>。如果有 WHERE 子句，则是对所有符合筛选条件的数据行进行统计；如果没有 WHERE 子句，则是对数据表的数据行数进行统计。</li><li><code>COUNT(*) = COUNT(1) &gt; COUNT(字段)</code></li><li>如果要统计<code>COUNT(*)</code>，尽量在数据表上建立二级索引，系统会自动采用<code>key_len</code>小的二级索引进行扫描，这样当我们使用<code>SELECT COUNT(*)</code>的时候效率就会提升，有时候可以提升几倍甚至更高。</li><li>函数：</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231610483.png" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231610988.png" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231610043.png" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231610814.png" style="zoom:67%;" /></p><ul><li><p>日期格式：<code>"yy-mm-dd hh-mm-ss"</code> 举例：<code>"2022-05-23 16:08:45"</code></p></li><li><p><code>SELECT EXTRACT(YEAR FROM '2022-05-23')</code>，运行结果为 <code>2022</code></p></li><li><p><code>SELECT CAST(123.123 AS DECIMAL(8,2))</code>，运行结果为 <code>123.12</code> ，<code>DECIMAL(8,2)</code>代表的是精度为 8 位（整数加小数位数最多为 8 位），小数位数为 2 位的数据类型</p></li><li><p><code>SELECT COALESCE(null,1,2)</code>，运行结果为 <code>1</code></p></li><li><p><code>WHERE DATE(birthdate)&gt;'2022-05-23'</code> 这样才是正确的，不能直接比较时间</p></li><li><p>MAX 和 MIN 函数也可以用于字符串类型数据的统计，如果是英文字母，则按照 A—Z 的顺序排列，越往后，数值越大。如果是汉字则按照全拼拼音进行排列：<code>SELECT MIN(CONVERT(name USING gbk)),MAX(CONVERT(name USING gbk)) FROM heros</code></p></li><li><p>去掉重复操作再使用聚集函数：<code>SELECT ROUND(AVG(DISTINCT hp_max), 2) FROM heros</code></p></li><li><p>当查询字段进行了索引时，主表 A 大于从表 B，使用 IN 子查询效率更高；相反主表 A 小于从表 B 时，使用 EXISTS 子查询效率更高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM A WHERE cc IN (SELECT cc FROM B)<br><br>SELECT * FROM A WHERE EXIST (SELECT cc FROM B WHERE B.cc=A.cc)<br></code></pre></td></tr></table></figure><p>如果表A大于表B，IN可以使用表B的索引；如果表B大于表A，EXIST可以使用表A的索引</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT player_id, a.team_id FROM player as a, team as b WHERE a.team_id = b.team_id<br><br># 等价于<br><br>SELECT player_id, a.team_id FROM player as a NATURAL JOIN team <br><br># 等价于<br><br>SELECT player_id,a.team_id FROM player as a JOIN team ON a.team_id = team.team_id<br><br># 等价于<br><br>SELECT player_id, a.team_id FROM player as a JOIN team USING(team_id)<br></code></pre></td></tr></table></figure><ul><li>笛卡尔积： <code>CROSS JOIN</code></li></ul><h3 id="存储过程">存储过程👋🏻</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE `add_num`(IN n INT)<br>BEGIN<br>       DECLARE i INT;<br>       DECLARE sum INT;<br>       <br>       SET i = 1;<br>       SET sum = 0;<br>       WHILE i &lt;= n DO<br>              SET sum = sum + i;<br>              SET i = i +1;<br>       END WHILE;<br>       SELECT sum;<br>END //<br>DELIMITER ;<br></code></pre></td></tr></table></figure><p>上述是一个存储过程，我执行 <code>CALL add_num(100)</code> ，便可以得到5050的答案</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220525091804568.png" style="zoom:67%;" /></p><p>流控制语句：</p><ul><li><p>BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。</p></li><li><p>DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。</p></li><li><p>SET：赋值语句，用于对变量进行赋值。</p></li><li><p>SELECT…INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</p></li><li><p>IF…THEN…ENDIF：条件判断语句，我们还可以在 IF…THEN…ENDIF 中使用 ELSE 和 ELSEIF 来进行条件判断。</p></li><li><p>CASE：CASE 语句用于多条件的分支判断，使用的语法是下面这样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CASE <br>WHEN expression1 THEN ...<br>WHEN expression2 THEN ...<br>...<br>    ELSE <br>    --ELSE 语句可以加，也可以不加。加的话代表的所有条件都不满足时采用的方式。<br>END<br></code></pre></td></tr></table></figure></li><li><p>LOOP、LEAVE 和 ITERATE：LOOP 是循环语句，使用 LEAVE 可以跳出循环，使用 ITERATE 则可以进入下一次循环。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 BREAK，把 ITERATE 理解为CONTINUE。</p></li><li><p>REPEAT…UNTIL…END REPEAT：这是一个循环语句，首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p></li><li><p>WHILE…DO…END WHILE：这也是循环语句，和 REPEAT 循环不同的是，这个语句需要先进行条件判断，如果满足条件就进行循环，如果不满足条件就退出循环。</p></li></ul><h3 id="事务">事务🏯</h3><p>原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</p><p>MySQL 中 completion_type 参数的作用：</p><ul><li><p>completion=0，这是默认情况。也就是说当我们执行 COMMIT 的时候会提交事务，在执行下一个事务时，还需要我们使用 START TRANSACTION 或者 BEGIN 来开启。</p></li><li><p>completion=1，这种情况下，当我们提交事务后，相当于执行了 COMMIT AND CHAIN，也就是开启一个链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;关羽&#x27;;<br>COMMIT;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>ROLLBACK;<br>SELECT * FROM test;<br><br># 结果是 关羽<br># 上述结果是因为ROLLBACK到上一次COMMIT的地方<br><br>CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;关羽&#x27;;<br>COMMIT;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>ROLLBACK;<br>SELECT * FROM test;<br><br># 结果是 关羽、张飞<br># 上述结果是因为两条‘张飞’的插入操作的事务都是自动提交，相当于两个事务，ROLLBACK并没有起作用<br><br>CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;<br>SET @@completion_type = 1;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;关羽&#x27;;<br>COMMIT;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>ROLLBACK;<br>SELECT * FROM test;<br><br># 结果是 关羽<br># 上述结果是因为设置completion_type，以下所有指令都在一个链式事务中，两条‘张飞’的插入操作是在一个事务中<br></code></pre></td></tr></table></figure></li><li><p>completion=2，这种情况下 COMMIT=COMMIT AND RELEASE，也就是当我们提交后，会自动与服务器断开连接。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;关羽&#x27;;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>INSERT INTO test SELECT &#x27;刘备&#x27;;<br>COMMIT;<br>SELECT * FROM test;<br><br># 结果是 关羽、张飞、刘备<br># 上述结果说明事务中如果有错误，如果执行COMMIT，会将事务中正确的部分进行执行<br></code></pre></td></tr></table></figure><p>事务并发存在异常</p><ul><li>脏读：读到了其他事务还没有提交的数据。</li><li>不可重复读：对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。</li><li>幻读：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读。</li></ul><p>注：</p><ul><li>不可重复读是同一条记录的内容被修改了，重点在于UPDATE或DELETE</li><li>幻读是查询某一个范围的数据行变多了或者少了，重点在于INSERT</li></ul><h3 id="游标">游标☃️</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE `calc_hp_max`()<br>BEGIN<br>       -- 创建接收游标的变量<br>       DECLARE hp INT;  <br> <br>       -- 创建总数变量 <br>       DECLARE hp_sum INT DEFAULT 0;<br>       -- 创建结束标志变量  <br>       DECLARE done INT DEFAULT false;<br>       -- 1. 定义游标     <br>       DECLARE cur_hero CURSOR FOR SELECT hp_max FROM heros;<br>       -- 指定游标循环结束时的返回值  <br>       DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true;  <br>       <br>       -- 2. 开启游标<br>       OPEN cur_hero;<br>       read_loop:LOOP<br>       -- 3. 从游标中取得数据<br>       FETCH cur_hero INTO hp;<br>       -- 判断游标的循环是否结束  <br>       IF done THEN  <br>           LEAVE read_loop;<br>       END IF; <br>       <br>       SET hp_sum = hp_sum + hp;<br>       END LOOP;<br>       -- 4. 关闭游标<br>       CLOSE cur_hero;<br>       SELECT hp_sum;<br>       -- 5. 释放游标<br>       DEALLOCATE PREPARE cur_hero;<br>END<br></code></pre></td></tr></table></figure><p>游标实际上是面向过程的思维方式，与面向集合的思维方式不同的地方在于，游标更加关注“如何执行”。我们可以通过游标更加精细、灵活地查询和管理想要的数据行。</p><h3 id="数据库调优">数据库调优🥂</h3><p>从以下维度进行分析：</p><ul><li><p>选择适合的 DBMS</p></li><li><p>优化表设计</p><ol type="1"><li>表结构要尽量遵循第三范式的原则。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新，插入和删除数据时等异常情况的发生。</li><li>如果分析查询应用比较多，尤其是需要进行多表联查的时候，可以采用反范式进行优化。反范式采用空间换时间的方式，通过增加冗余字段提高查询的效率。</li><li>表字段的数据类型选择，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用 CHAR 类型；当长度不固定时，通常采用 VARCHAR 类型。</li></ol></li><li><p>优化逻辑查询</p><ol type="1"><li>EXISTS 子查询和 IN 子查询的时候，会根据小表驱动大表的原则选择适合的子查询</li><li>在 WHERE 子句中会尽量避免对字段进行函数运算，它们会让字段的索引失效</li></ol></li><li><p>优化物理查询（索引）</p><ol type="1"><li>如果数据重复度高，就不需要创建索引。通常在重复度超过 10% 的情况下，可以不创建这个字段的索引。比如性别这个字段（取值为男和女）。</li><li>要注意索引列的位置对索引使用的影响。比如我们在 WHERE 子句中对索引字段进行了表达式的计算，会造成这个字段的索引失效。</li><li>要注意联合索引对索引使用的影响。我们在创建联合索引的时候会对多个字段创建索引，这时索引的顺序就很重要了。比如我们对字段 x, y, z 创建了索引，那么顺序是 (x,y,z) 还是 (z,y,x)，在执行的时候就会存在差别。</li><li>要注意多个索引对索引使用的影响。索引不是越多越好，因为每个索引都需要存储空间，索引多也就意味着需要更多的存储空间。此外，过多的索引也会导致优化器在进行评估的时候增加了筛选出索引的计算时间，影响评估的效率。</li></ol></li><li><p>使用 Redis 或 Memcached 作为缓存</p><p>将常用的数据直接放到内存中，就会大幅提升查询的效率</p><p>通常我们对于查询响应要求高的场景（响应时间短，吞吐量大），可以考虑内存数据库，毕竟术业有专攻。传统的 RDBMS 都是将数据存储在硬盘上，而内存数据库则存放在内存中，查询起来要快得多。不过使用不同的工具，也增加了开发人员的使用成本。</p></li><li><p>库级优化</p><p>如果读和写的业务量都很大，并且它们都在同一个数据库服务器中进行操作，那么数据库的性能就会出现瓶颈，这时为了提升系统的性能，优化用户体验，我们可以采用读写分离的方式降低主数据库的负载，比如用主数据库（master）完成写操作，用从数据库（slave）完成读操作。</p><p>当数据量级达到亿级以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。</p><p><strong>采用垂直分表的形式，就是将一张数据表分拆成多张表，采用水平分表的方式，就是将单张数据量大的表按照某个属性维度分成不同的小表。</strong></p><p>如果数据库中的数据表过多，可以采用垂直分库的方式，将关联的数据表部署在一个数据库上。如果数据表中的列过多，可以采用垂直分表的方式，将数据表分拆成多张，把经常一起使用的列放到同一张表里。</p><p>如果数据表中的数据达到了亿级以上，可以考虑水平切分，将大的数据表分拆成不同的子表，每张表保持相同的表结构。</p></li></ul><p>总结：</p><ul><li>选择比努力更重要</li><li>把 SQL 查询优化分成两个部分，逻辑查询优化和物理查询优化</li><li>通过外援来增强数据库的性能</li></ul><h3 id="反范式设计">反范式设计🌚</h3><p>越高阶的范式得到的数据表越多，数据冗余度越低。但有时候，我们在设计数据表的时候，还需要为了性能和读取效率违反范式化的原则。反范式就是相对范式化而言的，换句话说，就是允许少量的冗余，通过空间来换时间。</p><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。<strong>当冗余信息有价值或者能大幅度提高查询效率的时候，我们就可以采取反范式的优化。此外反范式优化也常用在数据仓库的设计中</strong>，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><p>数据仓库 VS 数据库：</p><ol type="1"><li>数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据；</li><li>数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据；</li><li>数据库设计需要尽量避免冗余，但为了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库期末总结</title>
    <link href="/post/48d4ae84.html"/>
    <url>/post/48d4ae84.html</url>
    
    <content type="html"><![CDATA[<h1 id="数据库系统期末总结">数据库系统期末总结</h1><p>主要针对数据库系统期末复习中的一些重点进行归纳总结</p><span id="more"></span><h3 id="数据库系统概述">数据库系统概述🐲</h3><ul><li><p>三级模式：</p><ul><li>外模式、用户模式、子模式、局部模式、（视图）</li><li>逻辑模式、概念模式、全局模式、（模式）</li><li>内模式、物理模式、存储模式</li></ul></li><li><p>两层映像：</p><ul><li>E-C ： 外 → 逻辑</li><li>C-I ： 逻辑 → 内</li></ul></li><li><p>两个独立性：</p><ul><li>逻辑数据独立性：当逻辑模式改变，不用改外模式，改 E-I 即可</li><li>物理数据独立性：当内模式改变，不用改逻辑模式，改 C-I 即可</li></ul></li><li><p>模式：对数据的抽象</p></li><li><p>模型：对模式的抽象</p></li></ul><h3 id="关系数据模型">关系数据模型🦴</h3><ul><li>主属性：包含在任意一个<strong>候选码</strong>中的属性</li><li>主码：候选码中的一个</li><li>两个关系通常是通过<strong>外码</strong>联系起来的</li><li><span class="math inline">\(\sigma\)</span> 操作的优先级： 非 &gt; <span class="math inline">\(\wedge\)</span> &gt; <span class="math inline">\(\vee\)</span></li><li><span class="math inline">\(\pi\)</span> 操作自带去重</li><li>完整性：<ul><li>实体完整性：主码不能为空</li><li>参数完整性：外码必须有对应值或空值</li><li>用户自定义完整性</li></ul></li><li><span class="math inline">\(\theta\)</span>连接<strong>不会去重</strong>、等值连接<strong>不会去重</strong>、自然连接<strong>会去重</strong></li><li>重命名：<span class="math inline">\(\rho\)</span></li><li><span class="math inline">\(R ÷ S= \pi_{R-S}(R)-\pi_{R-S}((\pi_{R-S}(R)×S)-R)\)</span></li><li>外连接是为了防止在连接（<span class="math inline">\(\theta\)</span>连接）操作后会出现元组数据的丢失的情况（空值）</li><li>关系演算：<span class="math inline">\(\{ t|P(t)\}\)</span> ，P是一个谓语</li><li>优先级： ( ) &gt; <span class="math inline">\(\theta\)</span> &gt; <span class="math inline">\(\exists\)</span> &gt; <span class="math inline">\(\forall\)</span> &gt; 非 &gt; <span class="math inline">\(\wedge\)</span> &gt; <span class="math inline">\(\vee\)</span> （这里的 <span class="math inline">\(\theta\)</span> 是指比较运算符）</li><li>关系域演算：<span class="math inline">\(\{ &lt;x_1,x_2...x_n&gt; | P(x_1,x_2...x_n) \}\)</span></li></ul><h3 id="sql">SQL🦐</h3><ul><li><p><code>insert into table_name values (a,b,c)</code></p></li><li><p><code>insert into table_name 子查询</code></p></li><li><p><code>asc</code>为升序（默认），<code>desc</code>为降序</p></li><li><p><code>update table_name set a=b where c=d</code></p></li><li><div class="code-wrapper"><pre class="mysql"><code>  select 字段列表[字段别名]   from 数据源  [where条件字句]  [group by 字句]  [having 字句]  [order by 字句]  [limit 字句]</code></pre></div></li><li><p>表达式 (not) in 子查询</p></li><li><p>子查询只能外层向内层传参数</p></li><li><p>表达式 <span class="math inline">\(\theta\ some/all\)</span> 子查询</p></li><li><p>in <span class="math inline">\(\leftrightarrow\)</span> =some、not in <span class="math inline">\(\leftrightarrow\)</span> &lt;&gt;all</p></li><li><p>子查询 union (all) / intersect (all) / except (all) ，其中带有 <strong>all 不删除重复元组</strong></p></li><li><p>任何<strong>没有出现</strong>在group by子句中的属性如果出现在select子句中的话，它<strong>只能出现在聚集函数的内部</strong>，否则这样的查询就是错误的</p></li><li><p>只有 COUNT 不忽略 null</p></li><li><p><span class="math inline">\(from\ table_{name1}\ (natural)\ inner\ join / left\ outer\ join / right\ outer\ join / full\ outer\ join\ table_{name2}\ (on ...)\)</span></p></li><li><p><span class="math inline">\(create\ view\ view_{name}\ as\)</span> 子查询</p></li><li><p>不能更新的view：</p><ul><li>select 目标列包含聚集函数</li><li>select 子句使用distinct</li><li>包含group by</li><li>包含经算术表达式计算出的列</li><li>由单个表的列组成但未包含主键</li></ul></li></ul><h3 id="概念数据库设计">概念数据库设计🪂</h3><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205201502437.png" /></p><h3 id="逻辑数据库设计">逻辑数据库设计🚍</h3><ul><li><span class="math inline">\(armstrong公理\)</span>：<ul><li><span class="math inline">\(Y\subseteq X \subseteq U,则X → Y\)</span></li><li><span class="math inline">\(X \rightarrow Y \in F.Z \subseteq U,则XZ \rightarrow YZ\)</span></li><li><span class="math inline">\(X \rightarrow Y,Y \rightarrow Z,则X \rightarrow Z\)</span></li><li><span class="math inline">\(X \rightarrow Y,X\rightarrow Z,则X\rightarrow YZ\)</span></li><li><span class="math inline">\(X\rightarrow Y,WY\rightarrow Z,则XW\rightarrow Z\)</span></li><li>$XY,Z Y,则XZ $</li></ul></li><li>最小覆盖（最小依赖集）计算：<ul><li>将F中的任意函数依赖 <span class="math inline">\(X → Y\)</span>替换为右部仅包含一个属性的函数依赖</li><li>删除左部的冗余属性</li><li>删除冗余函数依赖</li></ul></li><li>NF总结<ul><li>1NF 保证分量不可分</li><li>2NF 保证只有主键才能推出其他，消除非主属性对<strong>候选键</strong>的部分函数依赖</li><li>3NF 消除非主属性对<strong>候选键</strong>的传递函数依赖</li><li>BCNF 保证主属性完全函数依赖于<strong>候选键</strong>、或者满足1NF并且最小覆盖的左部都是<strong>候选键</strong></li></ul></li><li>识别无损连接分解：画表格</li><li>识别函数依赖保持：函数依赖的并集是否可以覆盖F</li><li>关系模式分解为 3NF：将每一个函数依赖单独组成一个关系，然后把左部相同的进行合并【保持依赖】</li><li>关系模式分解为 BCNF：将左侧不含候选键的函数依赖单独组成一个关系，将包含候选键的组成一关系【无损连接】</li></ul><h3 id="物理数据库设计">物理数据库设计🥡</h3><ul><li>索引文件组织方式：<ul><li>排序索引文件</li><li>散列索引文件</li></ul></li><li><span class="math inline">\(create\ index\ index_{name}\ on\ table_{name}(a,b,c)\)</span></li><li>稠密索引 VS 稀疏索引<ul><li>稠密索引：索引文件中包含了主文件对应字段的所有不同值</li><li>稀疏索引：索引文件中包含了主文件对应字段的部分不同值</li></ul></li><li>主索引 VS 辅助索引<ul><li>主索引通常是对每一存储块有一个索引项（稀疏索引）</li><li>辅助索引是稠密索引</li><li>一个主文件仅可以有一个主索引，但可以有多个辅助索引</li><li>主索引通常建立于主码/排序码上面；辅助索引建立于其他属性上面</li><li>主索引可以重新组织主文件数据，但辅助索引不能改变主文件数据</li></ul></li><li>聚簇索引 VS 非聚簇索引<ul><li>聚簇索引：索引中邻近的记录在主文件中也是临近存储的</li><li>非聚簇索引：索引中邻近的记录在主文件中不一定是邻近存储的</li><li>主索引是聚簇索引、辅助索引是非聚簇索引</li></ul></li></ul><h3 id="数据库存储">数据库存储🪢</h3><ul><li>CPU 到 主存之间按存储字访问，主存 到 外存之间按块/IO访问</li><li>操作系统对数据组织：FAT（文件分配表） -- 目录（文件夹） -- 磁盘块/簇</li><li>数据库中表所占磁盘块的分配方法：<ul><li>连续分配 【访问困难】</li><li>链接分配 【访问速度慢】</li><li>按簇分配 (簇是若干连续的磁盘块,簇之间靠指针连接)</li><li>索引分配(索引块中存放指向实际data块的指­针)</li></ul></li><li>（主）文件组织方法：<ul><li>无序记录文件（堆文件）：数据库重组是通过移走被删除的记录使有效记录连续存放，从而回收那些由删除记录而产生的未利用空间</li><li>有序记录文件（排序文件）：数据库重组是将溢出文件合并到主文件中，并恢复主文件中的记录顺序</li><li>散列文件</li><li>聚簇文件</li></ul></li></ul><h3 id="索引结构">索引结构🧆</h3><ul><li><p>B+树</p><ul><li>插入：分裂</li><li>分裂后增加父节点中的指针和键（右节点的第一个值）</li><li>删除：合并</li><li>合并后删除父节点中的指针和键</li></ul></li><li><p>可扩展散列：每次增加两倍</p></li><li><p>线性散列</p><ul><li><p>位是从右端（低位）开始取</p></li><li><p>n：当前的桶数、r：当前散列表中的记录总数、要求r&lt;= 1.7n</p></li><li><table><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">000</td><td style="text-align: center;">000</td><td style="text-align: center;">...</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">01</td><td style="text-align: center;">01</td><td style="text-align: center;">001</td><td style="text-align: center;">001</td><td style="text-align: center;">...</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">10</td><td style="text-align: center;">10</td><td style="text-align: center;">010</td><td style="text-align: center;">010</td><td style="text-align: center;">...</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">11</td><td style="text-align: center;">011</td><td style="text-align: center;">011</td><td style="text-align: center;">...</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">100</td><td style="text-align: center;">100</td><td style="text-align: center;">...</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">101</td><td style="text-align: center;">...</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">...</td></tr></tbody></table></li></ul></li></ul><h3 id="查询执行">查询执行👺</h3><ul><li><p>连接</p><ul><li>M ≥ 3（考虑输出）<ul><li><span class="math inline">\(B_R+B_R × B_S\)</span></li></ul></li><li>$M ≥ B_R+B_S $<ul><li><span class="math inline">\(B_R+B_S\)</span></li></ul></li><li><span class="math inline">\(M &gt; B_R，B_S≥B_R\)</span><ul><li><span class="math inline">\(B_R+B_S\)</span></li></ul></li><li><span class="math inline">\(B_S≥M，B_R≥M\)</span><ul><li><span class="math inline">\(\frac{B_RB_S}{M-2} + B_S\)</span> （考虑输出）</li></ul></li><li>排序<ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ M^2\)</span></li></ul></li><li>哈希<ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ (M-1)^2\)</span></li></ul></li><li>索引<ul><li>聚簇索引<ul><li><span class="math inline">\(B(R) + T(R)\left \lceil \frac{B(S)}{V(S,K)} \right \rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>非聚簇索引<ul><li><span class="math inline">\(B(R) + \frac{T(R)T(S)}{V(S,K)}\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li></ul></li></ul></li><li><p>去重（投影）</p><ul><li>一趟扫描<ul><li><span class="math inline">\(B(R)\)</span></li><li><span class="math inline">\(B(\delta(R))≤M\)</span></li></ul></li><li>排序<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ M^2\)</span></li></ul></li><li>哈希<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ (M-1)^2\)</span></li></ul></li></ul></li><li><p>分组</p><ul><li>一趟扫描<ul><li><span class="math inline">\(B(R)\)</span></li><li>所有分组可在内存中完整保存</li></ul></li><li>排序<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ M^2\)</span></li></ul></li><li>哈希<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ (M-1)^2\)</span></li></ul></li></ul></li><li><p>排序</p><ul><li><span class="math inline">\(3 B(R)\)</span> 【不考虑写回】、 <span class="math inline">\(4 B(R)\)</span> 【考虑写回】</li></ul></li><li><p>并、差、交</p><ul><li><p>集合上操作需要去重、包上操作不用去重</p></li><li><p>一趟扫描</p><ul><li><span class="math inline">\(B(R)+B(S)\)</span></li><li><span class="math inline">\(min(B(R),B(S)) ≤ M-1\)</span></li></ul></li><li><p>排序</p><ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ M^2\)</span></li></ul></li><li><p>哈希</p><ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ (M-1)^2\)</span></li></ul></li></ul></li><li><p>选择</p><ul><li>扫描<ul><li><span class="math inline">\(B(R)\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>哈希<ul><li><span class="math inline">\(\left \lceil \frac{B(R)}{V(R,K)} \right \rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>索引<ul><li>聚簇索引<ul><li><span class="math inline">\(\left \lceil \frac{B(R)}{V(R,K)} \right \rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>非聚簇索引<ul><li><span class="math inline">\(\left \lceil \frac{T(R)}{V(R,K)} \right \rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li></ul></li></ul></li></ul><h3 id="查询优化">查询优化🤡</h3><ul><li>逻辑查询优化：<ul><li>把形如<span class="math inline">\(\sigma_{F_1 \wedge F_2 \wedge ...\wedge F_n }(E)\)</span>的选择表达式变成串接形式<span class="math inline">\(\sigma_{F_1}(\sigma_{F_2}(...(\sigma_{F_n}(E)))\)</span></li><li>将<span class="math inline">\(\sigma\)</span> 移动到树底</li><li>将<span class="math inline">\(\pi\)</span> 移动到底部，若是对某表达式的所有属性进行的，则删去</li><li>将<span class="math inline">\(\sigma\)</span> 和<span class="math inline">\(\pi\)</span> 组合为<span class="math inline">\(\sigma\)</span> 后跟<span class="math inline">\(\pi\)</span> 或单个的形式</li></ul></li><li>物理查询优化：<ul><li>掌握 <span class="math inline">\(\pi\)</span> 、<span class="math inline">\(\sigma_{A=c}\)</span> 、<span class="math inline">\(\sigma_{A&lt;c}\)</span> 、<span class="math inline">\(and\)</span> 、<span class="math inline">\(or\)</span> 、自然连接的代价估计</li></ul></li></ul><h3 id="并发控制">并发控制📮</h3><ul><li><p>所有隔离级别均可以解决丢失修改问题</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205201127663.png"/></p><table><thead><tr class="header"><th style="text-align: center;">隔离级别</th><th style="text-align: center;">脏读</th><th style="text-align: center;">不可重复读</th><th style="text-align: center;">幻读</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">读未提交</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;">读已提交</td><td style="text-align: center;">×</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="odd"><td style="text-align: center;">可重复读</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;">可串行化</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td></tr></tbody></table></li><li><p>判断冲突可串行化调度：画图，判断有无环</p></li><li><p>X（排他）锁、S（读写）锁、U（更新）锁、I（增量）锁</p></li><li><p>两段锁协议</p><ul><li>读写数据之前要获得锁。每个事务中所有封锁请求先于任何一个解锁请求</li><li>两阶段：加锁段，解锁段。加锁段中不能有解锁操作，解锁段中不能有加锁操作</li></ul></li><li><p>如果一组事务中每个事务都在等待其他事务释放锁，则这组事务形成死锁</p></li><li><p>事务产生死锁当且仅当等待图中有环</p></li></ul><h3 id="故障恢复">故障恢复🚢</h3><ul><li><p>故障及其解决方法：</p><ul><li>事务故障：redo、undo事务</li><li>系统故障：运行日志，从检查点开始恢复<ul><li>检查点表征了:在检查点之前内存中数据与介质中数据是保持一致的</li></ul></li><li>介质故障：副本</li></ul></li><li><p>缓冲区处理策略</p><ul><li>Force:内存中的数据最晚在commit的时候写入磁盘</li><li>No force:内存中的数据可以一直保留，在commit之后过一段时间再写入磁盘。(此时在系统崩溃的时候可能还没写入到磁盘，需要redo)</li><li>No steal:不允许在事务commit之前把内存中的数据写入磁盘</li><li>Steal:允许在事务commit之前把内存中的数据写入磁盘。(此时若系统在commit之前崩溃时，已经有数据写入到磁盘了，要恢复到崩溃前的状态，需要Undo)</li><li>一般选用 Steal + No force</li></ul></li><li><p>undo日志：</p><ul><li>&lt;T,X,v&gt;中v为x的旧值</li><li>先OUTPUT再COMMIT</li></ul></li><li><p>redo日志：</p><ul><li>&lt;T,X,v&gt;中v为x的新值</li><li>先COMMIT再OUTPUT</li></ul></li><li><p>检查点</p><ul><li><p><code>&lt;begin checkpoint (T1,T2...Tn)&gt;</code></p><p><code>...</code></p><p><code>&lt;end checkpoint&gt;</code></p><p>redo 从 <code>begin checkpoint</code>开始扫描</p><p>undo 扫描到T1，T2 ... Tn 中最早的事务 Ti 的日志记录<code>&lt;Ti , begin&gt;</code>为止</p></li></ul></li><li><p>一般使用 &lt;T,X,u,v&gt;，其中旧值为u，新值为v</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个AES加密算法的工具类</title>
    <link href="/post/abbb7a99.html"/>
    <url>/post/abbb7a99.html</url>
    
    <content type="html"><![CDATA[<h1 id="一个aes加密算法的工具类android">一个AES加密算法的工具类（Android）</h1><p>我想要实现对一个字符串用AES加密算法进行加密，解密的操作，本来以为很容易，但是网上找到很多都是不能用的，下面这份代码亲测可用，于是记录之。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.util.Base64;<br><span class="hljs-keyword">import</span> android.util.Log;<br><br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AESUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> AESUtils.class.getSimpleName();<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 采用AES加密算法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES&quot;</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 字符编码(用哪个都可以，要注意new String()默认使用UTF-8编码 getBytes()默认使用ISO8859-1编码)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Charset</span> <span class="hljs-variable">CHARSET_UTF8</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加解密算法/工作模式/填充方式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CIPHER_ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES/ECB/PKCS5Padding&quot;</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789abcdef&quot;</span>; <span class="hljs-comment">//这里只要是16位字符即可</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * AES 加密</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data      待加密内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回Base64转码后的加密数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建AES秘钥</span><br>            <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">secretKeySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(secretKey.getBytes(CHARSET_UTF8), KEY_ALGORITHM);<br>            <span class="hljs-comment">// 创建密码器</span><br>            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);<br>            <span class="hljs-comment">// 初始化加密器</span><br>            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);<br>            <span class="hljs-type">byte</span>[] encryptByte = cipher.doFinal(data.getBytes(CHARSET_UTF8));<br>            <span class="hljs-comment">// 将加密以后的数据进行 Base64 编码</span><br>            <span class="hljs-keyword">return</span> base64Encode(encryptByte);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            handleException(<span class="hljs-string">&quot;encrypt&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * AES 解密</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> base64Data 加密的密文 Base64 字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decrypt</span><span class="hljs-params">(String base64Data)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] data = base64Decode(base64Data);<br>            <span class="hljs-comment">// 创建AES秘钥</span><br>            <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">secretKeySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(secretKey.getBytes(CHARSET_UTF8), KEY_ALGORITHM);<br>            <span class="hljs-comment">// 创建密码器</span><br>            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);<br>            <span class="hljs-comment">// 初始化解密器</span><br>            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);<br>            <span class="hljs-comment">// 执行解密操作</span><br>            <span class="hljs-type">byte</span>[] result = cipher.doFinal(data);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(result, CHARSET_UTF8);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            handleException(<span class="hljs-string">&quot;decrypt&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将 字节数组 转换成 Base64 编码</span><br><span class="hljs-comment">     * 用Base64.DEFAULT模式会导致加密的text下面多一行（在应用中显示是这样）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">base64Encode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>        <span class="hljs-keyword">return</span> Base64.encodeToString(data, Base64.NO_WRAP);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将 Base64 字符串 解码成 字节数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] base64Decode(String data) &#123;<br>        <span class="hljs-keyword">return</span> Base64.decode(data, Base64.NO_WRAP);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleException</span><span class="hljs-params">(String methodName, Exception e)</span> &#123;<br>        e.printStackTrace();<br>        Log.e(TAG, methodName + <span class="hljs-string">&quot;----&gt;&quot;</span> + e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AES加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理期末总结</title>
    <link href="/post/e5a09991.html"/>
    <url>/post/e5a09991.html</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理期末总结">编译原理期末总结</h1><p>主要针对编译原理期末复习中的一些重点进行归纳总结</p><span id="more"></span><h3 id="first集follow集select集计算">FIRST集、FOLLOW集、SELECT集计算🎃</h3><p>FIRST集：</p><ul><li>FIRST集中是可以有<span class="math inline">\(\xi\)</span>的</li><li>如果遇到 <span class="math inline">\(E → aF\)</span> 之类的，FIRST(E)中加入a</li><li>如果遇到 <span class="math inline">\(E → FT\)</span> 之类的，FIRST(E)中加入FIRST(F)中内容，如果 <span class="math inline">\(F → \xi\)</span> ，则 FIRST(E)中加入FIRST(T)中内容，可以一直往后顺延至某一个终结符或FIRST集中没有<span class="math inline">\(\xi\)</span> 的非终结符</li></ul><p>FOLLOW集：</p><ul><li>FOLLOW集中没有 <span class="math inline">\(\xi\)</span></li><li>先在开始符号 S 的FOLLOW中加入 <span class="math inline">\(\$\)</span></li><li>如果遇到 $ ... → FT$ 之类的，FOLLOW(F)中加入 FIRST(T)-<span class="math inline">\(\xi\)</span></li><li>如果遇到 $ ... → Fa$ 之类的，FOLLOW(F)中加入a</li><li>如果遇到 <span class="math inline">\(E → ...T\)</span> 之类的，FOLLOW(T)中加入FOLLOW(E)</li></ul><p>SELECT集：</p><ul><li>计算SELECT集时，要把所有的语句拆成不含 | 的形式</li><li>如果遇到 <span class="math inline">\(E → T\)</span>之类的，如果FIRST(T)不包含 <span class="math inline">\(\xi\)</span> ，则SELECT=FIRST(T)，如果FIRST(T)包含 <span class="math inline">\(\xi\)</span> ，则SELECT=(FIRST(T)- <span class="math inline">\(\xi\ ) \cup\)</span> FOLLOW(E)</li></ul><h3 id="ll文法和lr文法的判定条件">LL文法和LR文法的判定条件🚀</h3><ul><li>LL文法 文法G是LL(1)的，当且仅当G的任意两个具有相同左部的产生式A → α | β 满足条件：<ol type="1"><li>文法不含左递归（即不存在终结符a使得α 和β都能够推导出以a开头的串）</li><li>α和β至多有一个能推导出ε</li><li>如果 β <span class="math inline">\(\Rightarrow ^ *\)</span> ε，则FIRST(α) ∩ FOLLOW(A) =Φ；如果 α <span class="math inline">\(\Rightarrow ^ *\)</span> ε，则FIRST(β) ∩ FOLLOW(A) =Φ；</li></ol></li><li>LR文法<ul><li><p>LR(0)文法</p><p>如果文法对应的自动机中不存在<code>移进-归约冲突</code>和<code>归约-归约冲突</code>则为LR(0)文法。换句话说LR(0)文法分析不能解决这两种冲突，所以范围最小。移进-归约冲突就是在同一个项集族中同时出现了可以移进的产生式和可以归约的产生式。归约-归约冲突类似。</p></li><li><p>SLR文法</p><p>SLR文法中还是存在<code>归约-归约冲突</code>和存在<code>移进-归约冲突</code>，但是如果可以用FOLLOW集解决则是SLR文法。换句话说，SLR文法分析过程也不一定能解决这两种冲突。用FOLLOW集来处理出现了<code>归约-规约冲突</code>或<code>移进-归约冲突</code>的两条产生式，如果其FOLLOW集相交为空则为SLR文法，反之不是。</p></li><li><p>LR(1)文法</p><p>题目出现的基本都是LR(1)文法</p></li><li><p>LALR文法</p><p>LALR文法中存在<code>归约-归约冲突</code>。</p></li></ul></li></ul><h3 id="赋值语句翻译">赋值语句翻译🦊</h3><ul><li><p>if-else-then语句：</p><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown">if x&gt;1<br>then x=0<br>else x=2<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">nif x&gt;1 goto n+2<br>n+1goto n+4<br>n+2x=0<br>n+3goto n+5<br>n+4x=2<br>n+5...<br></code></pre></td></tr></table></figure></li><li><p>while语句：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">while i&gt;0<br>do i=i+1<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">nif i&gt;0 goto n+2<br>n+1goto n+5<br>n+2t=i+1<br>n+3i=t<br>n+4goto n<br>n+5...<br></code></pre></td></tr></table></figure></li><li><p>逻辑运算符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">if ( x&lt;100 || x&gt;200 &amp;&amp; x!=y )<br><span class="hljs-code">x=0;</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">nif x&lt;100 goto n+6 <br>n+1goto n+2<br>n+2if x &gt; 200 goto n+4<br>n+3goto n+7 <br>n+4if x!=y goto n+6<br>n+5goto n+7<br>n+6x=0<br>n+7...<br></code></pre></td></tr></table></figure></li></ul><h3 id="控制语句的sdt回填">控制语句的<code>SDT</code>&amp;回填⛄</h3><p>控制流语句：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1if B then S1<br>2if B then S1 else S2<br>3while B S1<br></code></pre></td></tr></table></figure><p>布尔表达式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1B1 or B2<br>2B1 and B2<br>3not B<br>4(B)<br>5E1 relop E2<br>6true<br>7false<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052245722.png" alt="控制流语句SDT" style="zoom:75%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052245278.png" alt="布尔表达式SDT" style="zoom:75%;" /></p><p>控制流SDT编写：</p><ul><li>分析每一个非终结符之前：<ul><li>先计算继承属性</li><li>再观察代码结构图中该非终结符对应的方框顶部是否有<code>导入箭头</code>。如果有，调用<code>label()</code>函数</li></ul></li><li>上一个代码框执行完<code>不顺序执行</code>下一个代码框时，生成一条<code>显式跳转</code>指令</li><li>有<code>自下而上的箭头</code>时，设置<code>begin</code>属性。且定义后<code>直接调用label( )函数</code>绑定地址</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052148748.png" alt="控制流语句回填" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052146083.png" alt="布尔表达式的回填" style="zoom:67%;" /></p><p>回填SDT编写：</p><ul><li>文法改造<ul><li>在list箭头指向的位置设置标记非终结符M</li></ul></li><li>在产生式末尾的语义动作中<ul><li>计算综合属性</li><li>调用backpatch ( )函数回填各个list</li></ul></li></ul><p>注：上述语句的<strong>代码结构图</strong>非常重要</p><h3 id="数据流分析技术">数据流分析技术🪆</h3><h4 id="到达定值分析">到达定值分析👨🏻‍🚀</h4><p>对 <span class="math inline">\(d_i\)</span>进行分析，gen是本基本块中的所有 <span class="math inline">\(d_i\)</span>，kill是不在本基本块内，但是和本基本块内 <span class="math inline">\(d_i\)</span>左部相同的<span class="math inline">\(d_j\)</span></p><p><span class="math inline">\(IN(B)=\cup OUT(B)\)</span></p><p><span class="math inline">\(OUT(B)=gen \cup (IN(B)-kill)\)</span></p><p>用途：</p><ol type="1"><li>循环不变计算检测</li><li>常量合并</li><li>判定变量x在p点上是否未经定值被引用</li></ol><h4 id="活跃变量分析">活跃变量分析👑</h4><p>对每一个基本块内的变量进行分析，use是右部中用到的符号，def是左部中符号，若use和def有交集，放在use里</p><p><span class="math inline">\(OUT(B)=\cup IN(B)\)</span></p><p><span class="math inline">\(IN(B)=use \cup (OUT(B)-def)\)</span></p><p>注意：活跃变量分析从<span class="math inline">\(B_n\)</span>开始分析</p><p>用途：</p><ol type="1"><li>删除无用赋值</li><li>为基本块分配寄存器</li></ol><h4 id="可用表达式分析">可用表达式分析🦄</h4><p>对每一个<code>z=x op y</code> 这类的表达式进行分析，先找出所有的<code>x op y</code>，记作S。</p><p>遇到 z = x op y ，e_gen先加入x op y ,然后删掉所有含有z的表达式；e_kill先删掉x op y ，然后加入所有S中含有z的表达式。</p><p><span class="math inline">\(IN(B)=\cap OUT(B)\)</span></p><p><span class="math inline">\(OUT(B)=e_{gen} \cup (IN(B)-e_{kill})\)</span></p><p>用途：</p><ol type="1"><li>消除全局公共子表达式</li><li>复制传播</li></ol><h3 id="概念总结主要针对选填">概念总结（主要针对选填）🐼</h3><h4 id="绪论">绪论😶‍🌫️</h4><ul><li>预处理 <span class="math inline">\(\rightarrow\)</span> 编译 <span class="math inline">\(\rightarrow\)</span> 汇编 <span class="math inline">\(\rightarrow\)</span> 链接 <span class="math inline">\(\rightarrow\)</span> 目标机器代码</li><li>编译：将高级语言翻译成汇编语言或机器语言的过程</li><li>词法分析中 token ：&lt;种别码，属性值&gt;、语法分析构造<strong>语法分析树</strong>、语义分析收集标识符的属性信息<strong>建立符号表和语义检查</strong></li></ul><h4 id="语言及其文法">语言及其文法🐻‍❄️</h4><ul><li><p>对于 <span class="math inline">\(\alpha\ \rightarrow\ \beta\)</span></p><ul><li>1型文法 -- 上下文有关文法：<span class="math inline">\(|\alpha|\ ≤\ |\beta|\)</span></li><li>2型文法 -- 上下文无关文法：<span class="math inline">\(\alpha\ \in\ V_N，A\rightarrow \beta\)</span></li><li>3型文法 -- 正则文法：<ul><li>右线性文法<span class="math inline">\(A\rightarrow wB\)</span> 或 <span class="math inline">\(A \rightarrow w\)</span><br /></li><li>右线性文法<span class="math inline">\(A\rightarrow Bw\)</span> 或 <span class="math inline">\(A \rightarrow w\)</span></li></ul></li></ul></li><li><p>短语和直接短语：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205180933517.png" /></p></li></ul><h4 id="词法分析">词法分析🐒</h4><ul><li>错误恢复（恐慌模式）：从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止</li></ul><h4 id="语法分析">语法分析👻</h4><ul><li>最右推导（规范推导）<span class="math inline">\(\Leftrightarrow\)</span> 最左规约<span class="math inline">\(\Leftrightarrow\)</span>最右句型（规范句型）</li><li>LL(1)文法不需要回溯，是一种确定的自顶向下分析方法（预测分析法）</li><li>预测分析中错误恢复（恐慌模式）：忽略输入中的一些符号，直到输入中出现由设计者选定的同步词法单元集合中的某个词法单元，将FOLLOW集中元素设置为 <span class="math inline">\(synch\)</span><ul><li>如果是空：忽略</li><li>如果是 <span class="math inline">\(synch\)</span> ，弹出栈顶非终结符</li><li>如果是终结符不匹配，弹出终结符</li></ul></li><li>预测分析法实现步骤：<ol type="1"><li>构造文法</li><li>改造文法：消除二义性、消除左递归、消除回溯</li><li>求每个变量的FIRST集和FOLLOW集，从而求得每个候选式的SELECT集</li><li>检查是不是 LL(1) 文法。若是，构造预测分析表</li><li>对于递归的预测分析，根据预测分析表为每一个非终结符编写一个过程；对于非递归的预测分析，实现表驱动的预测分析算法</li></ol></li><li>每次规约的符号串称为“句柄”，句柄是句型的最左直接短语</li><li>LR分析中错误恢复<ul><li>恐慌模式：丢弃输入符号</li><li>短语层次</li></ul></li></ul><h4 id="语法制导翻译">语法制导翻译🎎</h4><ul><li><p>SDD是对CFG的推广</p></li><li><p><strong>注释分析树</strong>：每个节点都有属性值的分析树</p></li><li><p>终结符只能有综合属性</p></li><li><p>一个没有副作用的SDD称为属性文法</p></li><li><p>S-SDD可以按照自底向上顺序计算属性值并且实现</p></li><li><p>如果 S-SDD 的基本文法可以使用LR分析技术，那么它的SDT可以在LR语法分析中实现</p></li><li><p>扩展栈：</p><table><thead><tr class="header"><th style="text-align: center;">状态</th><th style="text-align: center;">符号</th><th style="text-align: center;">属性</th></tr></thead><tbody></tbody></table></li><li><p>如果L-SDD 的基本文法可以使用LL分析技术【LL文法判定】，那么它的SDT可以在LL或LR语法分析中实现</p></li><li><p>如果选用非递归LL实现，扩展语法分析栈：</p><table><thead><tr class="header"><th style="text-align: center;">action</th><th style="text-align: center;">A</th><th style="text-align: center;">Asyn</th></tr></thead><tbody></tbody></table><p>A的继承属性在A中</p></li><li><p>如果选用递归LL实现：继承属性是形参，综合属性的返回值</p></li></ul><h4 id="中间代码生成">中间代码生成🐧</h4><ul><li>局部变量存储分配：对于声明语句，从类型表达式可以知道该类型<strong>在运行时刻所需的存储单元数量</strong>称为类型的宽度。在<strong>编译时刻</strong>，可以使用类型的宽度为每一个名字<strong>分配一个相对地址</strong>。名字的类型和相对地址信息保存在相应的符号表记录中</li><li>逻辑运算符优先级：not &gt; and &gt; or</li></ul><h4 id="运行存储分配">运行存储分配👽</h4><ul><li><p>活动记录结构：</p><table><tbody><tr class="odd"><td style="text-align: center;">实参</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">返回值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">控制链</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">访问链</td><td style="text-align: center;">访问存放于其他活动记录的非局部数据</td></tr><tr class="odd"><td style="text-align: center;">保存的机器状态</td><td style="text-align: center;">返回地址和寄存器中内容</td></tr><tr class="even"><td style="text-align: center;">局部变量</td><td style="text-align: center;">该过程中声明的数据</td></tr><tr class="odd"><td style="text-align: center;">临时变量</td><td style="text-align: center;"></td></tr></tbody></table></li><li><p>栈式存储分配可以保证它的非局部变量的相对地址总是固定的，和过程调用序列无关</p></li><li><p>活动树：用来描述程序运行期间控制进入和离开各个活动情况的树</p></li><li><p>每个活跃的活动都有一个位于控制栈中的活动记录</p></li><li><p>当一个过程是递归的时候，常常会有该过程的多个活动记录同时出现在栈中</p></li><li><p>top_sp指向活动记录中局部数据开始的位置</p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205181113824.png" alt="" style="zoom:67%;" /></p><ul><li>符号表作用：辅助代码生成、一致性检查</li></ul><h4 id="代码优化">代码优化🐇</h4><ul><li>未经声明错误是语义分析检测出的（还有重复定值）；未经定值是数据流分析检测出的</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205181145527.png" alt="" style="zoom:67%;" /></p><h4 id="代码生成">代码生成🌞</h4><ul><li>代码生成器主要任务：<ul><li>指令选择</li><li>寄存器分配和指派</li><li>指令排序</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205181204936.png" alt="" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件过程与工具</title>
    <link href="/post/f6d9959d.html"/>
    <url>/post/f6d9959d.html</url>
    
    <content type="html"><![CDATA[<p><strong>本文章主要基于 哈尔滨工业大学 范国祥老师 软件工程与工具课程</strong></p><span id="more"></span><h1 id="软件过程与工具">软件过程与工具</h1><h2 id="概述">1.概述🥡</h2><h3 id="软件的基本概念">1.1 软件的基本概念</h3><ul><li>1.1.1 什么是软件<ul><li>软件：一组对象或项目所形成的一个“配置”，由<strong>程序、文档和数据</strong>构成。</li><li>“变化”是永恒的主题</li></ul></li><li>1.1.2 软件的发展<ul><li>面向构件的软件 = 构件 + 框架</li><li>面向服务的软件 = 服务 + 消息 + 总线</li></ul></li></ul><h3 id="软件工程的基本概念">1.2 软件工程的基本概念</h3><ul><li>1.2.1 软件工程产生的历史根源</li><li>1.2.2 软件工程的基本概念</li><li>1.2.3 软件工程的知识体系</li></ul><h3 id="软件工程工具">1.3 软件工程工具</h3><ul><li>1.3.1 CASE工具</li></ul><h2 id="软件过程核心思想">2.软件过程核心思想😶‍🌫️</h2><h3 id="软件工程的本质不同抽象层次之间的映射与转换">2.1 软件工程的本质：不同抽象层次之间的映射与转换</h3><ul><li><p>任何软件系统开发的共同本质在于：<strong>从现实空间的需求到计算机空间的软件代码之间的映射与转换</strong></p></li><li><p>单步映射与多步映射</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337499.png" /></p><p>如上图所示，黑色虚线是正确的实现途径，红色是实际的实现途径（单步映射），蓝色也是实际的实现途径（多步映射）</p><ul><li>软件工程本质：用严格的规范和管理手段来缩小偏差，通过牺牲“时间”来提高“质量”</li></ul></li><li><p>软件工程的两个映射</p><ul><li>概念映射：问题空间的概念与解空间的模型化概念之间的映射<ul><li>“学生” <span class="math inline">\(\rightarrow Class Student (No, Name, Dept, Grade)\)</span></li></ul></li><li>业务逻辑映射：问题空间的处理逻辑与解空间处理逻辑之间的映射<ul><li>计算某班学生平均分数→</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">calculateAverageScore</span> <span class="hljs-params">(Struct [] scores)</span> <br>&#123;<br>    检索;<br>    计算平均分算法;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>软件工程：不同抽象层次之间的映射过程</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337315.png" style="zoom:70%;" /></p><p>现实空间的需求<span class="math inline">\(\rightarrow\)</span> 需求规约<span class="math inline">\(\rightarrow\)</span> 设计规约<span class="math inline">\(\rightarrow\)</span> 代码</p></li></ul><h3 id="软件工程所关注的目标">2.2 软件工程所关注的目标</h3><ul><li><p>软件工程所关注的对象</p><ul><li><p>产品：各个抽象层次的产出物</p></li><li><p>过程：在各个抽象层次之间进行映射和转换</p><p>“产品与过程二相性”：要把二者结合起来去考虑，而不能忽略其中任何一方</p></li></ul></li><li><p>软件工程所关注的目标</p><ol type="1"><li>功能性需求：软件所实现的功能达到它的设计规范和满足用户需求的程度<ul><li>完备性、正确性（描述软件在需求范围之内的行为）、健壮性（描述软件在需求范围之外的行为）、可靠性</li></ul></li><li>非功能性需求：系统能够完成所期望的工作的性能与质量<ul><li>效率、可用性、可维护性、可移植性、清晰性、安全性、兼容性、经济性、商业质量</li></ul></li><li>不同目标之间的关系：折中</li></ol></li></ul><h3 id="软件开发中的多角色">2.3 软件开发中的多角色</h3><h3 id="软件工程-最佳实践">2.4 软件工程 = 最佳实践</h3><p><del>（当你把所有错误都犯过之后，你就是正确的了）</del></p><h3 id="软件工程的四个核心理论概念">2.5 软件工程的四个核心理论概念</h3><ul><li>分治</li><li>复用</li><li>折中</li><li>演化<ul><li>软件系统在其生命周期中面临各种变化</li><li>可修改性、可维护性、可扩展性</li></ul></li></ul><h2 id="软件过程模型">3.软件过程模型📮</h2><h3 id="软件过程">3.1 软件过程</h3><ul><li><p>黑盒过程和白盒过程</p><p>将整个软件开发过程看成一个黑盒，而在实际软件开发中要在黑盒中留出白盒进行反馈（<span class="math inline">\(feedback\)</span>）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337643.png"  style="zoom:80%;" /></p></li></ul><h3 id="典型软件过程模型">3.2 典型软件过程模型</h3><h4 id="瀑布模型">3.2.1 瀑布模型</h4><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337802.png" style="zoom:80%;" /></p><p>过程：从上一项活动接收该项活动的工作对象作为输入，利用这一输入实施该项活动应完成的内容给出该项活动的工作成果，并作为输出传给下一项活动。同时评审该项活动的实施，若确认，则继续下一项活动；否则返回前面，甚至更前面的活动（但是这种回溯非常困难）</p><p>每个阶段都有里程碑和提交物。</p><ul><li>优点：追求效率、能够逐步稳定的使项目向前发展</li><li>缺点：过于理想化、快速建立起来的系统结构可能会在后续的持续更改中导致软件质量低下、客户只有在末期才能得到可执行程序</li><li>适合场景：软件项目较小，各模块间接口定义非常清晰；需求在项目开始之前已经被全面的了解，产品的定义非常稳定；需求在开发中不太可能发生重大改变</li></ul><p>瀑布模型太理想化，太单纯，已不再适合现代的软件开发模式，在大型系统开发中已经很少使用。</p><h4 id="增量过程模型">3.2.2 增量过程模型</h4><p>无须等到所有需求都出来才进行开发，只要某个需求的核心部分出来，即可进行开发；可能迫切需要为用户迅速提供一套功能有限的软件产品，然后在后续版本中再细化和扩展功能。</p><ul><li><p>增量模型</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337609.png" style="zoom:60%;" /></p><p><strong>本质：以迭代的方式运用瀑布模型</strong></p><p>当使用增量模型时，<strong>第1个增量往往是核心的产品</strong>，即第1个增量实现了基本的需求，但很多补充的特征还没有发布。客户对每一个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。<strong>增量模型强调每一个增量均发布一个可操作的产品。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">例：开发一个类似于Word的字处理软件<br><span class="hljs-code">增量1：提供基本的文件管理、编辑和文档生成功能</span><br><span class="hljs-code">增量2：提供高级的文档编辑功能</span><br><span class="hljs-code">增量3：实现拼写和语法检查功能</span><br><span class="hljs-code">增量4：完成高级的页面排版功能</span><br></code></pre></td></tr></table></figure><ul><li>优点：能够快速推出软件产品，满足客户需求，对客户有一定的镇定作用、不用一下子投入太多资源。灵活性比较高</li><li>缺点：由于软件其他构件是后期加入的，容易导致由于构件之间的不稳定从而使系统崩溃。</li></ul></li><li><p>快速应用程序开发(RAD)</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337170.png" style="zoom:80%;" /></p><ul><li>优点：<strong>侧重于短开发周期</strong>（一般为60~90天）的增量过程模型，是瀑布模型的高速变体，通过<strong>基于构件的构建方法</strong>实现快速开发；<strong>多个团队并行进行开发</strong>，但启动时间有先后，先启动团队的提交物将作为后启动团队的输入</li><li>缺点：</li><li><strong>需要大量的人力资源</strong>来创建多个相对独立的RAD团队；如果<strong>没有在短时间内为急速完成整个系统做好准备</strong>，RAD项目将会失败；如果<strong>系统不能被合理的模块化</strong>，RAD将会带来很多问题；<strong>技术风险很高的情况下</strong>（采用很多新技术、软件需与其他已有软件建立集成等等），不宜采用RAD</li></ul></li><li><p>增量模型和RAD模型区别：增量模型要求后来的增量不能对之前的系统结构进行破坏</p></li></ul><h4 id="演化过程模型">3.2.3 演化过程模型</h4><p>需求的变更频繁，要求在非常短的期限内实现，以充分满足客户/用户要求、及时投入市场</p><p>本质：循环、反复、不断调整当前系统以适应需求变化</p><p>由于构建产品所需的周期数据不确定，给项目管理带来困难；演化速度太快，项目陷入混乱；演化速度太慢，影响生产率；为追求软件的高质量而牺牲了开发速度、灵活性和可扩展性</p><ul><li><p>快速原型法</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337551.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337539.png" style="zoom:80%;" /></p><ul><li><p>原型的分类</p><ul><li><p>抛弃式原型</p><p>最初的原型在完成并得到用户认可之后，将不会作为交付给用户的最终系统的一部分，而是被抛弃，其目的只是为了收集与验证需求</p><p><strong>该类原型是不可执行的</strong></p></li><li><p>演化式模型</p><p>最初构造的原型将具备较高的质量，包含了系统的核心功能，然后通过收集需求对其进行不断的改善和精化</p><p><strong>该类原型是可执行的，将成为最终系统的一部分</strong></p></li></ul></li><li><p>优点：提高和改善客户/用户的参与程度，最大程度的响应用户需求的变化</p></li><li><p>缺点：设计原型时未考虑整体软件质量和长期的可维护性，系统结构较差；混淆原型系统和最终系统；额外的开发费用</p></li></ul></li><li><p>螺旋模型</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337809.png" style="zoom:70%;" /></p><p>制定计划<span class="math inline">\(\rightarrow\)</span> 风险分析<span class="math inline">\(\rightarrow\)</span>实施工程<span class="math inline">\(\rightarrow\)</span>客户评价<span class="math inline">\(\rightarrow\)</span>制定计划<span class="math inline">\(\rightarrow\)</span>...</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">例：<br>第1圈：开发出产品的规格说明<br>第2圈：开发产品的原型系统<br>第3~n圈：不断的迭代，开发不同的软件版本<br>根据每圈交付后用户的反馈来调整预算、进度、需要迭代的次数<br></code></pre></td></tr></table></figure><p><strong>与增量、RAD等的最大区别在于重视风险评估</strong></p><ul><li>出发点：开发过程中及时识别和分析风险，并采取适当措施以消除或减少风险带来的危害</li><li>优点：结合了原型的迭代性质与瀑布模型的系统性和可控性，是一种<strong>风险驱动型的过程模型</strong></li><li>缺点：周期长，成本高，软件开发人员应该擅长寻找可能的风险</li></ul></li></ul><h4 id="其他过程模型">3.2.4 其他过程模型</h4><ul><li>形式化过程</li><li>软件复用过程</li></ul><h3 id="案例分析">3.3 案例分析</h3><h2 id="敏捷方法与过程">4.敏捷方法与过程🎑</h2><h4 id="敏捷过程模型">4.1 敏捷过程模型</h4><p>开发过程中<strong>“变化”</strong>是无处不在的，要将<strong>“变化”</strong>的意识贯穿在每一项开发活动中。</p><p><strong>“小步快跑，及时反馈”</strong></p><p>本质：<strong>以快速的增量和迭代方式进行软件开发</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337761.png" style="zoom:75%;" /></p><p>敏捷过程中最重要的因素：<strong>人</strong></p><h4 id="极限编程xp">4.2 极限编程(XP)</h4><p>planning(用户故事User story) → design(测试驱动的开发TDD) → coding(结对编程Pair programming) → test(持续集成Continuous instegration)</p><ul><li><p>XP planning</p><p>用户故事：<strong>客户</strong>为用户故事指定<strong>优先级</strong>，<strong>XP团队</strong>为用户故事指定<strong>成本</strong></p><p>将若干个用户故事指定为<strong>下一次发布的增量</strong></p><p>规划<strong>整体进度</strong></p></li><li><p>XP design</p><p>遵循<span class="math inline">\(KIS(Keep\ It\ Simple)\)</span>原则</p><p>设计模型：面向对象方法，<span class="math inline">\(CRC\)</span>卡片</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337682.png" style="zoom:70%;" /></p><p>遇到困难问题：创建原型</p><p>对设计方案不断<strong>重构</strong></p></li><li><p>XP coding &amp; test</p><p>测试驱动的开发<span class="math inline">\((TDD):\)</span></p><ul><li><p>编码前设计<strong>单元测试用例</strong></p></li><li><p><strong>结对编程</strong></p><ul><li><p>驾驶员：控制键盘输入的人</p></li><li><p>领航员：起到领航，提醒的作用</p></li><li><p>驾驶员和领航员不断轮换角色，不宜连续工作超过一小时；领航员要控制时间</p></li><li><p>主动参与、只有水平上的差距，没有级别上的差异</p></li><li><p>程序各方面的质量取决于<strong>一对程序员中各方面水平较高的那一位</strong></p></li></ul></li></ul></li></ul><p>何以谓“极限”：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337950.png" style="zoom:80%;" /></p><h4 id="scrum">4.3 Scrum</h4><p>整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个<span class="math inline">\(Sprint\)</span>，每个<span class="math inline">\(Sprint\)</span>的建议长度是2到4周</p><p>使用产品列表<span class="math inline">\(Product\ Backlog\)</span>来管理需求，产品列表<span class="math inline">\(Product\ Backlog\)</span>是一个按照商业价值排序的需求列表，列表条目的体现形式通常为用户故事</p><p>先开发对于用户具有较高价值的需求</p><p>在<span class="math inline">\(Sprint\)</span>中，<span class="math inline">\(Scrum\)</span>团队从产品列表<span class="math inline">\(Product\ Backlog\)</span>中挑选最高优先级的需求进行开发；挑选的需求在<span class="math inline">\(Sprint\)</span>计划会议上经过讨论、分析和估算得到相应的任务列表(<span class="math inline">\(Sprint\ backlog\)</span>)</p><p>在每个迭代结束时，<span class="math inline">\(Scrum\)</span>团队将提交潜在可交付的产品增量</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211210103202604.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338325.png" style="zoom:55%;" /></p><p><span class="math inline">\(Scrum\)</span>中的六项活动</p><ul><li><span class="math inline">\(Sprint\)</span> (冲刺)：代表一个1-4周的迭代</li><li>发布计划会议<span class="math inline">\((Release\ Planning\ Meeting)\rightarrow\ Product\ Backlog\)</span></li><li><span class="math inline">\(Sprint\)</span>计划会议<span class="math inline">\((Sprint\ Planning\ Meeting) \rightarrow\ Sprint\ Backlog\)</span></li><li>每日站会<span class="math inline">\((Daily\ Scrum\ Meeting)\)</span></li><li><span class="math inline">\(Sprint\)</span>评审会<span class="math inline">\((Sprint\ Review\ Meeting)\)</span></li><li><span class="math inline">\(Sprint\)</span>回顾会议<span class="math inline">\((Sprint\ Retrospective\ Meeting)\)</span></li></ul><p>每日站会：</p><ul><li>我昨天做了什么<span class="math inline">\((What\ have\ you\ done\ since\ yesterday? )\)</span></li><li>我今天要做什么<span class="math inline">\((What\ are\ you\ planning\ to\ do\ today? )\)</span></li><li>我碰到了哪些问题<span class="math inline">\((Do\ you\ have\ any\ problems\ that\ would\ prevent\ you\ from\ accomplishing\ your\ goal\ ?)\)</span></li></ul><p><span class="math inline">\(Sprint\ Burndown\ chart\)</span>：燃尽图，用于表示剩余工作量的工作图表，由横轴（X）和纵轴（Y）组成，横轴表示时间，纵轴表示工作量。这种图表可以直观的预测何时工作将全部完成。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338703.png" style="zoom:60%;" /></p><h4 id="与传统开发过程模型的对比">4.4 与传统开发过程模型的对比</h4><ul><li>瀑布模型<ul><li>将全部需求以整体方式向前推进，无迭代<br /></li><li>基本模型</li></ul></li><li>增量模型<ul><li>将需求分成多份，串行推进，无迭代</li><li>串行的瀑布</li></ul></li><li>RAD模型<ul><li>将需求分成多份，并行推进，无迭代</li><li>并行的瀑布</li></ul></li><li>原型模型<ul><li>迭代</li><li>基本模型</li></ul></li><li>螺旋模型<ul><li>按瀑布阶段划分，各阶段分别迭代(原型+风险分析)</li><li>原型+瀑布</li></ul></li><li>敏捷模型<ul><li>将需求分成尽量小的碎片，以碎片为单位进行高速迭代</li><li>增量+迭代</li></ul></li></ul><h4 id="敏捷案例分析">4.5 敏捷案例分析</h4><h4 id="总结">4.6总结</h4><ul><li><span class="math inline">\(XP\)</span>与<span class="math inline">\(Scrum\)</span>区别<ul><li>迭代长度的不同。<span class="math inline">\(XP\)</span>的一个<span class="math inline">\(Sprint\)</span>的迭代长度大致为1~2周, 而<span class="math inline">\(Scrum\)</span>的迭代长度一般为 2~ 4周。</li><li>在迭代中, 是否允许修改需求。<span class="math inline">\(XP\)</span>在一个迭代中，如果一个用户故事还没有实现， 则可以考虑用另外的需求将其替换， 替换的原则是需求实现的时间量是相等的。 而<span class="math inline">\(Scrum\)</span>是不允许这样做的，一旦迭代开工会完毕, 任何需求都不允许添加进来，并有<span class="math inline">\(Scrum\ Master\)</span>严格把关，不允许开发团队收到干扰。</li><li>在迭代中，用户故事是否严格按照优先级别来实现。<span class="math inline">\(XP\)</span>是务必要遵守优先级别的。 但<span class="math inline">\(Scrum\)</span>在这点做得很灵活， 可以不按照优先级别来做。</li><li>软件的实施过程中，是否采用严格的工程方法，保证进度或者质量。<span class="math inline">\(Scrum\)</span>没有对软件的整个实施过程开出严格工程实践的处方，要求开发者自觉保证；但<span class="math inline">\(XP\)</span>对整个流程方法定义非常严格，规定需要采用<span class="math inline">\(TDD\)</span>, 自动测试，结对编程，简单设计，重构等约束团队的行为。</li></ul></li></ul><h2 id="软件项目管理">5.软件项目管理🦄</h2><p>软件项目的特征：</p><ul><li>不可见性</li><li>不确定性</li><li>多变化性</li><li>高技能及其高流通性</li></ul><h4 id="软件项目管理的案例">5.1 软件项目管理的案例</h4><p>软件项目管理的<span class="math inline">\(4P\)</span></p><ul><li>人员</li><li>产品</li><li>过程</li><li>项目</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338571.png"/></p><h4 id="人员people">5.2 人员(People)</h4><p>软件开发团队的组织方式：</p><ul><li>一窝蜂模式</li><li>主治医师模式<ul><li>明星模式</li></ul></li><li>社区模式<ul><li>开源项目</li></ul></li><li>交响乐团模式<ul><li>“工厂” <span class="math inline">\(\rightarrow\)</span> “规格严格”</li></ul></li><li>爵士乐模式<ul><li>类似于一群天才构成的敏捷团队<span class="math inline">\(\rightarrow\)</span>“功夫到家”</li></ul></li><li>功能团队模式</li><li>官僚模式</li></ul><p>大型项目的技术管理组织结构</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338920.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338516.png"  style="zoom:80%;" /></p><h4 id="产品product">5.3 产品(Product)</h4><p>确定软件范围<span class="math inline">\(\rightarrow\)</span>分治</p><p>产品结构分解<span class="math inline">\(PBS\)</span></p><ul><li>通过分层的树型结构来定义和组织<strong>项目范围内的所有产出物(产品)</strong>，自顶向下，逐级细分</li></ul><h4 id="过程process">5.4 过程(Process)</h4><p>选择合适的软件过程模型<span class="math inline">\(\rightarrow\)</span>根据所选的过程模型，对其进行适应性修改<span class="math inline">\(\rightarrow\)</span>确定过程中所包含的工作任务列表</p><p>工作结构分解<span class="math inline">\(WBS\)</span></p><ul><li>通过分层的树型结构来定义和组织<strong>工作任务之间的分解关系</strong>，自顶向下，逐级细分</li></ul><h4 id="项目project">5.5 项目(Project)</h4><p><span class="math inline">\(W^{5}HH\)</span>原则</p><ul><li><span class="math inline">\(Why\)</span> 为什么要开发这个系统？</li><li><span class="math inline">\(What\)</span> 将要做什么？</li><li><span class="math inline">\(When\)</span> 什么时候做？</li><li><span class="math inline">\(Who\)</span> 某功能由谁来做？</li><li><span class="math inline">\(Where\)</span> 机构组织位于何处？</li><li><span class="math inline">\(How\)</span> 如何完成技术与管理工作？</li><li><span class="math inline">\(How\ much\)</span> 各种资源分别需要多少？</li></ul><h4 id="可行性分析与估算">5.6 可行性分析与估算</h4><h4 id="项目进度计划与监控">5.7 项目进度计划与监控</h4><p>甘特图；描述任务的进度安排</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338913.png" style="zoom:80%;" /></p><p>下图是一张项目进度跟踪甘特图：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338810.png" style="zoom:80%;" /></p><p><span class="math inline">\(T_{x}\)</span>标识<span class="math inline">\(task\)</span>，<span class="math inline">\(M_{x}\)</span>标识里程碑，白色标识各项目计划开始/结束日期，白色 + 蓝色标识各项目实际开始/结束日期。</p><p><span class="math inline">\(XP/Scrum\)</span>敏捷开发中的进度计划与监控</p><ul><li><p>以“迭代”为单位：每次迭代包含多少个用户故事或用例</p></li><li><p>每次迭代为30天左右</p></li><li><p>针对每个用户故事，团队成员联合估算和协商开发代价(时间)</p></li><li><p>使用任务墙(<span class="math inline">\(Task\ Board\)</span>)/燃尽图(<span class="math inline">\(Burndown\ Chart\)</span>)等作为进度监控工具，评估迭代的当前进展情况</p></li></ul><h2 id="软件演化与配置管理">6.软件演化与配置管理🍳</h2><h4 id="软件演化">6.1 软件演化</h4><p>软件演化的<span class="math inline">\(Lehman\)</span>定律</p><ul><li><p>持续变化：现实世界的系统要么变得越来越没有价值，要么进行持续不断的变化以适应环境的变化；环境变化产生软件修改，软件修改又继续促进环境变化</p></li><li><p>复杂度逐渐增大：当系统逐渐发生变化时，其结构和功能将变得越来越复杂，并逐渐难以维护并失去控制，直至无法继续演化，从而需要大量额外的资源和维护工作来保持系统的正常运行；软件修改会引入新的错误，造成故障率的升高</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211211095223736.png" style="zoom:80%;" /></p></li></ul><p>软件演化的处理策略：</p><ul><li>软件维护：为了修改软件缺陷或增加新的功能而对软件进行的变更；软件变更通常发生在局部，不会改变整个结构</li><li>软件再工程：为了避免软件退化而对软件的一部分进行重新设计、编码和测试，提高软件的可维护性和可靠性等</li><li><strong>前者力度小</strong></li></ul><h4 id="软件维护">6.2 软件维护</h4><p>软件维护类型</p><ul><li>纠错性维护（开发中有错误）</li><li>适应性维护（外部环境和数据环境变化）</li><li>完善性维护（新的需求和要求）【占比最大】</li><li>预防性维护（减少或避免前三类维护所做的维护）</li></ul><p>软件维护内容：</p><ul><li>程序维护</li><li>数据维护</li><li>硬件维护</li></ul><h4 id="软件配置管理scm">6.3 软件配置管理(SCM)</h4><p><span class="math inline">\(SCI\)</span>：软件配置项，软件配置的基本单位（文件）</p><p><span class="math inline">\(SCM\)</span>贯穿整个软件生命周期与软件工程过程</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338393.png" style="zoom:75%;" /></p><p><span class="math inline">\(SCM\)</span>目标：当变更发生时，能够提高适应变更的容易程度，并且能够减少所花费的工作量</p><p><span class="math inline">\(SCM\)</span>基本元素：</p><ul><li><p>配置项<span class="math inline">\((CI)\)</span></p><p>软件过程的输出信息可以分为三个主要类别：程序、文档，数据。</p><p>软件配置项<span class="math inline">\(SCI\)</span>：上述三项的总称，包含了所有在软件中产生的信息，<strong>是软件全生命周期内受管理和控制的基本单位</strong>，大到整个系统，小到某个硬件设备或软件模块</p><p><span class="math inline">\(SCI\)</span>具有唯一的名称和多个属性</p><p><span class="math inline">\(CI\)</span>之间<strong>依赖关系</strong>：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338465.png" style="zoom:80%;" /></p><p>对每一个<span class="math inline">\(CI\)</span>建立一个演变图，以记录对象的变更历史</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338247.png" style="zoom:80%;" /></p></li><li><p>基线<span class="math inline">\((Baseline)\)</span></p><p>在软件配置项成为基线之前，可以迅速而随意的进行变更，一旦成为基线，<strong>变更时需要遵循正式的评审流程才可以变更</strong>，因此，基线可看作是软件开发过程中的“里程碑”</p><p>基线是在某个时间点上对产品属性的一致描述，它是定义变化的基础</p><p><span class="math inline">\(Version \geqslant Release \geqslant Baseline \geqslant Milestone \geqslant checkpoint\)</span></p><p><span class="math inline">\(Version\)</span>：对外发布版本</p><p><span class="math inline">\(Release\)</span>：不一定要对外发布，但对外发布版本一定是<span class="math inline">\(Release\)</span></p><p><span class="math inline">\(Baseline\)</span>：不能改动</p><p><span class="math inline">\(Milestone\)</span>：里程碑</p><p><span class="math inline">\(checkpoint\)</span>：检查点，最为灵活</p></li><li><p>配置管理数据库<span class="math inline">\((CMDB)\)</span></p><p>也称为<span class="math inline">\(SCM\)</span>中心存储库，用于保存与软件相关的所有配置项的信息以及配置项之间关系的数据库</p><p><span class="math inline">\(\alpha 测试\)</span>：内部单用户在开发环境测试</p><p><span class="math inline">\(\beta 测试\)</span>：多用户在开发环境测试</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338613.png"  style="zoom:80%;" /></p></li><li><p>最终硬件库<span class="math inline">\((DHS)\)</span></p></li><li><p>最终软件库<span class="math inline">\((DSL)\)</span></p></li></ul><h4 id="持续集成">6.4 持续集成</h4><p>敏捷开发的一项重要实践</p><p>集成：集成测试【集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。一些局部反映不出来的问题，在全局上很可能暴露出来。）】</p><p>所有的开发人员需要在本地机器上做本地构建，然后再提交到版本控制库中，从而确保他们的变更不会导致持续集成失败，开发人员每天至少向版本控制库中提交一次代码，开发人员每天至少需要从版本控制库中更新一次代码到本地机器。需要有专门的集成服务器来执行集成构建，每天要执行多次构建，每次构建都要<span class="math inline">\(100 \%\)</span>通过，每次构建都可以生成可发布的产品，<strong>修复失败的构建是优先级最高的事情</strong></p><h4 id="本地-vs-分布式-版本控制系统">6.5 本地 vs 分布式 版本控制系统</h4><ul><li><p>本地版本控制系统(<span class="math inline">\(Local\ VCS\)</span>)</p><p>采用简单的数据库或文件系统来记录本地文件的历次更新差异</p></li><li><p>集中化版本控制系统<span class="math inline">\((Centralized\ VCS)\)</span></p><p>有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的开发者通过客户端连到这台服务器，取出最新的文件或者提交更新</p><p>缺点：单点故障，可靠性</p></li><li><p>分布式版本控制系统<span class="math inline">\((Distributed\ VCS)\)</span></p><p>客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来</p><p>任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p><p>每一次的提取操作，实际上都是一次对代码仓库的完整备份</p></li></ul><h4 id="git的基本思想">6.6 Git的基本思想</h4><p><span class="math inline">\(git\)</span>关注文件数据整体是否发生变化而不是文件内容</p><ul><li><p>传统思路：存储每个文件与初始版本的差异</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338587.png" /></p></li><li><p><span class="math inline">\(git\)</span>思路：存储项目随时间变化的快照（在本地磁盘保留项目的完整历史，以空间换时间）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338023.png" /></p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211211134742881.png" style="zoom:40%;" /></p><ul><li><span class="math inline">\(workspace\)</span>工作目录【已修改<span class="math inline">\(modified\)</span>】</li><li><span class="math inline">\(staging\)</span>暂存区（本地不占内存）【已暂存<span class="math inline">\(stages\)</span>】：本质上是一个文件，保存了下次要提交的文件列表信息</li><li><span class="math inline">\(local\ repository\)</span>本地仓库【已提交<span class="math inline">\(committed\)</span>】</li><li><span class="math inline">\(remote\ repository\)</span>远程仓库</li></ul><p><span class="math inline">\(git\)</span>工作流程</p><ul><li>在工作目录中修改某些文件</li><li>对修改后的文件进行快照，然后保存到暂存区域</li><li>提交更新，将保存在暂存区域的文件快照永久转储到Git目录中</li></ul><h4 id="基本git指令">6.7 基本Git指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git status<br>哪些更新未暂存？哪些更新已暂存？<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git diff<br>比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容（修改之后但未加入暂存）<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git diff --cached<br>比较的是暂存区域内的文件的更改（修改之后加入缓存但尚未提交）<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git diff HEAD<br>查看已缓存和未缓存的所有差异<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338492.png" style="zoom:70%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git commit -a<br>跳过git add<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset<br>git add的反向操作,使得暂存区与仓库版本一致<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338369.png" style="zoom:80%;" /></p><p>更改一次<span class="math inline">\(commit\)</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">1.git commit --amend<br>2.git reset HEAD^<br>^表示上一次提交<br></code></pre></td></tr></table></figure><h4 id="git远程仓库指令">6.8 Git远程仓库指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git">git fetch<br>从远程仓库抓取数据到本地，获取本地仓库尚未拥有的全部更新<br>如果本地仓库有了不同的修改，则需要手工将本地修改与远程仓库的修改合并起来<br>git merge<br>分支合并<br>git pull = git fetch + git merge<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338982.png" style="zoom:70%;" /></p><h4 id="git分支指令">6.9 Git分支指令</h4><p><span class="math inline">\(git\)</span>分支本质：指向<span class="math inline">\(commit\)</span>对象的可变指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout -b xxx = git branch xxx + git checkout xxx<br>创建分支并跳转<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/techflow/p/13876755.html"><span class="math inline">\(git\)</span>分支</a></p><h4 id="远程分支">6.10 远程分支</h4><p>远程仓库只能看，不能修改</p><h4 id="使用git进行协同开发的实例">6.11 使用Git进行协同开发的实例</h4><h2 id="uml及建模工具">7. UML及建模工具🪂</h2><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338391.png" style="zoom:80%;" /></p><p>UML中事物：</p><ul><li>结构事物</li><li>行为事物</li><li>分组事物<ul><li>包（只存在于开发阶段）</li></ul></li><li>注释事物</li></ul><p>UML中关系：</p><ul><li><p>关联</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338747.png" /></p></li><li><p>依赖</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339834.png" /></p></li><li><p>泛化</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339535.png" /></p></li><li><p>实现</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339262.png" /></p></li><li><p>聚合</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339198.png" /></p></li></ul><h4 id="用例图">7.1 用例图</h4><p>用例图分类：<strong>业务用例图、系统用例图</strong></p><p>用例图组成：<strong>参与者<span class="math inline">\(Actor\)</span>，用例<span class="math inline">\(Use\ Case\)</span>，关联关系<span class="math inline">\(Association\)</span>，包含关系<span class="math inline">\(Include\)</span>，扩展关系<span class="math inline">\(Extend\)</span>，泛化关系<span class="math inline">\(Generalization\)</span></strong></p><ul><li><p>参与者</p><ul><li>参与者对系统而言总是外部的</li><li>分为启动者（消费者）和支持者（商家）</li><li>参与者之间可以有泛化关系</li></ul></li><li><p>用例</p><ul><li><p>区分用例和事件流：用例处于系统的需求分析阶段，避免考虑细节性问题；事件流描述系统“做什么”，会有更多的细节，也是在需求分析阶段。</p></li><li><p>用例对应有事件流文件</p><p>举例：<strong>用例名称：学生选课</strong></p><p><strong>简要描述：把具有选课资格的某一学生加到该课程的选课名单中</strong></p><p><strong>前提条件：学生已注册，选过该课程的先导课程并获得学分</strong></p><p><strong>后置条件：如果学生具有注册资格，并且该课程仍有空位，则学生注册到该课程</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339512.png" style="zoom:60%;" /></p><p>👆🏻一个用例对应的事件流文件</p></li></ul></li><li><p>关联关系</p><ul><li>参与者与用例之间的关系</li></ul></li><li><p>包含关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211213201926513.png" style="zoom:70%;" /></p><ul><li>用户用例执行，提供者用例必须执行</li></ul></li><li><p>扩展关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339441.png" style="zoom:70%;" /></p><ul><li>没有基础用例，扩展用例也是完整的用例</li><li>基础用例被执行时，一般不会涉及扩展用例，只有特定的条件发生，扩展用例才可能被执行，这是与包含关系的差别</li></ul></li><li><p>泛化关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339556.png" style="zoom:70%;" /></p><ul><li>子用例表示父用例的特殊形式</li><li>一个用例（父用例）可以被特别地列举为一个或多个子用例</li><li>泛化关系是一般和特殊的关系</li></ul></li><li><p>用例是有粒度的，用例的粒度指的是用例所包含的系统服务或功能单元的多少。</p><ul><li>用例的粒度越大，用例包含的功能越多，反之则包含的功能越少。</li><li><strong>步骤不是用例</strong></li><li>用例识别的标准：<span class="math inline">\(actor\)</span>与系统之间的一次独立交互</li></ul></li><li><p>注意用例的边界</p></li><li><p>用例是<span class="math inline">\(actor\)</span>与系统之间的交互，<span class="math inline">\(actor\)</span>与<span class="math inline">\(actor\)</span>在现实中的交互不应包含在<span class="math inline">\(use\ case\)</span></p></li><li><p>注意区分<span class="math inline">\(actor\)</span>和系统</p></li><li><p>我们要开发的系统（软件）是业务组织里面的一个业务对象，系统<strong>用例就是这个业务对象对外提供的服务</strong></p></li></ul><h4 id="活动图">7.2 活动图</h4><p>活动图描述活动的顺序，展现从一个活动到另一个活动的控制流，本质是一种<strong>流程图</strong>，着重表现从一个活动到另一个活动的控制流。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214141101491.png"  style="zoom:80%;" /></p><p>活动图元素：</p><ul><li><p>动作状态</p><p><span class="math inline">\(Action\)</span> 节点</p><p>原子（无法分解），不可中断（一旦开始，一直运行到结束），瞬时，可以有入转换，至少有一条出转换</p><p><strong>不能有</strong>入口动作和出口动作，<strong>不能有</strong>内部转移</p></li><li><p>活动状态</p><p><span class="math inline">\(Activity\)</span>节点</p><p>非原子运行（可以分解），活动状态的内部活动可以用另一个<strong>活动图</strong>来表示，可以有入口动作和出口动作，可以有内部转移</p><p><strong>动作状态是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态</strong></p></li><li><p>开始点&amp;结束点</p><p><span class="math inline">\(\bullet\)</span> 表示开始</p><p><span class="math inline">\(\bigotimes\)</span> 表示子流程结束</p><p><span class="math inline">\(\odot\)</span> 表示整个活动结束</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339185.png"  style="zoom:60%;" /></p><p>等价于：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339939.png" style="zoom:60%;" /></p></li><li><p>分支与合并</p><p><span class="math inline">\(\lozenge\)</span> 节点</p></li><li><p>分叉与汇合</p><p>分叉用将控制流分为两个或者多个<strong>并发</strong>运行的分支；汇合用于同步这些<strong>并发</strong>分支，以达到共同完成一项事务的目的</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339135.png" style="zoom:67%;" /></p></li><li><p>泳道</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339325.png" style="zoom:50%;" /></p></li><li><p>对象流</p><p>对象流是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或动作对对象的影响；可以理解为数据流</p></li></ul><p>活动图 <span class="math inline">\(VS\)</span> 状态图</p><p><strong>活动图</strong>着重表现从一个活动到另一个活动的控制流，是<strong>内部处理驱动的流程</strong>；<strong>状态图</strong>着重描述从一个状态到另一个状态的流程，主要有<strong>外部事件的参与</strong></p><p>活动图 <span class="math inline">\(VS\)</span> 流程图</p><p><strong>流程图</strong>着重描述处理过程，它的主要控制结构是顺序、分支和循环，各个处理之间有严格的顺序和时间关系；<strong>活动图</strong>描述的则是对象活动的顺序关系所遵循的规则，它着重表现的是系统的行为，而非系统的处理过程；<strong>活动图能够表示并发活动的情形，流程图不能</strong></p><h4 id="类图对象图">7.3 类图/对象图</h4><p>描述类、接口及他们之间关系的图</p><p>显示系统各个类的<strong>静态结构</strong></p><p>类图的元素</p><ul><li><p>类</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214155332101.png" style="zoom:70%;" /></p><p>类属性可见性：</p><p><span class="math inline">\(public \mapsto +\)</span></p><p><span class="math inline">\(private \mapsto -\)</span></p><p><span class="math inline">\(protected \mapsto\#\)</span></p><p><span class="math inline">\(package \mapsto\)</span> ~</p></li><li><p>接口</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214160404753.png" style="zoom:80%;" /></p></li><li><p>依赖关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339425.png" style="zoom:70%;" /></p></li><li><p>泛化关系</p><p><span class="math inline">\(is\ a\ kind\ of\)</span></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339243.png" style="zoom:60%;" /></p></li><li><p>关联关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339923.png" style="zoom:60%;" /></p><ul><li><p>关联的名称不是必需的</p></li><li><p>关联的角色</p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214161919998.png" style="zoom:60%;" /></p><ul><li>关联的多重性</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339601.png" style="zoom:60%;" /></p><ul><li><p>聚合关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214162140753.png" style="zoom:60%;" /></p><p>整体和部分 <span class="math inline">\(has\ a\)</span></p></li><li><p>组合关系</p><p>一种特殊的聚合关系--&gt;强聚合</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340625.png" style="zoom:60%;" /></p><p><strong>成员对象的生命周期取决于聚合的生命周期</strong></p><p>聚合不仅控制着成员对象的行为，而且控制着成员对象的<strong>创建和析构</strong></p></li></ul></li><li><p>实现关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340457.png" style="zoom:80%;" /></p></li></ul><h4 id="序列图协作图">7.4 序列图/协作图</h4><p>交互图：描述系统中对象之间消息通信的图，包括：序列图，协作图</p><p>序列图用来描述系统中对象间通过消息进行交互，它强调消息在时间轴上的先后顺序：纵轴是时间轴，时间沿竖线向下延伸；横轴代表了在交互中的各独立的对象</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340272.png" style="zoom:80%;" /></p><p>序列图用来描述<strong>用例的实现</strong>，标识了消息发生交互的先后顺序，<strong>明确类的职责</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340372.png" style="zoom:70%;" /></p><p>序列图组成：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340467.png" style="zoom:70%;" /></p><ul><li><p>对象</p><p>创建对象的两种表示方法：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214190345889.png" style="zoom:67%;" /></p><p>注销对象：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340653.png" style="zoom:67%;" /></p></li><li><p>生命线</p></li><li><p>消息</p><p>对象之间某种形式的通信；可以是<strong>信号</strong>，也可以是<strong>调用</strong>；可以用于在对象间传递参数</p><p>消息分类：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340425.png" style="zoom:67%;" /></p></li><li><p>激活</p></li></ul><p>用例图、类图，序列图关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340337.png" style="zoom:80%;" /></p><p><span class="math inline">\(BCE\)</span>模式</p><p>边界类（<span class="math inline">\(Boundary\)</span>）：边界类用来<strong>隔离系统内部和外部</strong>，负责接收参与者的消息</p><p>控制类（<span class="math inline">\(Control\)</span>）：控制类对应用例，用来控制用例执行期间的复杂运算或者业务逻辑；<strong>在分析阶段，通常针对一个用例生成一个控制类</strong></p><p>实体类（<span class="math inline">\(Entity\)</span>）：对应于类图中领域概念中的类；封装了数据结构和数据存储有关的类</p><p>边界类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340947.png" style="zoom:80%;" /></p><p>控制类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340254.png" style="zoom:80%;" /></p><p>实体类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340303.png" style="zoom:80%;" /></p><p>原则：</p><ul><li>针对每一个用例，可以对应生成一个控制类</li><li>参与者对象只能跟边界对象互动</li><li>实体对象不能发送消息给边界对象和控制对象</li><li>特别情况，如只是对数据进行增加、删除、修改和查询操作也可以不设置控制对象，让边界对象直接发送消息给实体对象，以提高执行速度</li></ul><p>一个序列图可以描述多个场景</p><p>组合片段：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340021.png" style="zoom:70%;" /></p><p>操作符分类：</p><ul><li><p><span class="math inline">\(opt\)</span>：包含一个可能发生或可能不发生的序列，可以在临界条件中指定序列发生的条件</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340371.png"  style="zoom:70%;" /></p></li><li><p><span class="math inline">\(alt\)</span>：可以在每个片段中设置一个临界条件来指示该片段可以运行的条件； else 的指示其他任何临界条件都不为true时应运行的片段；如果所有临界条件都为false并且没有else，则不执行任何片段</p></li><li><p><span class="math inline">\(loop\)</span>：片段重复一定次数，可以在临界条件中指示片段重复的条件</p></li><li><p><span class="math inline">\(break\)</span>：如果执行此片段，则放弃序列的其余部分，可以使用临界来指示发生中断的条件</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342515.png" style="zoom:70%;" /></p></li><li><p><span class="math inline">\(par\)</span>：并行处理，片段中的事件可以交错</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342987.png" style="zoom:70%;" /></p></li><li><p><span class="math inline">\(critical\)</span>：指示此片段中的消息不得与其他消息交错，通常是一些原子性操作</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342038.png" style="zoom:70%;" /></p></li><li><p><span class="math inline">\(ref\)</span>：用来在一个交互图中，引用其他的交互图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342976.png" style="zoom:90%;" /></p></li></ul><p>协作图组成：</p><ul><li>对象</li><li>链</li><li>消息</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342783.png" style="zoom:80%;" /></p><p>序列图和协作图是等价的，可以从一种形式的图转换为另一种形式的图而不丢失任何信息</p><h4 id="状态图">7.5 状态图</h4><p>状态图主要用于描述<strong>一个对象</strong>在其生存期间的<strong>动态行为</strong>，表现为<strong>一个对象所经历的状态序列</strong>，引起状态转移的<strong>事件</strong>（<span class="math inline">\(Event\)</span>），以及因状态转移而伴随的<strong>动作</strong>（<span class="math inline">\(Action\)</span>）</p><p>状态图元素：</p><ul><li><p>状态</p><p>状态指在对象的生命周期中的某个条件或者状况；在此期间对象将满足<strong>某些条件、执行某些活动或等待某些事件</strong></p><ul><li>初始状态 <span class="math inline">\(\bullet\)</span></li><li>终止状态 <span class="math inline">\(\bigodot\)</span></li></ul></li><li><p>转移</p><p>对象在源状态中执行一定的动作，并在某个特定事件（<strong>触发事件</strong>）发生而且某个特定的<strong>警界条件</strong>满足时进入<strong>目标状态</strong>；状态可以有返回自身状态的转移（<strong>自身转移</strong>） <span class="math inline">\(\rightarrow\)</span></p></li><li><p>动作</p><p>原子操作</p></li><li><p>组合状态</p><p>含有子状态的状态</p></li><li><p>进入节点&amp;退出节点</p><p>进入节点 <span class="math inline">\(\bigcirc\)</span>：不需要初始化，直接通过进入节点进入状态</p><p>退出节点 <span class="math inline">\(\bigotimes\)</span> ：从子状态转移到外部状态</p></li><li><p>历史状态</p><p>记住从组合状态中退出时所处的子状态</p></li><li><p>并发</p><p>组合状态在某一时刻同时到达多个子状态</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342111.png"  style="zoom:70%;" /></p></li></ul><h4 id="组件图">7.6 组件图</h4><h4 id="部署图">7.7 部署图</h4><h2 id="需求获取与分析">8.需求获取与分析🦷</h2><h4 id="软件需求与需求获取">8.1 软件需求与需求获取</h4><h5 id="软件需求的定义">8.1.1 软件需求的定义</h5><p><strong>对用户需求的管理水平是决定软件成败的重要原因</strong></p><p>需求用于表达：“做什么”，不是表达：“怎么做”</p><h5 id="需求的分类">8.1.2 需求的分类</h5><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342633.png" style="zoom:60%;" /></p><ul><li><p>业务需求</p><p>客户对于系统的高层次目标要求<span class="math inline">\(high-level\ objectives\)</span>) ，定义了项目的远景和范畴(<span class="math inline">\(vision\ and\ scope\)</span>)</p></li><li><p>用户需求</p><p>从用户角度描述的<strong>系统功能需求与非功能需求</strong>，通常只涉及系统的<strong>外部行为</strong>而不涉及内部特性</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342566.png" style="zoom:60%;" /></p><ul><li><p>功能需求</p><p>系统应提供的功能或服务</p></li><li><p>非功能需求</p><p>对<strong>质量和性能</strong>的额外要求</p><ul><li>速度、存储空间、可用性、可靠性、容错性（一般用一些可度量的特性来描述）</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342423.png" style="zoom:60%;" /></p><ul><li><p>约束条件</p><p>法律法规、硬件/资源限制、开发语言</p></li><li><p>业务规则</p><p><strong>内部执行逻辑</strong></p><p>“如果...，那么...”</p></li><li><p>外部接口需求</p></li></ul><h5 id="好的需求与坏的需求">8.1.3 好的需求与坏的需求</h5><p>产生不合格需求的原因：</p><ul><li>无足够用户参与</li><li>用户需求的不断增加</li><li>模棱两可的需求</li><li>不必要的特性</li><li>过于精简的规格说明</li><li>忽略的用户分类</li><li>不准确的计划</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342635.png" style="zoom:70%;" /></p><h5 id="需求工程">8.1.4 需求工程</h5><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342624.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342468.png" style="zoom:65%;" /></p><h5 id="需求获取方法">8.1.5 需求获取方法</h5><p>需求获取的基本步骤：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342373.png" style="zoom:60%;" /></p><p>第1步：<strong>了解相关背景和领域/行业的知识</strong>，确定产品所期望的<strong>用户类</strong></p><p>第2步：与客户企业或组织的<strong>高层人员进行交流</strong>，了解实际用户任务和目标以及这些任务所支持的<strong>业务需求</strong></p><p>第3步：与客户企业或组织的<strong>底层人员进行交流</strong>，获取每个用户类的详细的<strong>用户需求</strong></p><p>第4步：整理需求纪要，<strong>发现新问题</strong>，并重复1-3步</p><p>第5步：<strong>需求分类和组织</strong>，以区别<strong>功能需求、非功能需求、约束条件、业务规则、外部接口需求</strong>、建议解决方法和附加信息</p><p>第6步：<strong>优先排序和冲突解决</strong></p><p>第7步：得到最终需求清单，并与客户做最终<strong>签字确认</strong></p><p>需求获取中的问题：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342857.png" style="zoom:70%;" /></p><p>需求获取技术</p><ul><li><p>收集现有纸面材料</p><ul><li>收集现有的报表、表格和过程描述</li><li>收集现有的工作流程图</li><li>分发和收集需求收集表</li></ul></li><li><p>面对面访谈</p><p>问题分类：</p><p>上下文无关问题：充分理解用户的问题，不涉及具体的解决方案</p><p>解决方案相关的问题：通过这类问题，探寻特定的解决方案并得到用户的认可</p></li><li><p>需求研讨会</p><p><span class="math inline">\(JAD\)</span>会议</p></li><li><p>现场观察/体验</p><p>被动观察：用户实地工作，需求分析人员在旁边看</p><p>主动观察：需求分析人员直接参与到用户的实际工作</p></li><li><p>头脑风暴</p></li></ul><p>对客户输入进行分类：</p><ul><li>业务需求：描述客户可以从产品中得到的<strong>资金、市场或其它业务利润的需求</strong></li><li>业务规则：一些活动只能<strong>在特定的条件下，由一些特定的人来完成时</strong>，该用户可能在描述一个业务规则</li><li>功能需求：用户应该能<span class="math inline">\(&lt;执行某些功能&gt;\)</span>或者系统应该<span class="math inline">\(&lt;具有某些行为&gt;\)</span></li><li>非功能需求</li><li>外部接口序需求：从<span class="math inline">\(&lt;某些设备&gt;\)</span>读取信号；给<span class="math inline">\(&lt;一些其他系统&gt;\)</span>发送信息；以<span class="math inline">\(&lt;某种格式&gt;\)</span>读取文件；能控制<span class="math inline">\(&lt;一些硬件&gt;\)</span></li><li>约束条件：必须使用<span class="math inline">\(&lt;一个特定的数据库产品或语言&gt;\)</span>；不能申请多于<span class="math inline">\(&lt;一定数量的内存&gt;\)</span>；操作必须与<span class="math inline">\(&lt;其它系统&gt;\)</span>相同；必须与<span class="math inline">\(&lt;其它应用程序&gt;\)</span>一致</li><li>数据定义</li></ul><h4 id="用户故事与用例建模">8.2 用户故事与用例建模</h4><h5 id="敏捷开发中的用户故事user-story">8.2.1 敏捷开发中的“用户故事”（User Story）</h5><p>在敏捷开发中，需求表述为一组“用户故事”；在传统的<span class="math inline">\(OO\)</span>分析与设计方法中，需求被表述为一组“用例”</p><p>组成部分：卡片、交谈、确认</p><p><span class="math inline">\(As\ a\ [user\ role],I\ want\ to\ [goal]\,so\ I\ can\ [reason]\ \ \ \rightarrow\ Who/What/Why\)</span></p><p>好的用户故事具备的特征： <span class="math inline">\(INVEST\)</span></p><p><span class="math inline">\(Independent、Negotiable(可讨论的)、Valuable、Estimable、Small、Testable\)</span></p><p><span class="math inline">\(TDD\)</span>：写代码前先写测试</p><h5 id="面向对象方法中的用例use-case">8.2.2 面向对象方法中的“用例”（Use Case）</h5><h5 id="用例建模的基本过程">8.2.3 用例建模的基本过程</h5><ol type="1"><li><p>识别并描述参与者（Actor）</p><p>特殊Actor：系统时钟</p></li><li><p>识别用例</p></li><li><p>识别参与者与角色之间的通讯关联（Association）</p></li><li><p>给出用例详细描述</p><p>事件流</p><ul><li>常规流</li><li>备选流（extend可以看成是备选流）</li></ul></li><li><p>细化用例模型（extend、include、泛化）</p><p>Actor之间存在泛化关系</p></li></ol><p>用例识别标准：actor与系统之间的一次独立交互</p><p>用例是actor与系统之间的交互，actor与actor在现实中的交互（讨价还价）不应包含在用例中</p><p>注意区分actor和系统，系统自己做的事情，不是独立的用例</p><h5 id="用例模型的提交物">8.2.4 用例模型的提交物</h5><h5 id="活动图-泳道图">8.2.5 活动图 &amp; 泳道图</h5><h4 id="需求的结构化分析">8.3 需求的结构化分析</h4><h5 id="结构化方法vs面向对象方法">8.3.1 结构化方法vs面向对象方法</h5><p>结构化方法：复杂世界<span class="math inline">\(\rightarrow\)</span>复杂处理过程（事情的发生发展），设计一系列功能解决</p><p>面向对象方法：任何系统都是由能够完成一组相关任务的对象构成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342199.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342024.png" style="zoom:65%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342738.png" style="zoom:67%;" /></p><h5 id="需求的结构化分析方法">8.3.2 需求的结构化分析方法</h5><p>结构化分析：帮助开发人员定义系统需要做什么（处理需求），系统需要存储和使用哪些数据（数据需求），系统需要什么样的输入和输出以及如何把这些功能结合在一起来完成任务</p><p>结构化分析方法：</p><ul><li>数据流图（<span class="math inline">\(DFD\)</span>）</li><li>实体-关系图（<span class="math inline">\(ERD,IDEF1X\)</span>）</li></ul><h5 id="数据流图dfd">8.3.3 数据流图（DFD）</h5><p>数据流图：用处理、外部实体、数据流以及数据存储来表示系统需求的图表</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342161.png" style="zoom:60%;" /></p><p>从外部实体发出的“数据流”可以是：1.外部实体发出的“处理请求”，即一个事件 2.外部实体给出的“输入数据”</p><p>指向“外部实体”的“数据流”一般是“处理”的反馈或处理结果</p><p>DFD图可以描述高层次的具有高度概括的系统处理也可以描述低层次的具有更详细分解的系统处理</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342013.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342258.png" style="zoom:67%;" /></p><ul><li><p>关联图：在<strong>单个处理符号</strong>中概括系统内所有处理活动的DFD</p><p><strong>关联图在表达系统边界时用处很大</strong>，系统的范围是通过单个的处理和外部实体所表示的事物来定义的；</p><p><strong>数据存储不画在关联图</strong>中是因为它本身被认为是系统内部的内容</p><p>当一个系统响应事件较多时，常常将系统分成多个子系统，并为每个子系统创建一张关联图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343220.png" style="zoom:70%;" /></p></li><li><p>DFD片段：用一个单一处理符号表示系统响应一个事件的DFD</p><p>在DFD片段中，展示了<strong>处理、外部实体和内部数据存储</strong>之间的交互细节</p><p>每个DFD片段仅显示要响应该事件的相关的那些数据存储</p><p><strong>一个DFD片段是为事件表中的每一个事件创建的</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343251.png" style="zoom:70%;" /></p></li><li><p>DFD的0层图：将一个系统或子系统的所有DFD片段组合到一个单个的DFD图中，这样的DFD图称为<strong>事件分离的系统模型/0层图</strong></p><p><strong>0层DFD图：“处理”的编号为<span class="math inline">\(i\)</span></strong></p></li><li><p>DFD层次：一个DFD片段中的<strong>处理</strong>也可以包含多个更小的<strong>处理</strong>，有时分析员需要将该DFD片段进一步细化，生成更详细层次的DFD图</p><p>1层DFD图：将0层DFD中的处理进一步细化等到的DFD图“处理”的编号为“<span class="math inline">\(i.j\)</span>”</p><p>2层DFD图：将1层DFD中的处理进一步细化等到的DFD图 “处理”的编号为“<span class="math inline">\(i.j.k\)</span>”</p></li></ul><p>如何画一个好的DFD图：</p><ul><li><p>最小化复杂度：采用分层结构将DFD划分为小的且相对独立的子集这样可以逐级阅读、考察DFD</p><p><strong>单个DFD图中不应有超过7±2个处理，单个DFD中不应超过7±2个数据流进出同一个处理/数据存储</strong></p><p>接口最小化：DFD中各个元素之间的连接数越少越好</p></li><li><p>保持数据流一致：</p><p><strong>一个“处理”和该“处理”被详细分解后在数据流内容上应该一致</strong></p><p><strong>对一个“处理”，有数据流入则必须有相对应的数据流出</strong></p><p><strong>对一个“处理”，有数据流出则必须有相对应的数据流入</strong></p></li><li><p><strong>黑洞</strong>：带有输入数据的但并不用其产生输出数据的处理或数据存储</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343749.png" style="zoom:50%;" /></p></li><li><p><strong>奇迹</strong>：没有足够数据元素作为输入或产生来源的一个处理或数据存储</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343727.png" style="zoom:50%;" /></p></li><li><p>典型错误：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343082.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343139.png" style="zoom:60%;" /></p></li></ul><p>在传统方法中，DFD图一般描述3种元素：处理【使用DFD】，（数据流，数据存储）【使用DD】</p><p>DFD细节描述：决策表、决策树</p><h5 id="数据字典dd">8.3.4 数据字典（DD）</h5><p>数据字典是数据分析的描述模型，包括：</p><ul><li><p>数据项定义：定义特定数据项的组成和意义</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343555.png" style="zoom:60%;" /></p></li><li><p>数据结构定义：定义有数据项组成的表达数据的基本数据</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343415.png"  style="zoom:60%;" /></p></li><li><p>数据流描述：描述数据流的数据构成，并指明其来源或去向</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343471.png" style="zoom:60%;" /></p></li><li><p>数据存储描述：描述保存在存储介质上的数据文件或数据库表的格式和内容</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343049.png" style="zoom:60%;" /></p></li><li><p>数据处理（广义DD）：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343127.png" style="zoom:60%;" /></p></li></ul><h5 id="数据分析erdidef1x">8.3.5 数据分析（ERD、IDEF1X）</h5><p>实体关系图（<span class="math inline">\(ERD\)</span>）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343154.png"  style="zoom:80%;" /></p><p>关联实体：解决上述问题的人为增加的数据实体，它一定包含两端数据实体的关键字</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343157.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343885.png" style="zoom:80%;" /></p><h4 id="面向对象的分析">8.4 面向对象的分析</h4><h5 id="面向对象的分析方法概述">8.4.1 面向对象的分析方法概述</h5><p>面向对象的分析模型由三个独立模型构成（分为3个阶段）：</p><ul><li>功能模型：从用户角度获取功能需求，由<strong>用例模型</strong>表示</li><li>静态结构模型：描述系统的概念实体，由<strong>类图</strong>表示</li><li>动态结构模型：描述对象之间的交互行为，由<strong>时序图和协作图</strong>表示</li></ul><p>静态结构模型&amp;动态结构模型建立与实现技术无关的系统逻辑结构</p><h5 id="建立静态结构模型">8.4.2 建立静态结构模型</h5><p>静态结构模型</p><ul><li><p>边界类</p><p>用户界面、系统接口、设备接口</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343809.png" style="zoom:80%;" /></p></li><li><p>控制类</p><p>对用例行为的封装，一般一个用例对于一个控制类</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343423.png" style="zoom:100%;" /></p></li><li><p>实体类</p><p>“事物”</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343679.png" style="zoom:100%;" /></p><p>三种类之间是“关联”关系</p><p><strong>一个边界类</strong>可以<strong>与多个控制类</strong>相关联</p><p><strong>一个控制类</strong>可以与<strong>多个边界类</strong>相关联、与<strong>多个实体类</strong>关联</p><p><strong>一个实体类</strong>可以与<strong>多个控制类</strong>相关联</p><ul><li><p>除非系统需要在各用例中管理和维护该角色的信息(不是指ID、密码)，否则只需将其作为actor，无需作为实体类</p></li><li><p><span class="math inline">\(actor\)</span>自己做的动作，都是边界类的操作，与控制类和实体类无关</p></li><li><p>实体类操作分两类：</p><ol type="a"><li><p><span class="math inline">\(new()、destroy()\)</span></p></li><li><p>对该实体内部的一个或多个属性的CRUD（增删改查）操作 — <strong>是自己的属性，不是其他实体的！</strong>因此，对用例中actor所发出的每个动作，需要仔细分析它对哪些实体类的哪些属性做CRUD</p></li></ol></li></ul><p>如果操作CRUD的对象不是该实体类的属性，则说明该操作应移动到相应的实体类中。</p><p>若某操作op会CRUD多个实体类的属性，通常可以把这个操作分解为多个小粒度操作，每个小操作放在专门的实体类中，如果没办法分解，则使用控制类加以完成。</p></li></ul><p>关系：泛化、关联、组合、聚合、依赖</p><ul><li><p>分析类图：主要区分边界类、控制类、实体类</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343643.png" style="zoom:70%;" /></p></li><li><p>领域类图：主要区分泛化、关联、组合、聚合、依赖</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343837.png" style="zoom:70%;" /></p></li></ul><h5 id="建立动态行为模型">8.4.3 建立动态行为模型</h5><p>见7.4</p><h5 id="案例分析-1">8.4.4 案例分析</h5><ol type="1"><li><p>角色识别</p></li><li><p>用例识别</p></li><li><p>建立用例模型</p></li><li><p>对用例图进行精化</p><p>（针对每个用例）</p></li><li><p>撰写用例描述</p></li><li><p>绘制用例的活动（泳道）图</p></li><li><p>识别分析类（边界类、控制类、实体类）</p></li><li><p>识别每个类的属性和方法</p></li><li><p>建立分析类图</p></li><li><p>建立领域类图</p></li><li><p>建立时序图</p></li></ol><h2 id="软件设计">9.软件设计🌏</h2><h4 id="结构化设计">9.1 结构化设计</h4><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343353.png" style="zoom:70%;" /></p><p>自动化系统边界划分：将数据流图分为手工处理部分和系统能自动完成的部分</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343277.png" style="zoom:70%;" /></p><p>结构图创建方法：</p><ul><li><p>DFD片段</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343667.png" style="zoom:70%;" /></p></li><li><p>DFD分解图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343962.png" style="zoom:70%;" /></p></li><li><p>DFD重组</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343136.png" style="zoom:70%;" /></p></li><li><p>结构图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344086.png" style="zoom:70%;" /></p></li></ul><p>变换型结构的数据流图呈一种线性状态，它所描述的工作可表示为输入、主处理及输出。</p><p>事务型结构的数据流图则呈束状，即一束数据流平行流人或流出，可能同时有几个事务要求处理。</p><p>DFD到系统结构图转换的模式：</p><ul><li>事务型</li><li>复杂变换型</li></ul><p>结构图：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344018.png" style="zoom:60%;" /></p><p><strong>三种转换</strong>【重中之重】</p><p><strong>见<span class="math inline">\(PPT\)</span></strong></p><p><a href="https://www.it610.com/article/1864147.htm">转换</a></p><h4 id="面向对象设计">9.2 面向对象设计</h4><p>结构化方法：分析阶段与设计阶段分得特别清楚，分别使用两套完全不同的建模符号和建模方法</p><p>面向对象设计（<span class="math inline">\(OOD\)</span>）：<span class="math inline">\(OO\)</span>各阶段均采用统一的“对象”概念，各阶段之间的区分变得不明显，形成“无缝”连接</p><p>系统设计（<strong>概要设计</strong>）<span class="math inline">\(\ \rightarrow\ \)</span>对象设计（<strong>详细设计</strong>）</p><p>子系统的划分应该符合<strong>高内聚低耦合</strong>的原则</p><p>类与类之间存在的“聚合、组合、关联、依赖”关系导致包与包之间存在依赖关系，即“包的依赖”(<span class="math inline">\(dependency\)</span>)；类与类之间的存在的“继承”关系导致包与包之间存在继承关系，即“包的泛化”(<span class="math inline">\(generalization\)</span>)</p><p>对象设计基本步骤</p><ol type="1"><li>创建初始的设计类</li><li>细化属性</li><li>细化操作</li><li>定义状态</li><li>细化依赖关系</li><li>细化关联关系</li><li>细化泛化关系</li></ol><h4 id="数据库设计">9.3 数据库设计</h4><p>数据库系统 = 数据库（DB） + 数据库管理系统（DBMS）</p><p>数据库设计任务：</p><ul><li>逻辑设计：设计<span class="math inline">\(ER\)</span>模型</li><li>物理设计：在具体的数据库系统中实现<span class="math inline">\(ER\)</span>模型</li></ul><p>数据库<strong>逻辑模型设计</strong>：ERD图</p><p><span class="math inline">\(3NF\)</span>范式：</p><ul><li><span class="math inline">\(1NF\)</span>：没有重复的属性或属性组（同样的东西不能重复拥有）</li><li><span class="math inline">\(2NF\)</span>：是<span class="math inline">\(1NF\)</span>且每个非主属性均函数依赖于主属性（主键）（领导在，他就在，找到领导就能找到他）</li><li><span class="math inline">\(3NF\)</span> ：是<span class="math inline">\(2NF\)</span>且非主属性间均不存在函数依赖（领导只有一个，不能有多级领导）</li></ul><p>根据ERD设计物理数据库</p><ol type="1"><li>为每个实体创建一个二维表</li><li>为每个字段选择适当的数据类型和取值范围</li><li>定义每个表的主键</li><li>针对1：M关联关系的子表添加外键</li><li>定义完整型约束</li></ol><p>分析类图映射到ERD</p><p>本质：把<strong>每一个类，类之间的关系</strong>分别映射到一张表或多张表</p><ul><li><p>一类一表</p></li><li><p>不管是<span class="math inline">\(1\ :\ 1，1\ :\ n，m\ :\ n\)</span>的关联关系 ，均可以：A，B分别映射为独立的数据表，然后再加入一张新表来存储二者之间的关联</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344870.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344820.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344920.png" style="zoom:67%;" /></p></li><li><p>聚合/组合关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344279.png" style="zoom:67%;" /></p></li><li><p>泛化关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344472.png" style="zoom:67%;" /></p></li></ul><h4 id="用户界面设计">9.4 用户界面设计</h4><ul><li><span class="math inline">\(CUI\)</span>：字符用户界面</li><li><span class="math inline">\(GUI\)</span>：图形用户界面 <span class="math inline">\(\rightarrow\ WIMP\)</span></li><li><span class="math inline">\(MUI\)</span>：多通道用户界面</li></ul><p>缺省设计方法：</p><ul><li>用户操作设定缺省值（也可以作为强制值输入）</li><li>经验值作为缺省值</li><li>统计方法确定出现几率大的值作为缺省值</li><li>统计方法确定出现几率大的值作为缺省值</li><li>最近使用值作为缺省值</li><li>输入数据的上下文关联缺省值</li><li>当前状态值可作为缺省值</li><li>当前状态值可作为缺省值</li><li>正常操作序列选项作为缺省值</li><li>树状隶属关系约束选项列表</li><li>智能焦点</li></ul><h2 id="软件测试">10.软件测试🍪</h2><h4 id="软件测试基础">10.1 软件测试基础</h4><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344061.png" style="zoom:60%;" /></p><p>上面的<span class="math inline">\(Venn\ Diagram\)</span>可以理解测试</p><p>测试可以证明“程序有错”，不能证明“程序正确”</p><h4 id="测试过程">10.2 测试过程</h4><p>软件测试的<span class="math inline">\(V\)</span>模型</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344859.png" style="zoom:60%;" /></p><h4 id="测试方法分类">10.3 测试方法分类</h4><ul><li><p>单元测试</p><p><strong>开发人员</strong>执行</p><p>驱动模块：模仿被测模块的上一级模块</p><p>桩模块：模拟被测单元需调用的其他函数接口</p></li><li><p>集成测试</p><p>测试的对象是模块间的接口</p><ul><li><p>整体集成</p><p>将所有模块按设计要求一次全部组装起来，然后进行整体测试</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344081.png" style="zoom:60%;" /></p></li><li><p>增量集成</p><p>逐步将新模块加入并测试</p><ul><li><p>自顶向下增量集成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345446.png" style="zoom:60%;" /></p><p>深度优先：A,B,E,C,D,F</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344771.png" style="zoom:80%;" /></p><p>广度优先：A,B,C,D,E,F</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345884.png" style="zoom:80%;" /></p><p><strong>所需桩模块巨大</strong></p><p>较少需要驱动模块</p></li><li><p>自底向下增量集成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345781.png" style="zoom:80%;" /></p><p><strong>不用桩模块</strong></p><p>难以尽早建立信心</p></li><li><p>三明治集成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345073.png" style="zoom:60%;" /></p></li></ul></li></ul></li><li><p>确认测试</p><p>是否满足软件需求说明书中的确认标准</p></li><li><p>系统测试</p></li><li><p>验收测试</p><p>以用户为主的测试</p><p><span class="math inline">\(\alpha\)</span>测试：由用户在开发环境下进行的测试</p><p><span class="math inline">\(\beta\)</span>测试：由软件的多个用户在实际使用环境下进行测试</p></li><li><p>回归测试</p></li></ul><h4 id="黑盒测试">10.4 黑盒测试</h4><h5 id="黑盒测试概述">10.4.1 黑盒测试概述</h5><p>通常在软件接口处进行</p><p>原理：任何程序都可以看成是将输入定义域取值映射到输出值域的函数</p><p>不可能穷举所有的情况</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345324.png" style="zoom:67%;" /></p><h5 id="等价类划分方法">10.4.2 等价类划分方法</h5><p>确定等价类的六大原则</p><ul><li>在输入条件规定了取值范围或值的个数的情况下，则可以确立1个有效等价类和2个无效等价类</li><li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立1个有效等价类和1个无效等价类</li><li>在输入条件是一个布尔量的情况下，可确定1个有效等价类和1个无效等价类</li><li>在规定了输入数据的一组值(假定n个)、并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和1个无效等价类</li><li>在规定了输入数据必须遵守的规则的情况下，可确立1个有效等价类(符合规则)和n个无效等价类(从不同角度违反规则)</li><li>在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步的划分为更小的等价类</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345728.png" style="zoom:80%;" /></p><h5 id="边界值方法">10.4.3 边界值方法</h5><p>原则</p><ul><li>如果输入条件规定了值的范围，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据</li><li>如果输入条件规定了值的个数，则用最大个数、最小个数、比最小个数少1,比最大个数多1的数据作为测试数据</li><li>将原则1和原则2应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值</li><li>如果程序的规格说明给出的输入域或输出域是有序集合，则应选取集合的第一个元素和最后一个元素作为测试用例</li><li>如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例</li><li>分析规格说明，找出其它可能的边界条件</li></ul><h4 id="白盒测试">10.5 白盒测试</h4><h5 id="白盒测试概述">10.5.1 白盒测试概述</h5><p><strong>白盒测试用例中的输入数据从程序结构导出，但期望输出务必从需求规格中导出</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345499.png" style="zoom:70%;" /></p><h5 id="白盒测试的覆盖标准">10.5.2 白盒测试的覆盖标准</h5><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345445.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345190.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345956.png" style="zoom:80%;" /></p><ul><li><p>语句覆盖</p><p>使每条语句至少被执行一次</p></li><li><p>判定覆盖</p><p>使程序中的每个分支至少都通过一次</p></li><li><p>条件覆盖</p><p>使判定中的<strong>每个条件（不用考虑整体的结果）</strong>获得各种可能的结果</p><p><strong>条件覆盖并不能完全包含判定覆盖，也可能不包含语句覆盖</strong></p></li><li><p>判定/条件覆盖</p><p>使判定中的每个条件取得各种可能的结果，并使得每个分支取得各种可能的结果</p><p>不一定查出逻辑表达式的所有错误</p></li><li><p>条件组合覆盖</p><p>使得每个判定中多个条件的各种取值的可能组合都至少出现一次</p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345199.png" style="zoom:70%;" /></p><h5 id="基本路径法">10.5.3 基本路径法</h5><p>路径测试：设计足够多的测试用例，覆盖被测试对象的所有可能路径</p><p>基本路径测试：保证测试中程序的每一个基本独立路径至少执行一次</p><ol type="1"><li>程序的控制流图：描述程序控制流的一种图示方法</li><li>程序圈复杂度：<span class="math inline">\(McCabe\)</span>复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界</li><li>导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果</li><li>准备测试用例：确保基本路径集中的每一条路径的执行</li></ol><ul><li><p>程序流图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345315.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345807.png" style="zoom:60%;" /></p><p>如果判断中的条件表达式是由一个或多个逻辑运算符 (<span class="math inline">\(OR, AND, NAND, NOR\)</span>) 连接的复合条件表达式，则需要改为一系列只有单条件的嵌套的判断</p><p>独立路径：一条程序执行的路径，至少包含一条在定义该路径之前的其他基本路径不曾用过得边</p><p>圈复杂度：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345553.png" style="zoom:80%;" /></p><p><strong>某些独立路径不能以独立的方式被测试(即穿越路径所需的数据组合不能形成程序的正常流)；在这种情况下，这些路径必须作为另一个路径测试的一部分来进行测试</strong></p><p>“圈复杂度”表示：<strong>只要最多V(G)个测试用例就可以达到基本路径覆盖，但并非一定要设计V(G)个用例</strong></p><p>但是：<strong>测试用例越简化，代表测试越少、可能发现的错误就越少</strong></p></li></ul><h5 id="循环测试法">10.5.4 循环测试法</h5><h5 id="xunit白盒测试">10.5.5 xUnit白盒测试</h5>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件过程与工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC学习</title>
    <link href="/post/1c335eca.html"/>
    <url>/post/1c335eca.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对JDBC进行相关总结</p><span id="more"></span><p><span class="math inline">\(JDBC\)</span>是SUN公司定义的一套接口，因为每一个数据库的底层实现原理都不一样，所以需要引入这一套规范。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251400895.png" /></p><p>首先引入依赖，可以下载对应<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">jar包</a>,具体步骤这里不再详说。 接下来到了具体JDBC代码的编写，主要分为以下6步。</p><p><strong>1.注册驱动</strong>（告诉<span class="math inline">\(java\)</span>程序，即将连接的是哪个公司的数据库）</p><p>这一步最原始的写法是： <figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>    Driver driver = <span class="hljs-keyword">new</span> com.mysql.cj.jdbc.<span class="hljs-constructor">Driver()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>register<span class="hljs-constructor">Driver(<span class="hljs-params">driver</span>)</span>;<br>&#125; catch (SQLException e) &#123;<br>    e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 通过Driver类获取到JDBC驱动。而查看<code>com.mysql.cj.jdbc.Driver</code>的源码 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.mysql.cj.jdbc;<br><br><span class="hljs-keyword">import</span> java.sql.<span class="hljs-type">DriverManager</span>;<br><span class="hljs-keyword">import</span> java.sql.<span class="hljs-type">SQLException</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-title">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>&#123;<br>    public <span class="hljs-type">Driver</span>() <span class="hljs-keyword">throws</span> <span class="hljs-type">SQLException</span> &#123;<br>    &#125;<br><br>    static &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DriverManager</span>.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-type">Driver</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">SQLException</span> var1) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 可以看到有一个静态代码块完成了<code>registerDriver</code>的工作，所以我们只需要使用反射机制即可： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)</span>;<br>&#125; catch (ClassNotFoundException e) &#123;<br>    e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>2.获取连接</strong>（表示<span class="math inline">\(JVM\)</span>的进程和数据库进程之间的通道打开了，这属于进程之间的通信，比较重量级，使用完需要关闭）</p><p>这里使用如下方法进行连接的获取： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>get<span class="hljs-constructor">Connection(<span class="hljs-string">&quot;jdbc:mysql://ip:port/dbname&quot;</span>,<span class="hljs-params">user</span>,<span class="hljs-params">passwd</span>)</span>;<br></code></pre></td></tr></table></figure> 比如我的ip就用本地<code>localhost</code>或者<code>127.0.0.1</code>，<code>port</code>一般使用3306，<code>dbname</code>、<code>user</code>和<code>passwd</code>根据自己的数据库修改即可。</p><p><strong>3.获取数据库对象</strong>（专门执行<span class="math inline">\(SQL\)</span>语句的对象）</p><p>可以使用<code>Statement</code>来获取数据库对象： <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Statement stmt <span class="hljs-operator">=</span> conn.createStatement()<span class="hljs-comment">;</span><br>String sql <span class="hljs-operator">=</span> <span class="hljs-string">&quot;....&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure> 注意这里的sql语句定义在stmt之后,如果使用<code>Statement</code>的话，可能会遇到sql注入问题，具体可以参考：<a href="https://www.jianshu.com/p/643866408bb7">SQL注入</a>这篇博客，所以我们一般使用<code>PreparedStatement</code>获取数据库对象： <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String sql <span class="hljs-operator">=</span> <span class="hljs-string">&quot;....&quot;</span><span class="hljs-comment">;</span><br>PreparedStatement ps <span class="hljs-operator">=</span> conn.prepareStatement(sql)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure> 注意这里的sql语句定义在ps之前,可以看看源码 <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">PreparedStatement</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Statement</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure> <code>PreparedStatement</code>继承自<code>Statement</code>，它也是一个接口。解决sql注入问题的关键在于不让用户输入的语句参与sql语句的编译过程，<code>PreparedStatement</code>的原理是预先对sql语句的框架进行预编译，然后再给sql语句传值。 在sql语句里需要的值先用<code>?</code>替换，具体使用可以参见下一部分。 <strong>Tips</strong>：当然这里说一句<code>Statement</code>和<code>PreparedStatement</code>各有各的用处，并不是一股脑就用<code>PreparedStatement</code>的，以下情况一般使用<code>Statement</code>：(1).业务逻辑需要sql注入；(2).需要sql语句拼接。</p><p><strong>4.执行<span class="math inline">\(SQL\)</span>语句</strong>（<span class="math inline">\(DQL，DML\)</span>）</p><p>原表</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401265.png" /></p><ul><li><p>增 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String sql = <span class="hljs-string">&quot;insert into sc value(?,?,?)&quot;</span>;<br>ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>ps.set<span class="hljs-constructor">String(1,<span class="hljs-string">&quot;12345678&quot;</span>)</span>;<br>ps.set<span class="hljs-constructor">String(2,<span class="hljs-string">&quot;222&quot;</span>)</span>;<br>ps.set<span class="hljs-constructor">String(3,<span class="hljs-string">&quot;96&quot;</span>)</span>;<br><span class="hljs-built_in">int</span> count = ps.execute<span class="hljs-constructor">Update()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(count);<br></code></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401211.png" /></p><p>现在的表：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401993.png" /></p></li><li><p>删 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String sql = <span class="hljs-string">&quot;delete from sc where s_id = ?&quot;</span>;<br>ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>ps.set<span class="hljs-constructor">String(1,<span class="hljs-string">&quot;12345678&quot;</span>)</span>;<br><span class="hljs-built_in">int</span> count = ps.execute<span class="hljs-constructor">Update()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(count);<br></code></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401860.png" /></p><p>现在的表：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401617.png" /></p></li><li><p>改 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String sql = <span class="hljs-string">&quot;update sc set score = ? where s_id = 98020101&quot;</span>;<br>ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>ps.set<span class="hljs-constructor">String(1,<span class="hljs-string">&quot;90&quot;</span>)</span>;<br><span class="hljs-built_in">int</span> count = ps.execute<span class="hljs-constructor">Update()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(count);<br></code></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401487.png" /></p><p>现在的表：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401601.png" /></p></li><li><p>查 <figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select s_id,c_id,score from sc where score &gt; ?&quot;</span>;<br><span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-variable">conn</span>.<span class="hljs-property">prepareStatement</span>(<span class="hljs-variable">sql</span>);<br><span class="hljs-variable">ps</span>.<span class="hljs-property">setString</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;85&quot;</span>);<br><span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-variable">ps</span>.<span class="hljs-property">executeQuery</span>();<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-string">&quot;s_id<span class="hljs-char escape_">\t</span>c_id<span class="hljs-char escape_">\t</span>score&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-variable">rs</span>.<span class="hljs-property">next</span>()) &#123;<br>  <span class="hljs-title class_">String</span> <span class="hljs-variable">sid</span> <span class="hljs-operator">=</span> <span class="hljs-variable">rs</span>.<span class="hljs-property">getString</span>(<span class="hljs-string">&quot;s_id&quot;</span>);<br>  <span class="hljs-title class_">String</span> <span class="hljs-variable">cid</span> <span class="hljs-operator">=</span> <span class="hljs-variable">rs</span>.<span class="hljs-property">getString</span>(<span class="hljs-string">&quot;c_id&quot;</span>);<br>  <span class="hljs-title class_">String</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-variable">rs</span>.<span class="hljs-property">getString</span>(<span class="hljs-string">&quot;score&quot;</span>);<br>  <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">sid</span> <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\t</span>&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">cid</span> <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\t</span>&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">score</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>以下为运行结果：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251402376.png" /></p></li></ul><p><strong>5.处理查询结果集</strong>（只有执行<span class="math inline">\(DQL\)</span>语句后需要） <span class="math inline">\(DML\)</span>一语句一般返回<code>int</code>类型的量，而<span class="math inline">\(DQL\)</span>语句返回一个<span class="math inline">\(ResultSet\)</span>类型的量。 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//if DML</span><br><span class="hljs-built_in">int</span> res = ps.execute<span class="hljs-constructor">Update()</span>;<br></code></pre></td></tr></table></figure></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//if DQL</span><br>ResultSet rs = ps.execute<span class="hljs-constructor">Query()</span>;<br><span class="hljs-keyword">while</span> (rs.next<span class="hljs-literal">()</span>) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(1)</span>);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(2)</span>);<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>但是上面这种可能没有灵活性，所以有以下写法： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//if DQL</span><br>ResultSet rs = ps.execute<span class="hljs-constructor">Query()</span>;<br><span class="hljs-keyword">while</span> (rs.next<span class="hljs-literal">()</span>) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(<span class="hljs-params">col_name1</span>)</span>);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(<span class="hljs-params">col_name2</span>)</span>);<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure> 上面的<code>col_name1</code>,<code>col_name2</code>都是列名，这样也更加具有灵活性。</p><p><strong>6.释放资源</strong> 根据开启的顺序反向关闭<code>conn</code>，<code>ps</code>，<code>rs</code> <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss">if (rs != null) &#123;<br>    try &#123;<br>        rs<span class="hljs-selector-class">.close</span>();<br>    &#125; catch (SQLException e) &#123;<br>        e<span class="hljs-selector-class">.printStackTrace</span>();<br>    &#125;<br>&#125;<br>if (ps != null) &#123;<br>    try &#123;<br>        ps<span class="hljs-selector-class">.close</span>();<br>    &#125; catch (SQLException e) &#123;<br>        e<span class="hljs-selector-class">.printStackTrace</span>();<br>    &#125;<br>&#125;<br>if (conn != null) &#123;<br>    try &#123;<br>        conn<span class="hljs-selector-class">.close</span>();<br>    &#125; catch (SQLException e) &#123;<br>        e<span class="hljs-selector-class">.printStackTrace</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>接下来，可以对以上内容进行封装 封装一个工具类<code>DBUtil</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装JDBC工具类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fly-beep</span><br><span class="hljs-comment"> */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBUtil</span> &#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取数据库连接对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 连接对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment">       */</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sct&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;333&quot;</span>);<br>         &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭各种已经建立的资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ps</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rs</span><br><span class="hljs-comment">       */</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Connection conn,Statement ps,ResultSet rs)</span> &#123;<br>        <span class="hljs-keyword">if</span> (rs != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ps != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ps.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>       &#125;<br>         &#125;<br>         <br></code></pre></td></tr></table></figure></p><p>具体使用如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询以王开头的学生学号和姓名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fly-beep</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jdbcTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            conn = DBUtil.getConnection();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select s_id,s_name from student where s_name like ?&quot;</span>;<br>            ps = conn.prepareStatement(sql);<br>            ps.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;王%&quot;</span>);<br>            rs = ps.executeQuery();<br>            System.out.println(<span class="hljs-string">&quot;s_id&quot;</span> + <span class="hljs-string">&quot;\t\t&quot;</span> + <span class="hljs-string">&quot;s_name&quot;</span>);<br>            <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>                System.out.println(rs.getString(<span class="hljs-string">&quot;s_id&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span> + rs.getString(<span class="hljs-string">&quot;s_name&quot;</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            DBUtil.close(conn,ps,rs);<br>        &#125;<br>    &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure></p><p>查询结果如下： <img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251402843.png" /></p><p>JDBC执行事务操作 JDBC中的事务是自动提交的，只要执行任意一条<code>DML</code>语句，则自动提交一次。而我们可以使用conn的<code>setAutoCommit</code>函数取消这种自动提交机制。 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>    .....<br>    conn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>get<span class="hljs-constructor">Connection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sct&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;333&quot;</span>)</span>;<br>    <span class="hljs-comment">//取消自动提交事务</span><br>    conn.set<span class="hljs-constructor">AutoCommit(<span class="hljs-params">false</span>)</span>;<br>    String sql1 = <span class="hljs-string">&quot;&quot;</span>;<br>    String sql2 = <span class="hljs-string">&quot;&quot;</span>;<br>    .....<br><br>    ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql1</span>)</span>;<br>    ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql2</span>)</span>;<br>    .....<br>    <br>    <span class="hljs-comment">//运行到这说明没有问题，提交事务</span><br>    conn.commit<span class="hljs-literal">()</span>;<br>&#125; catch (Exception e) &#123;<br>    <span class="hljs-keyword">if</span>(conn != null) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//回滚事务</span><br>            conn.rollback<span class="hljs-literal">()</span>;<br>        &#125; catch (SQLException ex) &#123;<br>            ex.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 以上即为JDBC部分的全部内容！</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postgresql安装pg_hint_plan插件</title>
    <link href="/post/72be2669.html"/>
    <url>/post/72be2669.html</url>
    
    <content type="html"><![CDATA[<p>解决postgresql安装pg_hint_plan插件的相关问题</p><span id="more"></span><p>前言：由于项目需要，我需要使用<span class="math inline">\(postgresql\)</span>中的pg_hint_plan插件进行相关的分析，但是在安装中网上却并未找到很有效的相关资料，现总结如下：</p><p>本机配置： <span class="math inline">\(CentOs\ 7.6\)</span></p><h2 id="安装postgresql">安装<span class="math inline">\(postgresql\)</span></h2><p>参考<a href="https://www.postgresql.org/download/linux/redhat/">官网</a>上的描述，主要使用以下代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">sudo yum install -y https:<span class="hljs-regexp">//</span>download.postgresql.org<span class="hljs-regexp">/pub/</span>repos<span class="hljs-regexp">/yum/</span>reporpms<span class="hljs-regexp">/EL-7-x86_64/</span>pgdg-redhat-repo-latest.noarch.rpm<br>sudo yum install -y postgresql14-server<br>sudo <span class="hljs-regexp">/usr/</span>pgsql-<span class="hljs-number">14</span><span class="hljs-regexp">/bin/</span>postgresql-<span class="hljs-number">14</span>-setup initdb<br>sudo systemctl enable postgresql-<span class="hljs-number">14</span><br>sudo systemctl start postgresql-<span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><p>初始化数据库： <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/usr/</span>pgsql-<span class="hljs-number">14</span><span class="hljs-regexp">/bin/</span>postgresql-<span class="hljs-number">14</span>-setup initdb<br></code></pre></td></tr></table></figure></p><p>设置开机启动： <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo systemctl <span class="hljs-built_in">enable</span> postgresql-14<br></code></pre></td></tr></table></figure></p><p>启动postgresql服务 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> systemctl start postgresql-<span class="hljs-number">14</span><br></code></pre></td></tr></table></figure></p><p>设置数据库密码 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">su postgres<br>psql<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> postgres <span class="hljs-keyword">with</span> <span class="hljs-keyword">password</span> <span class="hljs-string">&#x27;yourpwd&#x27;</span><br></code></pre></td></tr></table></figure></p><p>开启远程访问 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/pgsql/</span><span class="hljs-number">14</span><span class="hljs-regexp">/data/</span>postgresql.conf<br></code></pre></td></tr></table></figure></p><p>找到下面的listen_address: <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">listen_address</span> = <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure></p><p>增加信任连接 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">vi /var/lib/pgsql/<span class="hljs-number">14</span>/data/pg_hba.conf<br></code></pre></td></tr></table></figure></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># IPv4 local connections:</span><br><span class="hljs-attribute">host</span>    <span class="hljs-literal">all</span>             <span class="hljs-literal">all</span>             <span class="hljs-number">0.0.0.0</span>/<span class="hljs-number">0</span>               trust<br></code></pre></td></tr></table></figure><p>重启服务 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">systemctl</span> restart postgresql-<span class="hljs-number">14</span><br></code></pre></td></tr></table></figure></p><p>添加端口号并重启防火墙 <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">zone=public</span> <span class="hljs-literal">--</span><span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">port=5432/tcp</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanent</span><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">reload</span><br></code></pre></td></tr></table></figure></p><p>这时候可以检查一下： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">rpm -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> postgresql<br></code></pre></td></tr></table></figure></p><p>命令行会输出以下信息： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">postgresql14</span>-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-libs-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-server-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br></code></pre></td></tr></table></figure></p><p>并且保证此时在root的权限下直接输入： <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">su postgres</span><br></code></pre></td></tr></table></figure></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">su postgres</span><br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">psql</span><br></code></pre></td></tr></table></figure><p>此时可以成功打开postgres即可！</p><h2 id="安装postgresql-devel">安装<span class="math inline">\(postgresql-devel\)</span></h2><p>这一步可以说是最坑的了，因为一般安装postgresql时只会安装 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">postgresql14</span>-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-libs-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-server-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br></code></pre></td></tr></table></figure></p><p>这三个包，但是这时的postgresql是<strong>没有C/C++环境</strong>的，而我们如果想要安装pg_hint_plan的话是需要的，所以我们需要安装<span class="math inline">\(postgresql-devel\)</span>。</p><p>直接运行： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> postgresql14-devel<br></code></pre></td></tr></table></figure></p><p>这时输入： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">rpm -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> postgresql<br></code></pre></td></tr></table></figure></p><p>命令行会输出以下信息： <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">postgresql14</span>-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-libs-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-devel-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-server-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br></code></pre></td></tr></table></figure></p><h2 id="安装pg_hint_plan插件">安装pg_hint_plan插件</h2><p>从<a href="https://github.com/ossc-db/pg_hint_plan/tags">官网</a>按照对应PG14版本的pg_hint_plan的<span class="math inline">\(.tar.gz\)</span>文件。</p><p>我下载的是pg_hint_plan-REL14_1_4_0.tar.gz</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">tar -zxvf pg_hint_plan-REL14_1_4_0.tar.gz<br>make<br>make install<br></code></pre></td></tr></table></figure><p>但是这时会遇到另一个坑了，以上代码是作者写在<span class="math inline">\(README.md\)</span>中的下载方法，但是这时你需要设置路径，所以应该执行以下代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">tar -zxvf pg_hint_plan-REL14_1_4_0.tar.gz<br>export <span class="hljs-type">PATH</span>=&quot;$PATH:/usr/pgsql-14/bin&quot;<br>make<br>make install<br></code></pre></td></tr></table></figure><p>这时就没问题了！</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251402401.png" /></p><hr /><p>参考链接：</p><ul><li><a href="https://www.postgresql.org/download/linux/redhat/">https://www.postgresql.org/download/linux/redhat/</a></li><li><a href="https://centos.pkgs.org/7/postgresql-14-aarch64/postgresql14-devel-14.2-1PGDG.rhel7.aarch64.rpm.html">https://centos.pkgs.org/7/postgresql-14-aarch64/postgresql14-devel-14.2-1PGDG.rhel7.aarch64.rpm.html</a></li><li><a href="https://stackoverflow.com/questions/4293111/postgresql-pg-config-bash-pg-config-command-not-found">https://stackoverflow.com/questions/4293111/postgresql-pg-config-bash-pg-config-command-not-found</a></li><li><a href="https://github.com/ossc-db/pg_hint_plan/tags">https://github.com/ossc-db/pg_hint_plan/tags</a></li><li><a href="https://github.com/ossc-db/pg_hint_plan/issues/57">https://github.com/ossc-db/pg_hint_plan/issues/57</a></li><li><a href="https://osdn.net/projects/pghintplan/howto/install">https://osdn.net/projects/pghintplan/howto/install</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/post/63785.html"/>
    <url>/post/63785.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇文章">第一篇文章</h1><p>写这篇文章主要是要警示自己：<strong>绝知此事要躬行</strong> <span id="more"></span></p><hr /><p>下面放一些自己喜欢的句子：</p><hr /><p>苦难既然把我推到了悬崖的边缘，那么就让我在这悬崖边坐下来，顺便看看悬崖下的流岚雾霭，唱支歌给你听。</p><hr /><p>酒一杯，敬温华不练剑，</p><p>酒二杯，敬李淳罡为后辈开山，</p><p>酒三杯，敬曹官子一人攻城，</p><p>酒四杯，敬黄三甲为万世开太平，</p><p>酒五杯，敬李义山为北凉谋生路，</p><p>酒六杯，敬洪洗象为红颜修正道，</p><p>酒七杯，敬李玉斧为后世关天门，</p><p>酒八杯，敬徐凤年为中原百姓守国门，</p><p>酒九杯，敬中原宗师拒北城悍然赴死。</p><hr /><p>最后，Saber镇站：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/Saber.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
