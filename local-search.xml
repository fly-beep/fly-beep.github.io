<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql-bulk-loader之MySQLBulkLoaderDialog</title>
    <link href="/post/56726c76.html"/>
    <url>/post/56726c76.html</url>
    
    <content type="html"><![CDATA[<h1id="mysql-bulk-loader之mysqlbulkloaderdialog">mysql-bulk-loader之MySQLBulkLoaderDialog</h1><p>前情提要：</p><p>Kettle组件就是一个step，它有四个类构建而成，每个类职责不同，各司其职。</p><span id="more"></span><ul><li>BaseStep:step类，实现了StepInterface接口，它是每个组件实际的业务处理类，组件的功能在这个类里实现。</li><li>BaseStepMeta:step元数据类，实现了StepMetaInterface接口，它的职责是保存和序列化组件的配置。</li><li>BaseStepData:step数据类，实现了StepDataInterface接口，用于存放每个组件在执行过程中的数据。</li><li>BaseStepDialog:step界面类，实现了StepDialogInterface接口，实现组件和用户进行交互的界面，提供一个对组件进行配置的界面。</li></ul><h2 id="mysqlbulkloaderdialog">MySQLBulkLoaderDialog</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PluginDialog( id = &quot;MySQLBulkLoader&quot;, image = &quot;BLKMYSQL.svg&quot;, pluginType = PluginDialog.PluginType.STEP,</span><br><span class="hljs-meta">  documentationUrl = &quot;http://wiki.pentaho.com/display/EAI/MySQL+Bulk+Loader&quot; )</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySQLBulkLoaderDialog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseStepDialog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StepDialogInterface</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; PKG = MySQLBulkLoaderDialog.class; <span class="hljs-comment">// for i18n purposes, needed by Translator2!!</span><br><br>  <span class="hljs-keyword">private</span> CCombo wConnection;<br><br>  <span class="hljs-keyword">private</span> Label wlSchema;<br>  <span class="hljs-keyword">private</span> TextVar wSchema;<br>  <span class="hljs-keyword">private</span> FormData fdlSchema, fdSchema;<br><br>  <span class="hljs-keyword">private</span> Label wlTable;<br>  <span class="hljs-keyword">private</span> Button wbTable;<br>  <span class="hljs-keyword">private</span> TextVar wTable;<br>  <span class="hljs-keyword">private</span> FormData fdlTable, fdbTable, fdTable;<br><br>  <span class="hljs-keyword">private</span> Label wlFifoFile;<br>  <span class="hljs-keyword">private</span> TextVar wFifoFile;<br>  <span class="hljs-keyword">private</span> FormData fdlFifoFile, fdFifoFile;<br><br>  <span class="hljs-keyword">private</span> Label wlReplace;<br>  <span class="hljs-keyword">private</span> Button wReplace;<br>  <span class="hljs-keyword">private</span> FormData fdlReplace, fdReplace;<br><br>  <span class="hljs-keyword">private</span> Label wlIgnore;<br>  <span class="hljs-keyword">private</span> Button wIgnore;<br>  <span class="hljs-keyword">private</span> FormData fdlIgnore, fdIgnore;<br><br>  <span class="hljs-keyword">private</span> Label wlLocal;<br>  <span class="hljs-keyword">private</span> Button wLocal;<br>  <span class="hljs-keyword">private</span> FormData fdlLocal, fdLocal;<br><br>  <span class="hljs-keyword">private</span> Label wlDelimiter;<br>  <span class="hljs-keyword">private</span> Button wbDelimiter;<br>  <span class="hljs-keyword">private</span> TextVar wDelimiter;<br>  <span class="hljs-keyword">private</span> FormData fdlDelimiter, fdDelimiter;<br><br>  <span class="hljs-keyword">private</span> Label wlEnclosure;<br>  <span class="hljs-keyword">private</span> TextVar wEnclosure;<br>  <span class="hljs-keyword">private</span> FormData fdlEnclosure, fdEnclosure;<br><br>  <span class="hljs-keyword">private</span> Label wlEscapeChar;<br>  <span class="hljs-keyword">private</span> TextVar wEscapeChar;<br>  <span class="hljs-keyword">private</span> FormData fdlEscapeChar, fdEscapeChar;<br><br>  <span class="hljs-keyword">private</span> Label wlCharSet;<br>  <span class="hljs-keyword">private</span> TextVar wCharSet;<br>  <span class="hljs-keyword">private</span> FormData fdlCharSet, fdCharSet;<br><br>  <span class="hljs-keyword">private</span> Label wlBulkSize;<br>  <span class="hljs-keyword">private</span> TextVar wBulkSize;<br>  <span class="hljs-keyword">private</span> FormData fdlBulkSize, fdBulkSize;<br><br>  <span class="hljs-keyword">private</span> Label wlReturn;<br>  <span class="hljs-keyword">private</span> TableView wReturn;<br>  <span class="hljs-keyword">private</span> FormData fdlReturn, fdReturn;<br><br>  <span class="hljs-keyword">private</span> Button wGetLU;<br>  <span class="hljs-keyword">private</span> FormData fdGetLU;<br>  <span class="hljs-keyword">private</span> Listener lsGetLU;<br><br>  <span class="hljs-keyword">private</span> Button wDoMapping;<br>  <span class="hljs-keyword">private</span> FormData fdDoMapping;<br><br>  <span class="hljs-keyword">private</span> MySQLBulkLoaderMeta input;<br><br>  <span class="hljs-keyword">private</span> ColumnInfo[] ciReturn;<br><br>  <span class="hljs-keyword">private</span> Map&lt;String, Integer&gt; inputFields;<br><br>  <span class="hljs-keyword">private</span> List&lt;ColumnInfo&gt; tableFieldColumns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ColumnInfo&gt;();<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="构造函数">构造函数</h3><p>用于创建 MySQL Bulk Loader 步骤的图形用户界面（GUI）对话框。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">MySQLBulkLoaderDialog</span><span class="hljs-params">( Shell parent, Object in, TransMeta transMeta, String sname )</span> &#123;<br>  <span class="hljs-built_in">super</span>( parent, (BaseStepMeta) in, transMeta, sname );<br>  input = (MySQLBulkLoaderMeta) in;<br>  inputFields = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Integer&gt;();<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="open">open</h3><p>其作用是打开一个对话框。这段代码创建了一个对话框，并在对话框中添加了多个控件，如标签、文本框、按钮等，用于接收用户的输入。其中包括一些事件监听器，用于处理控件的修改事件和焦点丢失事件。在最后，通过<code>shell.open()</code>打开对话框，并使用一个循环来处理对话框的事件，直到对话框被关闭。最后，返回步骤名称<code>stepname</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Shell</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> getParent();  <span class="hljs-comment">// 获取父级 Shell</span><br>    <span class="hljs-type">Display</span> <span class="hljs-variable">display</span> <span class="hljs-operator">=</span> parent.getDisplay();  <span class="hljs-comment">// 获取 Display</span><br><br>    shell = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shell</span>(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);  <span class="hljs-comment">// 创建一个新的 Shell 对象，并设置样式</span><br>    props.setLook(shell);  <span class="hljs-comment">// 设置外观</span><br><br>    <span class="hljs-comment">// 监听文本框修改事件</span><br>    <span class="hljs-type">ModifyListener</span> <span class="hljs-variable">lsMod</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModifyListener</span>() &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyText</span><span class="hljs-params">(ModifyEvent e)</span> &#123;<br>            input.setChanged();<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 监听焦点丢失事件</span><br>    <span class="hljs-type">FocusListener</span> <span class="hljs-variable">lsFocusLost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FocusAdapter</span>() &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">focusLost</span><span class="hljs-params">(FocusEvent arg0)</span> &#123;<br>            setTableFieldCombo();<br>        &#125;<br>    &#125;;<br><br>    changed = input.hasChanged();  <span class="hljs-comment">// 判断输入是否有更改</span><br><br>    <span class="hljs-type">FormLayout</span> <span class="hljs-variable">formLayout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormLayout</span>();  <span class="hljs-comment">// 创建表单布局</span><br>    formLayout.marginWidth = Const.FORM_MARGIN;<br>    formLayout.marginHeight = Const.FORM_MARGIN;<br><br>    shell.setLayout(formLayout);  <span class="hljs-comment">// 设置 Shell 的布局</span><br>    shell.setText(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.Shell.Title&quot;</span>));  <span class="hljs-comment">// 设置 Shell 的标题</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> props.getMiddlePct();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">margin</span> <span class="hljs-operator">=</span> Const.MARGIN;<br><br>    <span class="hljs-comment">// Stepname line</span><br>    wlStepname = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Label</span>(shell, SWT.RIGHT);<br>    wlStepname.setText(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.Stepname.Label&quot;</span>));<br>    props.setLook(wlStepname);<br>    fdlStepname = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();<br>    fdlStepname.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormAttachment</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    fdlStepname.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormAttachment</span>(middle, -margin);<br>    fdlStepname.top = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormAttachment</span>(<span class="hljs-number">0</span>, margin);<br>    wlStepname.setLayoutData(fdlStepname);<br>    wStepname = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);<br>    wStepname.setText(stepname);<br>    props.setLook(wStepname);<br>    wStepname.addModifyListener(lsMod);<br>    fdStepname = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();<br>    fdStepname.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormAttachment</span>(middle, <span class="hljs-number">0</span>);<br>    fdStepname.top = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormAttachment</span>(<span class="hljs-number">0</span>, margin);<br>    fdStepname.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormAttachment</span>(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>);<br>    wStepname.setLayoutData(fdStepname);<br><br>    <span class="hljs-comment">// 其他控件的创建和布局类似，这里省略...</span><br>    <span class="hljs-comment">// ...</span><br><br>    shell.open();  <span class="hljs-comment">// 打开 Shell 对话框</span><br>    <span class="hljs-keyword">while</span> (!shell.isDisposed()) &#123;<br>        <span class="hljs-keyword">if</span> (!display.readAndDispatch()) &#123;<br>            display.sleep();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stepname;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="generatemappings">generateMappings</h3><p>用于生成映射关系。这段代码的作用是在MySQL BulkLoader对话框中生成字段的源到目标映射关系。它首先获取源字段和目标字段的元数据，然后检查是否存在缺失的字段，并显示确认对话框。接下来，它弹出一个映射对话框，允许用户输入或编辑映射关系。最后，根据用户输入的映射关系更新界面显示。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateMappings</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 获取源字段和目标字段...</span><br>    <span class="hljs-comment">//</span><br>    RowMetaInterface sourceFields;  <span class="hljs-comment">// 源字段的元数据接口</span><br>    RowMetaInterface targetFields;  <span class="hljs-comment">// 目标字段的元数据接口</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>      sourceFields = transMeta.getPrevStepFields( stepMeta );  <span class="hljs-comment">// 获取前一个步骤的字段信息</span><br>    &#125; <span class="hljs-keyword">catch</span> ( KettleException e ) &#123;<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">ErrorDialog</span>( shell,<br>        BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.DoMapping.UnableToFindSourceFields.Title&quot;</span> ),<br>        BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.DoMapping.UnableToFindSourceFields.Message&quot;</span> ), e );<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 刷新数据</span><br>    input.setDatabaseMeta( transMeta.findDatabase( wConnection.getText() ) );  <span class="hljs-comment">// 设置输入的数据库连接信息</span><br>    input.setTableName( transMeta.environmentSubstitute( wTable.getText() ) );  <span class="hljs-comment">// 设置输入的表名</span><br>    <span class="hljs-type">StepMetaInterface</span> <span class="hljs-variable">stepMetaInterface</span> <span class="hljs-operator">=</span> stepMeta.getStepMetaInterface();<br>    <span class="hljs-keyword">try</span> &#123;<br>      targetFields = stepMetaInterface.getRequiredFields( transMeta );  <span class="hljs-comment">// 获取目标步骤需要的字段信息</span><br>    &#125; <span class="hljs-keyword">catch</span> ( KettleException e ) &#123;<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">ErrorDialog</span>( shell,<br>        BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.DoMapping.UnableToFindTargetFields.Title&quot;</span> ),<br>        BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.DoMapping.UnableToFindTargetFields.Message&quot;</span> ), e );<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    String[] inputNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[sourceFields.size()];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sourceFields.size(); i++ ) &#123;<br>      <span class="hljs-type">ValueMetaInterface</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> sourceFields.getValueMeta( i );<br>      inputNames[i] = value.getName() + EnterMappingDialog.STRING_ORIGIN_SEPARATOR + value.getOrigin() + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建现有的映射列表...</span><br>    <span class="hljs-comment">//</span><br>    List&lt;SourceToTargetMapping&gt; mappings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;SourceToTargetMapping&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">missingSourceFields</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">missingTargetFields</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nrFields</span> <span class="hljs-operator">=</span> wReturn.nrNonEmpty();<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nrFields; i++ ) &#123;<br>      <span class="hljs-type">TableItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> wReturn.getNonEmpty( i );<br>      <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> item.getText( <span class="hljs-number">2</span> );<br>      <span class="hljs-type">String</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> item.getText( <span class="hljs-number">1</span> );<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">sourceIndex</span> <span class="hljs-operator">=</span> sourceFields.indexOfValue( source );<br>      <span class="hljs-keyword">if</span> ( sourceIndex &lt; <span class="hljs-number">0</span> ) &#123;<br>        missingSourceFields.append( Const.CR ).append( <span class="hljs-string">&quot;   &quot;</span> ).append( source ).append( <span class="hljs-string">&quot; --&gt; &quot;</span> ).append( target );<br>      &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">targetIndex</span> <span class="hljs-operator">=</span> targetFields.indexOfValue( target );<br>      <span class="hljs-keyword">if</span> ( targetIndex &lt; <span class="hljs-number">0</span> ) &#123;<br>        missingTargetFields.append( Const.CR ).append( <span class="hljs-string">&quot;   &quot;</span> ).append( source ).append( <span class="hljs-string">&quot; --&gt; &quot;</span> ).append( target );<br>      &#125;<br>      <span class="hljs-keyword">if</span> ( sourceIndex &lt; <span class="hljs-number">0</span> || targetIndex &lt; <span class="hljs-number">0</span> ) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-type">SourceToTargetMapping</span> <span class="hljs-variable">mapping</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SourceToTargetMapping</span>( sourceIndex, targetIndex );<br>      mappings.add( mapping );<br>    &#125;<br><br>    <span class="hljs-comment">// 如果存在缺失字段，则显示确认对话框</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span> ( missingSourceFields.length() &gt; <span class="hljs-number">0</span> || missingTargetFields.length() &gt; <span class="hljs-number">0</span> ) &#123;<br><br>      <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-keyword">if</span> ( missingSourceFields.length() &gt; <span class="hljs-number">0</span> ) &#123;<br>        message +=<br>          BaseMessages.getString(<br>            PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.DoMapping.SomeSourceFieldsNotFound&quot;</span>, missingSourceFields.toString() )<br>            + Const.CR;<br>      &#125;<br>      <span class="hljs-keyword">if</span> ( missingTargetFields.length() &gt; <span class="hljs-number">0</span> ) &#123;<br>        message +=<br>          BaseMessages.getString(<br>            PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.DoMapping.SomeTargetFieldsNotFound&quot;</span>, missingSourceFields.toString() )<br>            + Const.CR;<br>      &#125;<br>      message += Const.CR;<br>      message +=<br>        BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.DoMapping.SomeFieldsNotFoundContinue&quot;</span> ) + Const.CR;<br>      MessageDialog.setDefaultImage( GUIResource.getInstance().getImageSpoon() );<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">goOn</span> <span class="hljs-operator">=</span><br>        MessageDialog.openConfirm( shell, BaseMessages.getString(<br>          PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.DoMapping.SomeFieldsNotFoundTitle&quot;</span> ), message );<br>      <span class="hljs-keyword">if</span> ( !goOn ) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">EnterMappingDialog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnterMappingDialog</span>( MySQLBulkLoaderDialog.<span class="hljs-built_in">this</span>.shell, sourceFields.getFieldNames(), targetFields<br>        .getFieldNames(), mappings );  <span class="hljs-comment">// 创建映射对话框</span><br>    mappings = d.open();<br><br>    <span class="hljs-comment">// 如果用户确认了映射对话框，则更新界面显示</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span> ( mappings != <span class="hljs-literal">null</span> ) &#123;<br>      <span class="hljs-comment">// 清除并重新填充列表</span><br>      <span class="hljs-comment">//</span><br>      wReturn.table.removeAll();<br>      wReturn.table.setItemCount( mappings.size() );<br>      <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings.size(); i++ ) &#123;<br>        <span class="hljs-type">SourceToTargetMapping</span> <span class="hljs-variable">mapping</span> <span class="hljs-operator">=</span> mappings.get( i );<br>        <span class="hljs-type">TableItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> wReturn.table.getItem( i );<br>        item.setText( <span class="hljs-number">2</span>, sourceFields.getValueMeta( mapping.getSourcePosition() ).getName() );<br>        item.setText( <span class="hljs-number">1</span>, targetFields.getValueMeta( mapping.getTargetPosition() ).getName() );<br>        item.setText( <span class="hljs-number">3</span>, MySQLBulkLoaderMeta.getFieldFormatTypeDescription( input.getFieldFormatType()[i] ) );<br>      &#125;<br>      wReturn.setRowNums();<br>      wReturn.optWidth( <span class="hljs-literal">true</span> );<br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><h3 id="getdata">getData</h3><p>用于获取MySQL Bulk Loader对话框中的数据并将其显示在界面上。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> ( log.isDebug() ) &#123;<br>      logDebug( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.Log.GettingKeyInfo&quot;</span> ) );<br>    &#125;<br><br>    wEnclosure.setText( Const.NVL( input.getEnclosure(), <span class="hljs-string">&quot;&quot;</span> ) );  <span class="hljs-comment">// 设置包围符文本框的内容</span><br>    wDelimiter.setText( Const.NVL( input.getDelimiter(), <span class="hljs-string">&quot;&quot;</span> ) );  <span class="hljs-comment">// 设置分隔符文本框的内容</span><br>    wEscapeChar.setText( Const.NVL( input.getEscapeChar(), <span class="hljs-string">&quot;&quot;</span> ) );  <span class="hljs-comment">// 设置转义字符文本框的内容</span><br>    wCharSet.setText( Const.NVL( input.getEncoding(), <span class="hljs-string">&quot;&quot;</span> ) );  <span class="hljs-comment">// 设置字符集文本框的内容</span><br>    wReplace.setSelection( input.isReplacingData() );  <span class="hljs-comment">// 设置替换数据复选框的选择状态</span><br>    wIgnore.setSelection( input.isIgnoringErrors() );  <span class="hljs-comment">// 设置忽略错误复选框的选择状态</span><br>    wLocal.setSelection( input.isLocalFile() );  <span class="hljs-comment">// 设置本地文件复选框的选择状态</span><br>    wBulkSize.setText( Const.NVL( input.getBulkSize(), <span class="hljs-string">&quot;&quot;</span> ) );  <span class="hljs-comment">// 设置批量大小文本框的内容</span><br><br>    <span class="hljs-keyword">if</span> ( input.getFieldTable() != <span class="hljs-literal">null</span> ) &#123;<br>      <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; input.getFieldTable().length; i++ ) &#123;<br>        <span class="hljs-type">TableItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> wReturn.table.getItem( i );<br>        <span class="hljs-keyword">if</span> ( input.getFieldTable()[i] != <span class="hljs-literal">null</span> ) &#123;<br>          item.setText( <span class="hljs-number">1</span>, input.getFieldTable()[i] );  <span class="hljs-comment">// 设置字段表格中第一列的内容</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> ( input.getFieldStream()[i] != <span class="hljs-literal">null</span> ) &#123;<br>          item.setText( <span class="hljs-number">2</span>, input.getFieldStream()[i] );  <span class="hljs-comment">// 设置字段表格中第二列的内容</span><br>        &#125;<br>        item.setText( <span class="hljs-number">3</span>, MySQLBulkLoaderMeta.getFieldFormatTypeDescription( input.getFieldFormatType()[i] ) );  <span class="hljs-comment">// 设置字段表格中第三列的内容</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ( input.getDatabaseMeta() != <span class="hljs-literal">null</span> ) &#123;<br>      wConnection.setText( input.getDatabaseMeta().getName() );  <span class="hljs-comment">// 设置数据库连接文本框的内容</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> ( transMeta.nrDatabases() == <span class="hljs-number">1</span> ) &#123;<br>        wConnection.setText( transMeta.getDatabase( <span class="hljs-number">0</span> ).getName() );  <span class="hljs-comment">// 设置数据库连接文本框的内容为唯一数据库的名称</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( input.getSchemaName() != <span class="hljs-literal">null</span> ) &#123;<br>      wSchema.setText( input.getSchemaName() );  <span class="hljs-comment">// 设置模式名文本框的内容</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> ( input.getTableName() != <span class="hljs-literal">null</span> ) &#123;<br>      wTable.setText( input.getTableName() );  <span class="hljs-comment">// 设置表名文本框的内容</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> ( input.getFifoFileName() != <span class="hljs-literal">null</span> ) &#123;<br>      wFifoFile.setText( input.getFifoFileName() );  <span class="hljs-comment">// 设置FIFO文件名文本框的内容</span><br>    &#125;<br><br>    wReturn.setRowNums();  <span class="hljs-comment">// 设置字段表格的行号</span><br>    wReturn.optWidth( <span class="hljs-literal">true</span> );  <span class="hljs-comment">// 调整字段表格的列宽</span><br><br>    wStepname.selectAll();  <span class="hljs-comment">// 选中步骤名称文本框的内容</span><br>    wStepname.setFocus();  <span class="hljs-comment">// 将焦点设置在步骤名称文本框中</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="setcomboboxes">setComboBoxes</h3><p>用于设置下拉列表框的选项。</p><p>代码的功能概述如下：</p><ol type="1"><li>创建一个<code>HashMap</code>对象<code>fields</code>，用于存储字段名称和对应的索引。</li><li>将输入字段<code>inputFields</code>中的字段添加到<code>fields</code>中。</li><li>获取<code>fields</code>中的键集合，并将其转换为<code>List</code>类型的<code>entries</code>。</li><li>将<code>entries</code>转换为数组<code>fieldNames</code>，并按字母顺序排序。</li><li>将排序后的<code>fieldNames</code>设置为下拉列表框的选项。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setComboBoxes</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Something was changed in the row.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">final</span> Map&lt;String, Integer&gt; fields = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Integer&gt;();  <span class="hljs-comment">// 创建一个存储字段名称和索引的哈希映射</span><br><br>    <span class="hljs-comment">// Add the currentMeta fields...</span><br>    fields.putAll( inputFields );  <span class="hljs-comment">// 将输入字段inputFields中的字段添加到fields中</span><br><br>    Set&lt;String&gt; keySet = fields.keySet();  <span class="hljs-comment">// 获取fields的键集合</span><br>    List&lt;String&gt; entries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;( keySet );  <span class="hljs-comment">// 将键集合转换为列表类型</span><br><br>    String[] fieldNames = entries.toArray( <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[entries.size()] );  <span class="hljs-comment">// 将列表转换为数组</span><br>    Const.sortStrings( fieldNames );  <span class="hljs-comment">// 按字母顺序排序数组</span><br>    <span class="hljs-comment">// return fields</span><br>    ciReturn[<span class="hljs-number">1</span>].setComboValues( fieldNames );  <span class="hljs-comment">// 设置下拉列表框的选项为排序后的字段数组</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="cancel">cancel</h3><p>用于取消操作。</p><p>代码的功能概述如下：</p><ol type="1"><li>将变量<code>stepname</code>设置为<code>null</code>，即取消当前步骤的名称。</li><li>将输入对象<code>input</code>的<code>changed</code>属性设置为<code>changed</code>变量的值，表示输入对象是否发生了改变。</li><li>释放资源，关闭对话框。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span> &#123;<br>    stepname = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 取消当前步骤的名称</span><br>    input.setChanged( changed );  <span class="hljs-comment">// 设置输入对象的changed属性，表示是否发生了改变</span><br>    dispose();  <span class="hljs-comment">// 释放资源，关闭对话框</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="getinfo">getInfo</h3><p>用于获取用户在对话框中输入的信息，并将其设置到给定的<code>MySQLBulkLoaderMeta</code>对象中。代码的功能概述如下：</p><ol type="1"><li>获取字段的数量<code>nrfields</code>。</li><li>根据字段数量分配<code>MySQLBulkLoaderMeta</code>对象的内存。</li><li>将用户在对话框中输入的各项信息设置到<code>inf</code>对象的对应属性中，包括封闭符号、分隔符、转义字符、编码方式、是否替换数据、是否忽略错误、是否使用本地文件、批量大小等。</li><li>遍历字段列表，将字段表、字段流和字段格式类型设置到<code>inf</code>对象的相应属性中。</li><li>设置模式名称、表名称、数据库连接元数据和FIFO文件名。</li><li>将步骤名称设置为<code>wStepname</code>文本框中的值。</li><li>返回步骤名称。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getInfo</span><span class="hljs-params">( MySQLBulkLoaderMeta inf )</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">nrfields</span> <span class="hljs-operator">=</span> wReturn.nrNonEmpty();  <span class="hljs-comment">// 获取字段的数量</span><br><br>    inf.allocate( nrfields );  <span class="hljs-comment">// 根据字段数量分配内存</span><br><br>    inf.setEnclosure( wEnclosure.getText() );  <span class="hljs-comment">// 设置封闭符号</span><br>    inf.setDelimiter( wDelimiter.getText() );  <span class="hljs-comment">// 设置分隔符</span><br>    inf.setEscapeChar( wEscapeChar.getText() );  <span class="hljs-comment">// 设置转义字符</span><br>    inf.setEncoding( wCharSet.getText() );  <span class="hljs-comment">// 设置编码方式</span><br>    inf.setReplacingData( wReplace.getSelection() );  <span class="hljs-comment">// 设置是否替换数据</span><br>    inf.setIgnoringErrors( wIgnore.getSelection() );  <span class="hljs-comment">// 设置是否忽略错误</span><br>    inf.setLocalFile( wLocal.getSelection() );  <span class="hljs-comment">// 设置是否使用本地文件</span><br>    inf.setBulkSize( wBulkSize.getText() );  <span class="hljs-comment">// 设置批量大小</span><br><br>    <span class="hljs-keyword">if</span> ( log.isDebug() ) &#123;<br>        logDebug( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.Log.FoundFields&quot;</span>, <span class="hljs-string">&quot;&quot;</span> + nrfields ) );<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历字段列表，设置字段表、字段流和字段格式类型</span><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nrfields; i++ ) &#123;<br>        <span class="hljs-type">TableItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> wReturn.getNonEmpty( i );<br>        inf.getFieldTable()[i] = item.getText( <span class="hljs-number">1</span> );<br>        inf.getFieldStream()[i] = item.getText( <span class="hljs-number">2</span> );<br>        inf.getFieldFormatType()[i] = MySQLBulkLoaderMeta.getFieldFormatType( item.getText( <span class="hljs-number">3</span> ) );<br>    &#125;<br><br>    inf.setSchemaName( wSchema.getText() );  <span class="hljs-comment">// 设置模式名称</span><br>    inf.setTableName( wTable.getText() );  <span class="hljs-comment">// 设置表名称</span><br>    inf.setDatabaseMeta( transMeta.findDatabase( wConnection.getText() ) );  <span class="hljs-comment">// 设置数据库连接元数据</span><br>    inf.setFifoFileName( wFifoFile.getText() );  <span class="hljs-comment">// 设置FIFO文件名</span><br><br>    stepname = wStepname.getText(); <span class="hljs-comment">// 返回步骤名称</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="ok">ok</h3><p>这段代码是一个私有方法<code>ok()</code>，用于在用户单击对话框中的"OK"按钮时执行的操作。代码的功能概述如下：</p><ol type="1"><li>检查步骤名称是否为空，如果为空，则直接返回。</li><li>将对话框中的信息设置到<code>input</code>对象中，调用了前面提到的<code>getInfo()</code>方法。</li><li>检查<code>input</code>对象中的数据库连接元数据是否为空，如果为空，则显示一个错误提示框。</li><li>关闭对话框。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ok</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> ( Utils.isEmpty( wStepname.getText() ) ) &#123;  <span class="hljs-comment">// 检查步骤名称是否为空</span><br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 如果为空，则直接返回</span><br>    &#125;<br><br>    <span class="hljs-comment">// 将对话框中的信息设置到input对象中</span><br>    getInfo( input );<br><br>    <span class="hljs-keyword">if</span> ( input.getDatabaseMeta() == <span class="hljs-literal">null</span> ) &#123;  <span class="hljs-comment">// 检查数据库连接元数据是否为空</span><br>        <span class="hljs-type">MessageBox</span> <span class="hljs-variable">mb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageBox</span>( shell, SWT.OK | SWT.ICON_ERROR );<br>        mb.setMessage( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.InvalidConnection.DialogMessage&quot;</span> ) );<br>        mb.setText( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.InvalidConnection.DialogTitle&quot;</span> ) );<br>        mb.open();  <span class="hljs-comment">// 显示错误提示框</span><br>    &#125;<br><br>    dispose();  <span class="hljs-comment">// 关闭对话框</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="gettablename">getTableName</h3><p>用于获取数据库中的表名。代码的功能概述如下：</p><ol type="1"><li>根据用户选择的数据库连接，获取相应的数据库元数据对象。</li><li>如果数据库元数据对象不为空，则打开一个数据库浏览器对话框，让用户选择表名和模式名。</li><li>如果用户在数据库浏览器对话框中进行了选择并确认，则将选择的模式名和表名设置到相应的文本框中。</li><li>如果数据库元数据对象为空，则显示一个错误提示框。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getTableName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">DatabaseMeta</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 数据库元数据对象</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">connr</span> <span class="hljs-operator">=</span> wConnection.getSelectionIndex();  <span class="hljs-comment">// 获取用户选择的数据库连接索引</span><br>    <span class="hljs-keyword">if</span> ( connr &gt;= <span class="hljs-number">0</span> ) &#123;<br>        inf = transMeta.getDatabase( connr );  <span class="hljs-comment">// 根据索引获取数据库元数据对象</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ( inf != <span class="hljs-literal">null</span> ) &#123;  <span class="hljs-comment">// 如果数据库元数据对象不为空</span><br>        <span class="hljs-keyword">if</span> ( log.isDebug() ) &#123;<br>            logDebug( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.Log.LookingAtConnection&quot;</span> ) + inf.toString() );<br>        &#125;<br><br>        <span class="hljs-comment">// 打开一个数据库浏览器对话框</span><br>        <span class="hljs-type">DatabaseExplorerDialog</span> <span class="hljs-variable">std</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatabaseExplorerDialog</span>( shell, SWT.NONE, inf, transMeta.getDatabases() );<br>        std.setSelectedSchemaAndTable( wSchema.getText(), wTable.getText() );  <span class="hljs-comment">// 设置已选的模式名和表名</span><br>        <span class="hljs-keyword">if</span> ( std.open() ) &#123;  <span class="hljs-comment">// 用户确认选择</span><br>            wSchema.setText( Const.NVL( std.getSchemaName(), <span class="hljs-string">&quot;&quot;</span> ) );  <span class="hljs-comment">// 将选择的模式名设置到文本框</span><br>            wTable.setText( Const.NVL( std.getTableName(), <span class="hljs-string">&quot;&quot;</span> ) );  <span class="hljs-comment">// 将选择的表名设置到文本框</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">MessageBox</span> <span class="hljs-variable">mb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageBox</span>( shell, SWT.OK | SWT.ICON_ERROR );<br>        mb.setMessage( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.InvalidConnection.DialogMessage&quot;</span> ) );<br>        mb.setText( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.InvalidConnection.DialogTitle&quot;</span> ) );<br>        mb.open();  <span class="hljs-comment">// 显示错误提示框</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="getupdate">getUpdate</h3><p>用于获取更新字段的相关信息。代码的功能概述如下：</p><ol type="1"><li>尝试获取前一步骤（previous step）的字段信息。</li><li>如果字段信息不为空，则创建一个<code>TableItemInsertListener</code>监听器，并在表格中插入字段信息。</li><li>如果字段类型为日期类型，则将对应的表格项设置为"Y"，否则也将其设置为"Y"。</li><li>使用<code>BaseStepDialog.getFieldsFromPrevious()</code>方法将前一步骤的字段信息填充到表格中。</li><li>如果获取字段信息时发生异常，则显示一个错误对话框。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUpdate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">RowMetaInterface</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> transMeta.getPrevStepFields( stepname );  <span class="hljs-comment">// 获取前一步骤的字段信息</span><br>        <span class="hljs-keyword">if</span> ( r != <span class="hljs-literal">null</span> ) &#123;  <span class="hljs-comment">// 如果字段信息不为空</span><br>            <span class="hljs-type">TableItemInsertListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TableItemInsertListener</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tableItemInserted</span><span class="hljs-params">( TableItem tableItem, ValueMetaInterface v )</span> &#123;<br>                    <span class="hljs-keyword">if</span> ( v.getType() == ValueMetaInterface.TYPE_DATE ) &#123;  <span class="hljs-comment">// 如果字段类型是日期类型</span><br>                        <span class="hljs-comment">// 默认值是：日期格式正确，后续可能更改...</span><br>                        tableItem.setText( <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Y&quot;</span> );  <span class="hljs-comment">// 将表格项的第三列设置为&quot;Y&quot;</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        tableItem.setText( <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Y&quot;</span> );  <span class="hljs-comment">// 默认值也是正确的...</span><br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;;<br>            BaseStepDialog.getFieldsFromPrevious( r, wReturn, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;&#125;, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, listener );  <span class="hljs-comment">// 将字段信息填充到表格中</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> ( KettleException ke ) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ErrorDialog</span>(<br>            shell, BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.FailedToGetFields.DialogTitle&quot;</span> ),<br>            BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.FailedToGetFields.DialogMessage&quot;</span> ), ke );  <span class="hljs-comment">// 显示错误对话框</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="create">create</h3><p>用于创建步骤和生成SQL语句。代码的功能概述如下：</p><ol type="1"><li>创建一个<code>MySQLBulkLoaderMeta</code>对象并调用<code>getInfo()</code>方法获取用户输入的信息并存入该对象。</li><li>根据步骤名称、步骤描述和上一步骤的字段信息创建一个<code>StepMeta</code>对象。</li><li>获取前一步骤的字段信息。</li><li>调用<code>info.getSQLStatements()</code>方法生成SQL语句对象<code>sql</code>，该方法将使用步骤信息、前一步骤的字段信息、资源库和元数据存储库等进行处理。</li><li>如果生成SQL语句过程中没有错误，则判断是否存在SQL语句。<ul><li>如果存在SQL语句，创建一个<code>SQLEditor</code>对象并打开SQL编辑器窗口，显示生成的SQL语句供用户查看和编辑。</li><li>如果不存在SQL语句，显示一个信息对话框，提示用户不需要生成SQL语句。</li></ul></li><li>如果生成SQL语句过程中存在错误，显示一个错误对话框，显示错误信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">MySQLBulkLoaderMeta</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySQLBulkLoaderMeta</span>();  <span class="hljs-comment">// 创建MySQLBulkLoaderMeta对象</span><br>        getInfo( info );  <span class="hljs-comment">// 获取用户输入的信息并存入对象中</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stepname;  <span class="hljs-comment">// 新名称可能尚未与其他步骤关联！</span><br>        <span class="hljs-type">StepMeta</span> <span class="hljs-variable">stepMeta</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StepMeta</span>(<br>            BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.StepMeta.Title&quot;</span> ), name, info );  <span class="hljs-comment">// 创建StepMeta对象</span><br>        <span class="hljs-type">RowMetaInterface</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> transMeta.getPrevStepFields( stepname );  <span class="hljs-comment">// 获取前一步骤的字段信息</span><br><br>        <span class="hljs-type">SQLStatement</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> info.getSQLStatements( transMeta, stepMeta, prev, repository, metaStore );  <span class="hljs-comment">// 生成SQL语句对象</span><br>        <span class="hljs-keyword">if</span> ( !sql.hasError() ) &#123;  <span class="hljs-comment">// 如果生成SQL语句过程中没有错误</span><br>            <span class="hljs-keyword">if</span> ( sql.hasSQL() ) &#123;  <span class="hljs-comment">// 如果存在SQL语句</span><br>                <span class="hljs-type">SQLEditor</span> <span class="hljs-variable">sqledit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLEditor</span>(<br>                    transMeta, shell, SWT.NONE, info.getDatabaseMeta(), transMeta.getDbCache(), sql.getSQL() );  <span class="hljs-comment">// 创建SQLEditor对象</span><br>                sqledit.open();  <span class="hljs-comment">// 打开SQL编辑器窗口</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果不存在SQL语句</span><br>                <span class="hljs-type">MessageBox</span> <span class="hljs-variable">mb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageBox</span>( shell, SWT.OK | SWT.ICON_INFORMATION );<br>                mb.setMessage( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.NoSQLNeeds.DialogMessage&quot;</span> ) );<br>                mb.setText( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.NoSQLNeeds.DialogTitle&quot;</span> ) );<br>                mb.open();  <span class="hljs-comment">// 显示信息对话框，提示不需要生成SQL语句</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果生成SQL语句过程中存在错误</span><br>            <span class="hljs-type">MessageBox</span> <span class="hljs-variable">mb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageBox</span>( shell, SWT.OK | SWT.ICON_ERROR );<br>            mb.setMessage( sql.getError() );<br>            mb.setText( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.SQLError.DialogTitle&quot;</span> ) );<br>            mb.open();  <span class="hljs-comment">// 显示错误对话框，显示错误信息</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> ( KettleException ke ) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ErrorDialog</span>(<br>            shell, BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.CouldNotBuildSQL.DialogTitle&quot;</span> ),<br>            BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderDialog.CouldNotBuildSQL.DialogMessage&quot;</span> ), ke );  <span class="hljs-comment">// 显示错误对话框</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="settablefieldcombo">setTableFieldCombo</h3><p>用于设置表字段的下拉列表。代码的功能概述如下：</p><ol type="1"><li>创建一个<code>Runnable</code>对象<code>fieldLoader</code>，其中包含了在后台线程中执行的代码块。</li><li>在<code>fieldLoader</code>的<code>run()</code>方法中，首先判断界面上的表格、连接和模式是否已经被销毁。</li><li>获取表格名称、连接名称和模式名称。</li><li>清空所有表字段列的下拉列表。</li><li>如果表格名称不为空，根据连接名称找到相应的数据库连接对象。</li><li>创建一个数据库对象，并尝试连接数据库。</li><li>构建模式和表格的组合名称。</li><li>通过数据库对象获取表格的字段信息。</li><li>如果字段信息不为空，将字段名称设置为表字段列的下拉列表的值。</li><li>在异常处理中，清空所有表字段列的下拉列表，并忽略任何错误。这样下拉列表将不会被填充，但不会对用户造成问题。</li><li>最后，尝试断开数据库连接，并在异常处理中忽略任何错误。</li><li>在主线程中异步执行<code>fieldLoader</code>，即在后台线程中加载表字段信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTableFieldCombo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">fieldLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!wTable.isDisposed() &amp;&amp; !wConnection.isDisposed() &amp;&amp; !wSchema.isDisposed()) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> wTable.getText(), connectionName = wConnection.getText(), schemaName =<br>                        wSchema.getText();<br><br>                <span class="hljs-comment">// 清空下拉列表</span><br>                <span class="hljs-keyword">for</span> (ColumnInfo colInfo : tableFieldColumns) &#123;<br>                    colInfo.setComboValues(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;&#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!Utils.isEmpty(tableName)) &#123;<br>                    <span class="hljs-type">DatabaseMeta</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> transMeta.findDatabase(connectionName);<br>                    <span class="hljs-keyword">if</span> (ci != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">Database</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Database</span>(loggingObject, ci);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            db.connect();<br><br>                            <span class="hljs-type">String</span> <span class="hljs-variable">schemaTable</span> <span class="hljs-operator">=</span><br>                                    ci.getQuotedSchemaTableCombination(transMeta.environmentSubstitute(schemaName), transMeta<br>                                            .environmentSubstitute(tableName));<br>                            <span class="hljs-type">RowMetaInterface</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> db.getTableFields(schemaTable);<br>                            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != r) &#123;<br>                                String[] fieldNames = r.getFieldNames();<br>                                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != fieldNames) &#123;<br>                                    <span class="hljs-keyword">for</span> (ColumnInfo colInfo : tableFieldColumns) &#123;<br>                                        colInfo.setComboValues(fieldNames);<br>                                    &#125;<br>                                &#125;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                            <span class="hljs-keyword">for</span> (ColumnInfo colInfo : tableFieldColumns) &#123;<br>                                colInfo.setComboValues(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;&#125;);<br>                            &#125;<br>                            <span class="hljs-comment">// 忽略此处的任何错误。下拉列表将不会被填充，但不会对用户造成问题</span><br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-keyword">if</span> (db != <span class="hljs-literal">null</span>) &#123;<br>                                    db.disconnect();<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>                                <span class="hljs-comment">// 忽略此处的任何错误</span><br>                                db = <span class="hljs-literal">null</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;;<br>    shell.getDisplay().asyncExec(fieldLoader);  <span class="hljs-comment">// 在主线程中异步执行fieldLoader</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开源之夏2023</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kettle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql-bulk-loader之MySQLBulkLoaderMeta</title>
    <link href="/post/91bdb779.html"/>
    <url>/post/91bdb779.html</url>
    
    <content type="html"><![CDATA[<h1id="mysql-bulk-loader之mysqlbulkloadermeta">mysql-bulk-loader之MySQLBulkLoaderMeta</h1><p>前情提要：</p><p>Kettle组件就是一个step，它有四个类构建而成，每个类职责不同，各司其职。</p><span id="more"></span><ul><li>BaseStep:step类，实现了StepInterface接口，它是每个组件实际的业务处理类，组件的功能在这个类里实现。</li><li>BaseStepMeta:step元数据类，实现了StepMetaInterface接口，它的职责是保存和序列化组件的配置。</li><li>BaseStepData:step数据类，实现了StepDataInterface接口，用于存放每个组件在执行过程中的数据。</li><li>BaseStepDialog:step界面类，实现了StepDialogInterface接口，实现组件和用户进行交互的界面，提供一个对组件进行配置的界面。</li></ul><h2 id="mysqlbulkloadermeta">MySQLBulkLoaderMeta</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Step( id = &quot;MySQLBulkLoader&quot;, name = &quot;BaseStep.TypeLongDesc.MySQLBulkLoader&quot;,</span><br><span class="hljs-meta">  description = &quot;BaseStep.TypeTooltipDesc.MySQLBulkLoader&quot;,</span><br><span class="hljs-meta">  categoryDescription = &quot;i18n:org.pentaho.di.trans.step:BaseStep.Category.Bulk&quot;,</span><br><span class="hljs-meta">  image = &quot;BLKMYSQL.svg&quot;,</span><br><span class="hljs-meta">  documentationUrl = &quot;http://wiki.pentaho.com/display/EAI/MySQL+Bulk+Loader&quot;,</span><br><span class="hljs-meta">  i18nPackageName = &quot;org.pentaho.di.trans.steps.mysqlbulkloader&quot; )</span><br><span class="hljs-meta">@InjectionSupported( localizationPrefix = &quot;MySQLBulkLoader.Injection.&quot;, groups = &#123; &quot;FIELDS&quot; &#125; )</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySQLBulkLoaderMeta</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseStepMeta</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StepMetaInterface</span>,<br>    ProvidesDatabaseConnectionInformation &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; PKG = MySQLBulkLoaderMeta.class; <span class="hljs-comment">// 用于国际化目的，Translator2 需要这个变量</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FIELD_FORMAT_TYPE_OK</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FIELD_FORMAT_TYPE_DATE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FIELD_FORMAT_TYPE_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FIELD_FORMAT_TYPE_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FIELD_FORMAT_TYPE_STRING_ESCAPE</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] fieldFormatTypeCodes = &#123; <span class="hljs-string">&quot;OK&quot;</span>, <span class="hljs-string">&quot;DATE&quot;</span>, <span class="hljs-string">&quot;TIMESTAMP&quot;</span>, <span class="hljs-string">&quot;NUMBER&quot;</span>, <span class="hljs-string">&quot;STRING_ESC&quot;</span> &#125;;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] fieldFormatTypeDescriptions = &#123;<br>    BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.FieldFormatType.OK.Description&quot;</span> ),<br>    BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.FieldFormatType.Date.Description&quot;</span> ),<br>    BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.FieldFormatType.Timestamp.Description&quot;</span> ),<br>    BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.FieldFormatType.Number.Description&quot;</span> ),<br>    BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.FieldFormatType.StringEscape.Description&quot;</span> )<br>  &#125;;<br><br>  <span class="hljs-comment">/** 目标表的模式 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;SCHEMA_NAME&quot; )</span><br>  <span class="hljs-keyword">private</span> String schemaName;<br><br>  <span class="hljs-comment">/** 目标表的名称 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;TABLE_NAME&quot; )</span><br>  <span class="hljs-keyword">private</span> String tableName;<br><br>  <span class="hljs-comment">/** 要创建的 FIFO 文件的名称 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;FIFO_FILE&quot; )</span><br>  <span class="hljs-keyword">private</span> String fifoFileName;<br><br>  <span class="hljs-comment">/** 数据库连接 */</span><br>  <span class="hljs-keyword">private</span> DatabaseMeta databaseMeta;<br><br>  <span class="hljs-comment">/** 目标表中的字段名 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;FIELD_TABLE&quot;, group = &quot;FIELDS&quot; )</span><br>  <span class="hljs-keyword">private</span> String[] fieldTable;<br><br>  <span class="hljs-comment">/** 流中的字段名 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;FIELD_STREAM&quot;, group = &quot;FIELDS&quot; )</span><br>  <span class="hljs-keyword">private</span> String[] fieldStream;<br><br>  <span class="hljs-comment">/** 标志，指示对格式化进行什么操作 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;FIELD_FORMAT&quot;, group = &quot;FIELDS&quot;, converter = FieldFormatTypeConverter.class )</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] fieldFormatType;<br><br>  <span class="hljs-comment">/** 使用的编码 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;ENCODING&quot; )</span><br>  <span class="hljs-keyword">private</span> String encoding;<br><br>  <span class="hljs-comment">/** REPLACE 子句标志 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;USE_REPLACE_CLAUSE&quot; )</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> replacingData;<br><br>  <span class="hljs-comment">/** IGNORE 子句标志 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;USE_IGNORE_CLAUSE&quot; )</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> ignoringErrors;<br><br>  <span class="hljs-comment">/** 允许指定 LOCAL 子句 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;LOCAL_FILE&quot; )</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> localFile;<br><br>  <span class="hljs-comment">/** 要使用的分隔符 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;DELIMITER&quot; )</span><br>  <span class="hljs-keyword">private</span> String delimiter;<br><br>  <span class="hljs-comment">/** 要使用的封闭符号 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;ENCLOSURE&quot; )</span><br>  <span class="hljs-keyword">private</span> String enclosure;<br><br>  <span class="hljs-comment">/** 转义字符 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;ESCAPE_CHAR&quot; )</span><br>  <span class="hljs-keyword">private</span> String escapeChar;<br><br>  <span class="hljs-comment">/** 每个批量语句加载的行数 */</span><br>  <span class="hljs-meta">@Injection( name = &quot;BULK_SIZE&quot; )</span><br>  <span class="hljs-keyword">private</span> String bulkSize;<br>        <br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 此处省略若干get和set方法</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="readdata">readData</h3><p>用于从 XML 节点中读取数据并初始化对象的属性。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readData</span><span class="hljs-params">( Node stepnode, List&lt;? extends SharedObjectInterface&gt; databases )</span> <span class="hljs-keyword">throws</span> KettleXMLException &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;connection&quot;</span> );<br>    databaseMeta = DatabaseMeta.findDatabase( databases, con ); <span class="hljs-comment">// 从数据库列表中查找指定的数据库连接</span><br><br>    schemaName = XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;schema&quot;</span> ); <span class="hljs-comment">// 读取目标表的模式</span><br>    tableName = XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;table&quot;</span> ); <span class="hljs-comment">// 读取目标表的名称</span><br><br>    fifoFileName = XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;fifo_file_name&quot;</span> ); <span class="hljs-comment">// 读取 FIFO 文件的名称</span><br><br>    encoding = XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;encoding&quot;</span> ); <span class="hljs-comment">// 读取编码方式</span><br>    enclosure = XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;enclosure&quot;</span> ); <span class="hljs-comment">// 读取封闭符号</span><br>    delimiter = XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;delimiter&quot;</span> ); <span class="hljs-comment">// 读取分隔符</span><br>    escapeChar = XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;escape_char&quot;</span> ); <span class="hljs-comment">// 读取转义字符</span><br><br>    bulkSize = XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;bulk_size&quot;</span> ); <span class="hljs-comment">// 读取每个批量语句加载的行数</span><br><br>    replacingData = <span class="hljs-string">&quot;Y&quot;</span>.equalsIgnoreCase( XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;replace&quot;</span> ) ); <span class="hljs-comment">// 读取是否使用 REPLACE 子句</span><br>    ignoringErrors = <span class="hljs-string">&quot;Y&quot;</span>.equalsIgnoreCase( XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;ignore&quot;</span> ) ); <span class="hljs-comment">// 读取是否使用 IGNORE 子句</span><br>    localFile = <span class="hljs-string">&quot;Y&quot;</span>.equalsIgnoreCase( XMLHandler.getTagValue( stepnode, <span class="hljs-string">&quot;local&quot;</span> ) ); <span class="hljs-comment">// 读取是否允许使用 LOCAL 子句</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nrvalues</span> <span class="hljs-operator">=</span> XMLHandler.countNodes( stepnode, <span class="hljs-string">&quot;mapping&quot;</span> ); <span class="hljs-comment">// 读取字段映射节点的数量</span><br>    allocate( nrvalues ); <span class="hljs-comment">// 根据节点数量分配数组大小</span><br><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nrvalues; i++ ) &#123;<br>      <span class="hljs-type">Node</span> <span class="hljs-variable">vnode</span> <span class="hljs-operator">=</span> XMLHandler.getSubNodeByNr( stepnode, <span class="hljs-string">&quot;mapping&quot;</span>, i ); <span class="hljs-comment">// 获取字段映射节点</span><br><br>      fieldTable[i] = XMLHandler.getTagValue( vnode, <span class="hljs-string">&quot;stream_name&quot;</span> ); <span class="hljs-comment">// 读取流中的字段名称</span><br>      fieldStream[i] = XMLHandler.getTagValue( vnode, <span class="hljs-string">&quot;field_name&quot;</span> ); <span class="hljs-comment">// 读取目标表中的字段名称</span><br>      <span class="hljs-keyword">if</span> ( fieldStream[i] == <span class="hljs-literal">null</span> ) &#123;<br>        fieldStream[i] = fieldTable[i]; <span class="hljs-comment">// 默认情况下，使用相同的字段名称</span><br>      &#125;<br>      fieldFormatType[i] = getFieldFormatType( XMLHandler.getTagValue( vnode, <span class="hljs-string">&quot;field_format_ok&quot;</span> ) ); <span class="hljs-comment">// 读取字段的格式化类型</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> ( Exception e ) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleXMLException</span>( BaseMessages.getString( PKG,<br>        <span class="hljs-string">&quot;MySQLBulkLoaderMeta.Exception.UnableToReadStepInfoFromXML&quot;</span> ), e );<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="readrep">readRep</h3><p>用于从资源库中读取数据并初始化对象的属性。该方法通过使用资源库的相关方法，从资源库中获取MySQL Bulk Loader步骤的配置信息，包括数据库连接、目标表信息、字段映射关系、格式化选项等。通过读取资源库中的属性值，并将其存储到对应的对象属性中，完成对象的初始化。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readRep</span><span class="hljs-params">( Repository rep, IMetaStore metaStore, ObjectId id_step, List&lt;DatabaseMeta&gt; databases )</span><br>    <span class="hljs-keyword">throws</span> KettleException &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    databaseMeta = rep.loadDatabaseMetaFromStepAttribute( id_step, <span class="hljs-string">&quot;id_connection&quot;</span>, databases ); <span class="hljs-comment">// 从资源库加载数据库连接信息</span><br><br>    schemaName = rep.getStepAttributeString( id_step, <span class="hljs-string">&quot;schema&quot;</span> ); <span class="hljs-comment">// 从资源库中获取模式名称</span><br>    tableName = rep.getStepAttributeString( id_step, <span class="hljs-string">&quot;table&quot;</span> ); <span class="hljs-comment">// 从资源库中获取表名称</span><br><br>    encoding = rep.getStepAttributeString( id_step, <span class="hljs-string">&quot;encoding&quot;</span> ); <span class="hljs-comment">// 从资源库中获取编码方式</span><br>    enclosure = rep.getStepAttributeString( id_step, <span class="hljs-string">&quot;enclosure&quot;</span> ); <span class="hljs-comment">// 从资源库中获取封闭符号</span><br>    delimiter = rep.getStepAttributeString( id_step, <span class="hljs-string">&quot;delimiter&quot;</span> ); <span class="hljs-comment">// 从资源库中获取分隔符</span><br>    escapeChar = rep.getStepAttributeString( id_step, <span class="hljs-string">&quot;escape_char&quot;</span> ); <span class="hljs-comment">// 从资源库中获取转义字符</span><br><br>    fifoFileName = rep.getStepAttributeString( id_step, <span class="hljs-string">&quot;fifo_file_name&quot;</span> ); <span class="hljs-comment">// 从资源库中获取 FIFO 文件名</span><br><br>    replacingData = rep.getStepAttributeBoolean( id_step, <span class="hljs-string">&quot;replace&quot;</span> ); <span class="hljs-comment">// 从资源库中获取是否使用 REPLACE 子句</span><br>    ignoringErrors = rep.getStepAttributeBoolean( id_step, <span class="hljs-string">&quot;ignore&quot;</span> ); <span class="hljs-comment">// 从资源库中获取是否使用 IGNORE 子句</span><br>    localFile = rep.getStepAttributeBoolean( id_step, <span class="hljs-string">&quot;local&quot;</span> ); <span class="hljs-comment">// 从资源库中获取是否允许使用 LOCAL 子句</span><br><br>    bulkSize = rep.getStepAttributeString( id_step, <span class="hljs-string">&quot;bulk_size&quot;</span> ); <span class="hljs-comment">// 从资源库中获取每个批量语句加载的行数</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nrvalues</span> <span class="hljs-operator">=</span> rep.countNrStepAttributes( id_step, <span class="hljs-string">&quot;stream_name&quot;</span> ); <span class="hljs-comment">// 获取字段映射节点的数量</span><br><br>    allocate( nrvalues ); <span class="hljs-comment">// 根据节点数量分配数组大小</span><br><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nrvalues; i++ ) &#123;<br>      fieldTable[i] = rep.getStepAttributeString( id_step, i, <span class="hljs-string">&quot;stream_name&quot;</span> ); <span class="hljs-comment">// 从资源库中获取流中的字段名称</span><br>      fieldStream[i] = rep.getStepAttributeString( id_step, i, <span class="hljs-string">&quot;field_name&quot;</span> ); <span class="hljs-comment">// 从资源库中获取目标表中的字段名称</span><br>      <span class="hljs-keyword">if</span> ( fieldStream[i] == <span class="hljs-literal">null</span> ) &#123;<br>        fieldStream[i] = fieldTable[i]; <span class="hljs-comment">// 默认情况下，使用相同的字段名称</span><br>      &#125;<br>      fieldFormatType[i] = getFieldFormatType( rep.getStepAttributeString( id_step, i, <span class="hljs-string">&quot;field_format_ok&quot;</span> ) ); <span class="hljs-comment">// 获取字段的格式化类型</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> ( Exception e ) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>( BaseMessages.getString( PKG,<br>        <span class="hljs-string">&quot;MySQLBulkLoaderMeta.Exception.UnexpectedErrorReadingStepInfoFromRepository&quot;</span> ), e );<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="saverep">saveRep</h3><p>用于将对象的属性值保存到资源库中。该方法使用资源库的相关方法，将MySQL Bulk Loader步骤的属性值保存到资源库中。包括数据库连接、目标表信息、字段映射关系、格式化选项等。同时还保存步骤与数据库之间的关联。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveRep</span><span class="hljs-params">( Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step )</span><br>    <span class="hljs-keyword">throws</span> KettleException &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    rep.saveDatabaseMetaStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;id_connection&quot;</span>, databaseMeta ); <span class="hljs-comment">// 保存数据库连接信息到资源库</span><br><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;schema&quot;</span>, schemaName ); <span class="hljs-comment">// 保存模式名称到资源库</span><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;table&quot;</span>, tableName ); <span class="hljs-comment">// 保存表名称到资源库</span><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;encoding&quot;</span>, encoding ); <span class="hljs-comment">// 保存编码方式到资源库</span><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;enclosure&quot;</span>, enclosure ); <span class="hljs-comment">// 保存封闭符号到资源库</span><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;delimiter&quot;</span>, delimiter ); <span class="hljs-comment">// 保存分隔符到资源库</span><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;escape_char&quot;</span>, escapeChar ); <span class="hljs-comment">// 保存转义字符到资源库</span><br><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;fifo_file_name&quot;</span>, fifoFileName ); <span class="hljs-comment">// 保存 FIFO 文件名到资源库</span><br><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;replace&quot;</span>, replacingData ); <span class="hljs-comment">// 保存是否使用 REPLACE 子句到资源库</span><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;ignore&quot;</span>, ignoringErrors ); <span class="hljs-comment">// 保存是否使用 IGNORE 子句到资源库</span><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;local&quot;</span>, localFile ); <span class="hljs-comment">// 保存是否允许使用 LOCAL 子句到资源库</span><br><br>    rep.saveStepAttribute( id_transformation, id_step, <span class="hljs-string">&quot;bulk_size&quot;</span>, bulkSize ); <span class="hljs-comment">// 保存每个批量语句加载的行数到资源库</span><br><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fieldTable.length; i++ ) &#123;<br>      rep.saveStepAttribute( id_transformation, id_step, i, <span class="hljs-string">&quot;stream_name&quot;</span>, fieldTable[i] ); <span class="hljs-comment">// 保存流中的字段名称到资源库</span><br>      rep.saveStepAttribute( id_transformation, id_step, i, <span class="hljs-string">&quot;field_name&quot;</span>, fieldStream[i] ); <span class="hljs-comment">// 保存目标表中的字段名称到资源库</span><br>      rep.saveStepAttribute( id_transformation, id_step, i, <span class="hljs-string">&quot;field_format_ok&quot;</span>,<br>          getFieldFormatTypeCode( fieldFormatType[i] ) ); <span class="hljs-comment">// 保存字段的格式化类型到资源库</span><br>    &#125;<br><br>    <span class="hljs-comment">// 还要保存步骤与数据库之间的关系！</span><br>    <span class="hljs-keyword">if</span> ( databaseMeta != <span class="hljs-literal">null</span> ) &#123;<br>      rep.insertStepDatabase( id_transformation, id_step, databaseMeta.getObjectId() ); <span class="hljs-comment">// 将步骤与数据库关联保存到资源库</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> ( Exception e ) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>( BaseMessages.getString( PKG,<br>        <span class="hljs-string">&quot;MySQLBulkLoaderMeta.Exception.UnableToSaveStepInfoToRepository&quot;</span> )<br>        + id_step, e );<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="check">check</h3><p>用于检查 MySQL Bulk Loader步骤的配置是否正确。该方法执行以下操作：</p><ul><li>首先，它检查是否存在有效的数据库连接，如果存在，则进行下一步的检查。</li><li>接下来，它检查要加载数据的目标表是否存在以及要插入/更新的字段是否在目标表中存在。</li><li>然后，它检查输入流中的字段是否存在。</li><li>最后，它检查是否有其他步骤将数据流导向这个步骤。</li></ul><p>在每个检查点处，会根据检查结果创建一个 <code>CheckResult</code>对象，并将其添加到 <code>remarks</code>列表中。这些检查结果可用于识别配置中的问题或错误。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">( List&lt;CheckResultInterface&gt; remarks, TransMeta transMeta, StepMeta stepMeta, RowMetaInterface prev,</span><br><span class="hljs-params">      String[] input, String[] output, RowMetaInterface info, VariableSpace space, Repository repository,</span><br><span class="hljs-params">      IMetaStore metaStore )</span> &#123;<br>  CheckResult cr;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">error_message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-keyword">if</span> ( databaseMeta != <span class="hljs-literal">null</span> ) &#123;<br>    <span class="hljs-type">Database</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Database</span>( loggingObject, databaseMeta ); <span class="hljs-comment">// 创建一个数据库对象</span><br>    db.shareVariablesWith( transMeta ); <span class="hljs-comment">// 与转换元数据共享变量</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      db.connect(); <span class="hljs-comment">// 连接到数据库</span><br><br>      <span class="hljs-keyword">if</span> ( !Utils.isEmpty( tableName ) ) &#123;<br>        cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString( PKG,<br>            <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.TableNameOK&quot;</span> ), stepMeta );<br>        remarks.add( cr );<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">error_found</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        error_message = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 检查表中的字段</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">schemaTable</span> <span class="hljs-operator">=</span><br>            databaseMeta.getQuotedSchemaTableCombination( transMeta.environmentSubstitute( schemaName ), transMeta<br>                .environmentSubstitute( tableName ) );<br>        <span class="hljs-type">RowMetaInterface</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> db.getTableFields( schemaTable ); <span class="hljs-comment">// 获取表中的字段信息</span><br>        <span class="hljs-keyword">if</span> ( r != <span class="hljs-literal">null</span> ) &#123;<br>          cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString( PKG,<br>              <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.TableExists&quot;</span> ), stepMeta );<br>          remarks.add( cr );<br><br>          <span class="hljs-comment">// 检查要插入/更新的字段是否存在于表中</span><br>          first = <span class="hljs-literal">true</span>;<br>          error_found = <span class="hljs-literal">false</span>;<br>          error_message = <span class="hljs-string">&quot;&quot;</span>;<br><br>          <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fieldTable.length; i++ ) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> fieldTable[i];<br><br>            <span class="hljs-type">ValueMetaInterface</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> r.searchValueMeta( field );<br>            <span class="hljs-keyword">if</span> ( v == <span class="hljs-literal">null</span> ) &#123;<br>              <span class="hljs-keyword">if</span> ( first ) &#123;<br>                first = <span class="hljs-literal">false</span>;<br>                error_message +=<br>                    BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.MissingFieldsToLoadInTargetTable&quot;</span> )<br>                        + Const.CR;<br>              &#125;<br>              error_found = <span class="hljs-literal">true</span>;<br>              error_message += <span class="hljs-string">&quot;\t\t&quot;</span> + field + Const.CR;<br>            &#125;<br>          &#125;<br>          <span class="hljs-keyword">if</span> ( error_found ) &#123;<br>            cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_ERROR, error_message, stepMeta );<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString( PKG,<br>                <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.AllFieldsFoundInTargetTable&quot;</span> ), stepMeta );<br>          &#125;<br>          remarks.add( cr );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          error_message = BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.CouldNotReadTableInfo&quot;</span> );<br>          cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_ERROR, error_message, stepMeta );<br>          remarks.add( cr );<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 查找输入流中的字段 &lt;prev&gt;</span><br>      <span class="hljs-keyword">if</span> ( prev != <span class="hljs-literal">null</span> &amp;&amp; prev.size() &gt; <span class="hljs-number">0</span> ) &#123;<br>        cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString( PKG,<br>            <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.StepReceivingDatas&quot;</span>, prev.size() + <span class="hljs-string">&quot;&quot;</span> ), stepMeta );<br>        remarks.add( cr );<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        error_message = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">error_found</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fieldStream.length; i++ ) &#123;<br>          <span class="hljs-type">ValueMetaInterface</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> prev.searchValueMeta( fieldStream[i] );<br>          <span class="hljs-keyword">if</span> ( v == <span class="hljs-literal">null</span> ) &#123;<br>            <span class="hljs-keyword">if</span> ( first ) &#123;<br>              first = <span class="hljs-literal">false</span>;<br>              error_message +=<br>                  BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.MissingFieldsInInput&quot;</span> ) + Const.CR;<br>            &#125;<br>            error_found = <span class="hljs-literal">true</span>;<br>            error_message += <span class="hljs-string">&quot;\t\t&quot;</span> + fieldStream[i] + Const.CR;<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ( error_found ) &#123;<br>          cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_ERROR, error_message, stepMeta );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString( PKG,<br>              <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.AllFieldsFoundInInput&quot;</span> ), stepMeta );<br>        &#125;<br>        remarks.add( cr );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        error_message =<br>            BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.MissingFieldsInInput3&quot;</span> ) + Const.CR;<br>        cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_ERROR, error_message, stepMeta );<br>        remarks.add( cr );<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> ( KettleException e ) &#123;<br>      error_message =<br>          BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.DatabaseErrorOccurred&quot;</span> ) + e.getMessage();<br>      cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_ERROR, error_message, stepMeta );<br>      remarks.add( cr );<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      db.disconnect(); <span class="hljs-comment">// 断开与数据库的连接</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    error_message = BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.InvalidConnection&quot;</span> );<br>    cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_ERROR, error_message, stepMeta );<br>    remarks.add( cr );<br>  &#125;<br><br>  <span class="hljs-comment">// 检查是否有输入流导向这个步骤！</span><br>  <span class="hljs-keyword">if</span> ( input.length &gt; <span class="hljs-number">0</span> ) &#123;<br>    cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString( PKG,<br>        <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.StepReceivingInfoFromOtherSteps&quot;</span> ), stepMeta );<br>    remarks.add( cr );<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckResult</span>( CheckResultInterface.TYPE_RESULT_ERROR, BaseMessages.getString( PKG,<br>        <span class="hljs-string">&quot;MySQLBulkLoaderMeta.CheckResult.NoInputError&quot;</span> ), stepMeta );<br>    remarks.add( cr );<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="getsqlstatements">getSQLStatements</h3><p>用于生成执行SQL语句的对象。该方法执行以下操作：</p><ul><li>首先，它创建一个名为 <code>retval</code> 的<code>SQLStatement</code> 对象，用于存储生成的SQL语句。</li><li>然后，它检查是否存在有效的数据库连接。</li><li>如果存在输入流<code>prev</code>，则它将复制输入流的字段，并修改字段名以匹配目标表的字段。</li><li>接下来，它检查是否定义了目标表名。</li><li>如果定义了目标表名，则创建一个数据库对象，并连接到数据库。</li><li>使用表名和字段信息，它生成一个DDL语句。</li><li>最后，它将生成的SQL语句存储在 <code>retval</code>对象中，并返回该对象。</li></ul><p>在每个检查点处，如果存在错误或异常情况，将设置适当的错误消息。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SQLStatement <span class="hljs-title function_">getSQLStatements</span><span class="hljs-params">( TransMeta transMeta, StepMeta stepMeta, RowMetaInterface prev,</span><br><span class="hljs-params">      Repository repository, IMetaStore metaStore )</span> <span class="hljs-keyword">throws</span> KettleStepException &#123;<br>  <span class="hljs-type">SQLStatement</span> <span class="hljs-variable">retval</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLStatement</span>( stepMeta.getName(), databaseMeta, <span class="hljs-literal">null</span> ); <span class="hljs-comment">// 默认：无需执行任何操作！</span><br><br>  <span class="hljs-keyword">if</span> ( databaseMeta != <span class="hljs-literal">null</span> ) &#123;<br>    <span class="hljs-keyword">if</span> ( prev != <span class="hljs-literal">null</span> &amp;&amp; prev.size() &gt; <span class="hljs-number">0</span> ) &#123;<br>      <span class="hljs-comment">// 复制行数据</span><br>      <span class="hljs-type">RowMetaInterface</span> <span class="hljs-variable">tableFields</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RowMeta</span>();<br><br>      <span class="hljs-comment">// 修改字段名</span><br>      <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fieldTable.length; i++ ) &#123;<br>        <span class="hljs-type">ValueMetaInterface</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> prev.searchValueMeta( fieldStream[i] );<br>        <span class="hljs-keyword">if</span> ( v != <span class="hljs-literal">null</span> ) &#123;<br>          <span class="hljs-type">ValueMetaInterface</span> <span class="hljs-variable">tableField</span> <span class="hljs-operator">=</span> v.clone();<br>          tableField.setName( fieldTable[i] );<br>          tableFields.addValueMeta( tableField );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleStepException</span>( <span class="hljs-string">&quot;Unable to find field [&quot;</span> + fieldStream[i] + <span class="hljs-string">&quot;] in the input rows&quot;</span> );<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> ( !Utils.isEmpty( tableName ) ) &#123;<br>        <span class="hljs-type">Database</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Database</span>( loggingObject, databaseMeta ); <span class="hljs-comment">// 创建一个数据库对象</span><br>        db.shareVariablesWith( transMeta ); <span class="hljs-comment">// 与转换元数据共享变量</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          db.connect(); <span class="hljs-comment">// 连接到数据库</span><br><br>          <span class="hljs-type">String</span> <span class="hljs-variable">schemaTable</span> <span class="hljs-operator">=</span><br>              databaseMeta.getQuotedSchemaTableCombination( transMeta.environmentSubstitute( schemaName ), transMeta<br>                  .environmentSubstitute( tableName ) );<br>          <span class="hljs-type">String</span> <span class="hljs-variable">cr_table</span> <span class="hljs-operator">=</span> db.getDDL( schemaTable, tableFields, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span> ); <span class="hljs-comment">// 获取DDL语句</span><br><br>          <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> cr_table;<br>          <span class="hljs-keyword">if</span> ( sql.length() == <span class="hljs-number">0</span> ) &#123;<br>            retval.setSQL( <span class="hljs-literal">null</span> );<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            retval.setSQL( sql );<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> ( KettleException e ) &#123;<br>          retval<br>              .setError( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.GetSQL.ErrorOccurred&quot;</span> ) + e.getMessage() );<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        retval.setError( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.GetSQL.NoTableDefinedOnConnection&quot;</span> ) );<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      retval.setError( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.GetSQL.NotReceivingAnyFields&quot;</span> ) );<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    retval.setError( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.GetSQL.NoConnectionDefined&quot;</span> ) );<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="analyseimpact">analyseImpact</h3><p>用于分析步骤对数据库的影响。该方法执行以下操作：</p><ul><li>首先，它检查是否存在输入流 <code>prev</code>。</li><li>如果存在输入流，它将遍历 <code>fieldTable</code> 数组中的字段。</li><li>对于每个字段，它在输入流中搜索对应的字段信息。</li><li>然后，它创建一个 <code>DatabaseImpact</code>对象，表示对数据库的读/写影响，并将其添加到 <code>impact</code>列表中。</li><li><code>DatabaseImpact</code>对象包含有关影响的详细信息，如转换名称、步骤名称、数据库名称、表名、字段名等。</li></ul><p>在这个方法中，它分析了步骤对数据库的影响，并将这些影响信息存储在<code>impact</code> 列表中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">analyseImpact</span><span class="hljs-params">( List&lt;DatabaseImpact&gt; impact, TransMeta transMeta, StepMeta stepMeta,</span><br><span class="hljs-params">      RowMetaInterface prev, String[] input, String[] output, RowMetaInterface info, Repository repository,</span><br><span class="hljs-params">      IMetaStore metaStore )</span> <span class="hljs-keyword">throws</span> KettleStepException &#123;<br>  <span class="hljs-keyword">if</span> ( prev != <span class="hljs-literal">null</span> ) &#123;<br>    <span class="hljs-comment">/* DEBUG CHECK THIS */</span><br>    <span class="hljs-comment">// 插入读/写影响的字段</span><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fieldTable.length; i++ ) &#123;<br>      <span class="hljs-type">ValueMetaInterface</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> prev.searchValueMeta( fieldStream[i] );<br><br>      <span class="hljs-type">DatabaseImpact</span> <span class="hljs-variable">ii</span> <span class="hljs-operator">=</span><br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatabaseImpact</span>( DatabaseImpact.TYPE_IMPACT_READ_WRITE, transMeta.getName(), stepMeta.getName(),<br>              databaseMeta.getDatabaseName(), transMeta.environmentSubstitute( tableName ), fieldTable[i],<br>              fieldStream[i], v != <span class="hljs-literal">null</span> ? v.getOrigin() : <span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Type = &quot;</span> + v.toStringMeta() );<br>      impact.add( ii );<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="getrequiredfields">getRequiredFields</h3><p>用于获取所需的字段信息。该方法执行以下操作： -首先，它使用变量空间（<code>space</code>）替换表名和模式名中的变量，获取实际的表名（<code>realTableName</code>）和模式名（<code>realSchemaName</code>）。- 接下来，它检查是否存在数据库连接对象 <code>databaseMeta</code>。 -如果存在数据库连接对象，则创建一个数据库对象（<code>db</code>），使用指定的日志对象和数据库连接对象。- 连接到数据库。 -如果实际表名不为空，则构建包含模式和表名的字符串（<code>schemaTable</code>）。- 检查表是否存在于数据库中。 - 如果表存在，则返回该表的字段信息。 -如果表不存在，则抛出异常，提示表不存在。 -如果实际表名为空，则抛出异常，提示未指定表名。 -如果没有数据库连接对象，则抛出异常，提示未定义连接。 -最后，断开数据库连接。</p><p>该方法的目的是获取步骤所需的字段信息。它连接到数据库，检查指定的表是否存在，并返回该表的字段信息。如果表不存在、未指定表名或未定义数据库连接，则会抛出相应的异常。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RowMetaInterface <span class="hljs-title function_">getRequiredFields</span><span class="hljs-params">( VariableSpace space )</span> <span class="hljs-keyword">throws</span> KettleException &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">realTableName</span> <span class="hljs-operator">=</span> space.environmentSubstitute( tableName );<br>  <span class="hljs-type">String</span> <span class="hljs-variable">realSchemaName</span> <span class="hljs-operator">=</span> space.environmentSubstitute( schemaName );<br><br>  <span class="hljs-keyword">if</span> ( databaseMeta != <span class="hljs-literal">null</span> ) &#123;<br>    <span class="hljs-comment">// 创建一个数据库对象，并使用指定的日志对象和数据库连接对象</span><br>    <span class="hljs-type">Database</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Database</span>( loggingObject, databaseMeta );<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 连接到数据库</span><br>      db.connect();<br><br>      <span class="hljs-keyword">if</span> ( !Utils.isEmpty( realTableName ) ) &#123;<br>        <span class="hljs-comment">// 构建包含模式和表名的字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">schemaTable</span> <span class="hljs-operator">=</span> databaseMeta.getQuotedSchemaTableCombination( realSchemaName, realTableName );<br><br>        <span class="hljs-comment">// 检查表是否存在</span><br>        <span class="hljs-keyword">if</span> ( db.checkTableExists( schemaTable ) ) &#123;<br>          <span class="hljs-comment">// 返回表的字段信息</span><br>          <span class="hljs-keyword">return</span> db.getTableFields( schemaTable );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.Exception.TableNotFound&quot;</span> ) );<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.Exception.TableNotSpecified&quot;</span> ) );<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> ( Exception e ) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.Exception.ErrorGettingFields&quot;</span> ), e );<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// 断开数据库连接</span><br>      db.disconnect();<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>( BaseMessages.getString( PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.Exception.ConnectionNotDefined&quot;</span> ) );<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3id="afterinjectionsynchronization">afterInjectionSynchronization</h3><p>该方法执行以下操作：</p><ul><li>首先，它检查字段表 <code>fieldTable</code> 的长度，并将其存储在<code>nrFields</code> 变量中。</li><li>如果字段表长度小于等于0，则直接返回，不执行后续操作。</li><li>如果字段表长度大于0，则调用<code>Utils.normalizeArrays</code>方法对字段流<code>fieldStream</code>和字段格式类型<code>fieldFormatType</code>进行规范化处理。<ul><li>规范化处理会确保字段流和字段格式类型的长度与字段表长度相同，并且每个数组的元素都对应于相应字段表的元素。</li><li><code>Utils.normalizeArrays</code>方法返回一个二维数组，其中第一个子数组是规范化后的字段流，第二个子数组是规范化后的字段格式类型。</li></ul></li><li>最后，将规范化后的字段流和字段格式类型赋值给原始的字段流和字段格式类型。</li></ul><p>该方法的目的是在注入完成后对字段流和字段格式类型进行同步处理，确保它们与字段表的长度相匹配，并且每个数组的元素与相应字段表的元素一一对应。这样可以确保字段的设置与字段表的定义保持一致。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@AfterInjection</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterInjectionSynchronization</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 获取字段表的长度</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">nrFields</span> <span class="hljs-operator">=</span> (fieldTable == <span class="hljs-literal">null</span>) ? -<span class="hljs-number">1</span> : fieldTable.length;<br><br>  <span class="hljs-comment">// 如果字段表长度小于等于0，直接返回</span><br>  <span class="hljs-keyword">if</span> (nrFields &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 对字段流进行规范化处理</span><br>  String[][] rtnStrings = Utils.normalizeArrays(nrFields, fieldStream);<br>  fieldStream = rtnStrings[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-comment">// 对字段格式类型进行规范化处理</span><br>  <span class="hljs-type">int</span>[][] rtnInts = Utils.normalizeArrays(nrFields, fieldFormatType);<br>  fieldFormatType = rtnInts[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开源之夏2023</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kettle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql-bulk-loader之MySQLBulkLoaderData</title>
    <link href="/post/ebbc502f.html"/>
    <url>/post/ebbc502f.html</url>
    
    <content type="html"><![CDATA[<h1id="mysql-bulk-loader之mysqlbulkloaderdata">mysql-bulk-loader之MySQLBulkLoaderData</h1><p>前情提要：</p><p>Kettle组件就是一个step，它有四个类构建而成，每个类职责不同，各司其职。</p><span id="more"></span><ul><li>BaseStep:step类，实现了StepInterface接口，它是每个组件实际的业务处理类，组件的功能在这个类里实现。</li><li>BaseStepMeta:step元数据类，实现了StepMetaInterface接口，它的职责是保存和序列化组件的配置。</li><li>BaseStepData:step数据类，实现了StepDataInterface接口，用于存放每个组件在执行过程中的数据。</li><li>BaseStepDialog:step界面类，实现了StepDialogInterface接口，实现组件和用户进行交互的界面，提供一个对组件进行配置的界面。</li></ul><h2 id="mysqlbulkloaderdata">MySQLBulkLoaderData</h2><p><code>MySQLBulkLoaderData</code> 类是用于存储 MySQL Bulk Loader步骤的运行时数据的类。它包含了与步骤执行相关的各种属性和对象，如数据库连接对象、关键字段序号数组、日志记录器、引号字符、分隔符字符、元数据对象等。其中还包括了一些辅助属性，如数据库描述、模式表名、FIFO文件名等。这些属性可以在步骤的执行过程中保存和传递数据。构造函数中初始化了数据库连接对象为<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySQLBulkLoaderData</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseStepData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StepDataInterface</span> &#123;<br>  <span class="hljs-keyword">public</span> Database db; <span class="hljs-comment">// 数据库连接对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] keynrs; <span class="hljs-comment">// 关键字段的序号数组</span><br>  <span class="hljs-keyword">public</span> StreamLogger errorLogger; <span class="hljs-comment">// 错误日志记录器</span><br>  <span class="hljs-keyword">public</span> StreamLogger outputLogger; <span class="hljs-comment">// 输出日志记录器</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] quote; <span class="hljs-comment">// 引号字符</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] separator; <span class="hljs-comment">// 分隔符字符</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] newline; <span class="hljs-comment">// 换行符字符</span><br>  <span class="hljs-keyword">public</span> ValueMetaInterface bulkTimestampMeta; <span class="hljs-comment">// 批量时间戳元数据</span><br>  <span class="hljs-keyword">public</span> ValueMetaInterface bulkDateMeta; <span class="hljs-comment">// 批量日期元数据</span><br>  <span class="hljs-keyword">public</span> ValueMetaInterface bulkNumberMeta; <span class="hljs-comment">// 批量数字元数据</span><br>  <span class="hljs-keyword">protected</span> String dbDescription; <span class="hljs-comment">// 数据库描述</span><br>  <span class="hljs-keyword">public</span> String schemaTable; <span class="hljs-comment">// 模式表名</span><br>  <span class="hljs-keyword">public</span> String fifoFilename; <span class="hljs-comment">// FIFO 文件名</span><br>  <span class="hljs-keyword">public</span> OutputStream fifoStream; <span class="hljs-comment">// FIFO 文件输出流</span><br>  <span class="hljs-keyword">public</span> MySQLBulkLoader.SqlRunner sqlRunner; <span class="hljs-comment">// SQL 运行器</span><br>  <span class="hljs-keyword">public</span> ValueMetaInterface[] bulkFormatMeta; <span class="hljs-comment">// 批量格式元数据数组</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> bulkSize; <span class="hljs-comment">// 批量大小</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 默认构造函数。</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MySQLBulkLoaderData</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    db = <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开源之夏2023</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kettle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql-bulk-loader之MySQLBulkLoader</title>
    <link href="/post/969263e2.html"/>
    <url>/post/969263e2.html</url>
    
    <content type="html"><![CDATA[<h1id="mysql-bulk-loader之mysqlbulkloader">mysql-bulk-loader之MySQLBulkLoader</h1><p>前情提要：</p><p>Kettle组件就是一个step，它有四个类构建而成，每个类职责不同，各司其职。</p><span id="more"></span><ul><li>BaseStep:step类，实现了StepInterface接口，它是每个组件实际的业务处理类，组件的功能在这个类里实现。</li><li>BaseStepMeta:step元数据类，实现了StepMetaInterface接口，它的职责是保存和序列化组件的配置。</li><li>BaseStepData:step数据类，实现了StepDataInterface接口，用于存放每个组件在执行过程中的数据。</li><li>BaseStepDialog:step界面类，实现了StepDialogInterface接口，实现组件和用户进行交互的界面，提供一个对组件进行配置的界面。</li></ul><h2 id="mysqlbulkloader">MySQLBulkLoader</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySQLBulkLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseStep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StepInterface</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; PKG = MySQLBulkLoaderMeta.class; <br><br>    <span class="hljs-keyword">private</span> MySQLBulkLoaderMeta meta;<br>    <span class="hljs-keyword">private</span> MySQLBulkLoaderData data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">threadWaitTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">300000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">threadWaitTimeText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;5min&quot;</span>;<br>    <br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="构造函数">构造函数</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">MySQLBulkLoader</span><span class="hljs-params">( StepMeta stepMeta, StepDataInterface stepDataInterface, <span class="hljs-type">int</span> copyNr, TransMeta transMeta,</span><br><span class="hljs-params">    Trans trans )</span> &#123;<br>  <span class="hljs-built_in">super</span>( stepMeta, stepDataInterface, copyNr, transMeta, trans );<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="execute">execute</h3><p>执行MySQL数据库的批量加载操作，该方法用于执行MySQL数据库的批量加载操作。首先，它会检查是否存在指定的FIFO文件，如果不存在，则会创建该文件并设置权限。然后，它会清除数据库缓存并建立与数据库的连接。最后，它会执行加载命令。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(MySQLBulkLoaderMeta meta)</span> <span class="hljs-keyword">throws</span> KettleException &#123;<br>  <span class="hljs-type">Runtime</span> <span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> Runtime.getRuntime(); <span class="hljs-comment">// 获取运行时对象</span><br><br>  <span class="hljs-keyword">try</span> &#123;<br>    data.fifoFilename = environmentSubstitute(meta.getFifoFileName()); <span class="hljs-comment">// 获取并替换FIFO文件名</span><br>    <br>    <span class="hljs-type">File</span> <span class="hljs-variable">fifoFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(data.fifoFilename); <span class="hljs-comment">// 创建File对象来表示FIFO文件</span><br>    <span class="hljs-keyword">if</span> (!fifoFile.exists()) &#123; <span class="hljs-comment">// 如果FIFO文件不存在</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">mkFifoCmd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mkfifo &quot;</span> + data.fifoFilename; <span class="hljs-comment">// 构造创建FIFO文件的命令字符串</span><br><br>      logBasic(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.CREATINGFIFO&quot;</span>, data.dbDescription, mkFifoCmd)); <span class="hljs-comment">// 记录日志</span><br>      <span class="hljs-type">Process</span> <span class="hljs-variable">mkFifoProcess</span> <span class="hljs-operator">=</span> rt.exec(mkFifoCmd); <span class="hljs-comment">// 执行创建FIFO文件的命令</span><br>      <span class="hljs-type">StreamLogger</span> <span class="hljs-variable">errorLogger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamLogger</span>(log, mkFifoProcess.getErrorStream(), <span class="hljs-string">&quot;mkFifoError&quot;</span>); <span class="hljs-comment">// 创建用于记录错误日志的线程</span><br>      <span class="hljs-type">StreamLogger</span> <span class="hljs-variable">outputLogger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamLogger</span>(log, mkFifoProcess.getInputStream(), <span class="hljs-string">&quot;mkFifoOuptut&quot;</span>); <span class="hljs-comment">// 创建用于记录输出日志的线程</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(errorLogger).start(); <span class="hljs-comment">// 启动错误日志线程</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(outputLogger).start(); <span class="hljs-comment">// 启动输出日志线程</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> mkFifoProcess.waitFor(); <span class="hljs-comment">// 等待创建FIFO文件的命令执行完毕并获取执行结果</span><br>      <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.ERRORFIFORC&quot;</span>, result, mkFifoCmd)); <span class="hljs-comment">// 如果命令执行结果不为0，抛出异常</span><br>      &#125;<br><br>      <span class="hljs-type">String</span> <span class="hljs-variable">chmodCmd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;chmod 666 &quot;</span> + data.fifoFilename; <span class="hljs-comment">// 构造设置FIFO文件权限的命令字符串</span><br>      logBasic(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.SETTINGPERMISSIONSFIFO&quot;</span>, data.dbDescription, chmodCmd)); <span class="hljs-comment">// 记录日志</span><br>      <span class="hljs-type">Process</span> <span class="hljs-variable">chmodProcess</span> <span class="hljs-operator">=</span> rt.exec(chmodCmd); <span class="hljs-comment">// 执行设置FIFO文件权限的命令</span><br>      errorLogger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamLogger</span>(log, chmodProcess.getErrorStream(), <span class="hljs-string">&quot;chmodError&quot;</span>); <span class="hljs-comment">// 创建用于记录错误日志的线程</span><br>      outputLogger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamLogger</span>(log, chmodProcess.getInputStream(), <span class="hljs-string">&quot;chmodOuptut&quot;</span>); <span class="hljs-comment">// 创建用于记录输出日志的线程</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(errorLogger).start(); <span class="hljs-comment">// 启动错误日志线程</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(outputLogger).start(); <span class="hljs-comment">// 启动输出日志线程</span><br>      result = chmodProcess.waitFor(); <span class="hljs-comment">// 等待设置FIFO文件权限的命令执行完毕并获取执行结果</span><br>      <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.ERRORFIFORC&quot;</span>, result, chmodCmd)); <span class="hljs-comment">// 如果命令执行结果不为0，抛出异常</span><br>      &#125;<br>    &#125;<br><br>    DBCache.getInstance().clear(meta.getDatabaseMeta().getName()); <span class="hljs-comment">// 清除数据库缓存</span><br>    <span class="hljs-keyword">if</span> (meta.getDatabaseMeta() == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果数据库元数据为空</span><br>      logError(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Init.ConnectionMissing&quot;</span>, getStepname())); <span class="hljs-comment">// 记录错误日志</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 返回执行失败</span><br>    &#125;<br>    data.db = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Database</span>(<span class="hljs-built_in">this</span>, meta.getDatabaseMeta()); <span class="hljs-comment">// 创建数据库连接对象</span><br>    data.db.shareVariablesWith(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 共享变量</span><br>    <span class="hljs-type">PluginInterface</span> <span class="hljs-variable">dbPlugin</span> <span class="hljs-operator">=</span> PluginRegistry.getInstance().getPlugin(DatabasePluginType.class, meta.getDatabaseMeta().getDatabaseInterface()); <span class="hljs-comment">// 获取数据库插件</span><br>    data.dbDescription = (dbPlugin != <span class="hljs-literal">null</span>) ? dbPlugin.getDescription() : BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.UnknownDB&quot;</span>); <span class="hljs-comment">// 设置数据库描述信息</span><br><br>    <span class="hljs-keyword">if</span> (getTransMeta().isUsingUniqueConnections()) &#123; <span class="hljs-comment">// 如果使用唯一连接</span><br>      <span class="hljs-keyword">synchronized</span> (getTrans()) &#123;<br>        data.db.connect(getTrans().getTransactionId(), getPartitionID()); <span class="hljs-comment">// 连接数据库</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      data.db.connect(getPartitionID()); <span class="hljs-comment">// 连接数据库</span><br>    &#125;<br><br>    logBasic(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.CONNECTED&quot;</span>, data.dbDescription)); <span class="hljs-comment">// 记录日志</span><br><br>    executeLoadCommand(); <span class="hljs-comment">// 执行加载命令</span><br>  &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>(ex); <span class="hljs-comment">// 抛出异常</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 返回执行成功</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="executeloadcommand">executeLoadCommand</h3><p>执行MySQL数据库的加载命令。该方法构建并执行MySQL数据库的加载命令。它生成包括文件路径、加载选项、数据表、字符集、字段分隔符、字段封闭符等在内的加载命令字符串。然后，它使用SqlRunner线程执行加载命令，并打开FIFO文件进行数据写入。如果发生异常，将进行相应的处理和日志记录。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeLoadCommand</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">loadCommand</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 初始化加载命令字符串</span><br><br>  loadCommand += <span class="hljs-string">&quot;LOAD DATA &quot;</span> + (meta.isLocalFile() ? <span class="hljs-string">&quot;LOCAL&quot;</span> : <span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot; INFILE &#x27;&quot;</span><br>      + environmentSubstitute(meta.getFifoFileName()) + <span class="hljs-string">&quot;&#x27; &quot;</span>; <span class="hljs-comment">// 构造加载数据的命令字符串，包括文件路径和加载选项</span><br><br>  <span class="hljs-keyword">if</span> (meta.isReplacingData()) &#123;<br>    loadCommand += <span class="hljs-string">&quot;REPLACE &quot;</span>; <span class="hljs-comment">// 如果指定替换数据，则添加替换选项</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (meta.isIgnoringErrors()) &#123;<br>    loadCommand += <span class="hljs-string">&quot;IGNORE &quot;</span>; <span class="hljs-comment">// 如果指定忽略错误，则添加忽略选项</span><br>  &#125;<br><br>  loadCommand += <span class="hljs-string">&quot;INTO TABLE &quot;</span> + data.schemaTable + <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 指定要加载到的数据库表</span><br><br>  <span class="hljs-keyword">if</span> (!Utils.isEmpty(meta.getEncoding())) &#123;<br>    loadCommand += <span class="hljs-string">&quot;CHARACTER SET &quot;</span> + meta.getEncoding() + <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 指定字符集</span><br>  &#125;<br><br>  <span class="hljs-type">String</span> <span class="hljs-variable">delStr</span> <span class="hljs-operator">=</span> meta.getDelimiter(); <span class="hljs-comment">// 获取字段分隔符</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;\t&quot;</span>.equals(delStr)) &#123;<br>    delStr = <span class="hljs-string">&quot;\\t&quot;</span>; <span class="hljs-comment">// 将制表符转义</span><br>  &#125;<br><br>  loadCommand += <span class="hljs-string">&quot;FIELDS TERMINATED BY &#x27;&quot;</span> + delStr + <span class="hljs-string">&quot;&#x27; &quot;</span>; <span class="hljs-comment">// 指定字段分隔符</span><br><br>  <span class="hljs-keyword">if</span> (!Utils.isEmpty(meta.getEnclosure())) &#123;<br>    loadCommand += <span class="hljs-string">&quot;OPTIONALLY ENCLOSED BY &#x27;&quot;</span> + meta.getEnclosure() + <span class="hljs-string">&quot;&#x27; &quot;</span>; <span class="hljs-comment">// 指定字段封闭符</span><br>  &#125;<br><br>  loadCommand += <span class="hljs-string">&quot;ESCAPED BY &#x27;&quot;</span> + meta.getEscapeChar() + ( <span class="hljs-string">&quot;\\&quot;</span>.equals(meta.getEscapeChar()) ? meta.getEscapeChar() : <span class="hljs-string">&quot;&quot;</span> ) + <span class="hljs-string">&quot;&#x27; &quot;</span>; <span class="hljs-comment">// 指定转义字符</span><br><br>  <span class="hljs-comment">// 构建要设置的列名列表</span><br>  loadCommand += <span class="hljs-string">&quot;(&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cnt &lt; meta.getFieldTable().length; cnt++) &#123;<br>    loadCommand += meta.getDatabaseMeta().quoteField(meta.getFieldTable()[cnt]); <span class="hljs-comment">// 引用列名，防止命令注入</span><br>    <span class="hljs-keyword">if</span> (cnt &lt; meta.getFieldTable().length - <span class="hljs-number">1</span>) &#123;<br>      loadCommand += <span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>  &#125;<br>  loadCommand += <span class="hljs-string">&quot;);&quot;</span> + Const.CR; <span class="hljs-comment">// 完成加载命令的构建</span><br><br>  logBasic(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.STARTING&quot;</span>, data.dbDescription, loadCommand)); <span class="hljs-comment">// 记录日志</span><br><br>  data.sqlRunner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlRunner</span>(data, loadCommand); <span class="hljs-comment">// 创建SqlRunner对象来执行加载命令</span><br>  data.sqlRunner.start(); <span class="hljs-comment">// 启动SqlRunner线程</span><br><br>  <span class="hljs-comment">// 准备开始向FIFO文件写入行数据...</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">if</span> (!Const.isWindows()) &#123; <span class="hljs-comment">// 如果不是Windows系统</span><br>    logBasic(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.OPENFIFO&quot;</span>, data.fifoFilename)); <span class="hljs-comment">// 记录日志</span><br>    <span class="hljs-type">OpenFifo</span> <span class="hljs-variable">openFifo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenFifo</span>(data.fifoFilename, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 打开FIFO文件的线程</span><br>    openFifo.start(); <span class="hljs-comment">// 启动打开FIFO文件的线程</span><br><br>    <span class="hljs-comment">// 等待SQL语句或FIFO写入器抛出异常</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      openFifo.join(<span class="hljs-number">200</span>); <span class="hljs-comment">// 等待200毫秒</span><br>      <span class="hljs-keyword">if</span> (openFifo.getState() == Thread.State.TERMINATED) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">try</span> &#123;<br>        data.sqlRunner.checkExcn(); <span class="hljs-comment">// 检查SQL运行器是否抛出异常</span><br>      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 我们需要打开一个流到FIFO文件，解除FIFO写入器的阻塞</span><br>        <span class="hljs-comment">// 因为FIFO写入器正在等待SQL运行器，但现在SQL运行器已经停止运行</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(data.fifoFilename)).close();<br>        openFifo.join();<br>        logError(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.ERRORFIFO&quot;</span>)); <span class="hljs-comment">// 记录错误日志</span><br>        logError(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">throw</span> e;<br>      &#125;<br><br>      <span class="hljs-keyword">try</span> &#123;<br>        openFifo.checkExcn(); <span class="hljs-comment">// 检查FIFO写入器是否抛出异常</span><br>      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>      &#125;<br>    &#125;<br>    data.fifoStream = openFifo.getFifoStream(); <span class="hljs-comment">// 获取FIFO文件的流</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="processrow">processRow</h3><p>一个step的处理方法，用于在Transformation中执行MySQL批量加载操作。该方法是一个步骤的处理方法，它从输入行集中获取一行数据，并执行MySQL批量加载操作。它会根据设定的批量大小定期重新开始批量加载过程，以提高性能。在处理过程中，它会将行数据写入批量加载，将数据传递给下一个步骤，并更新行数计数器。如果发生异常，将进行相应的处理和日志记录。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">processRow</span><span class="hljs-params">(StepMetaInterface smi, StepDataInterface sdi)</span> <span class="hljs-keyword">throws</span> KettleException &#123;<br>  meta = (MySQLBulkLoaderMeta) smi; <span class="hljs-comment">// 获取步骤的元数据</span><br>  data = (MySQLBulkLoaderData) sdi; <span class="hljs-comment">// 获取步骤的数据</span><br><br>  <span class="hljs-keyword">try</span> &#123;<br>    Object[] r = getRow(); <span class="hljs-comment">// 从输入行集中获取一行数据</span><br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果没有更多的输入数据...</span><br><br>      setOutputDone();<br><br>      closeOutput();<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (first) &#123;<br>      first = <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-comment">// 缓存字段索引。</span><br>      <span class="hljs-comment">//</span><br>      data.keynrs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[meta.getFieldStream().length];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; data.keynrs.length; i++) &#123;<br>        data.keynrs[i] = getInputRowMeta().indexOfValue(meta.getFieldStream()[i]);<br>      &#125;<br><br>      data.bulkFormatMeta = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueMetaInterface</span>[data.keynrs.length];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; data.keynrs.length; i++) &#123;<br>        <span class="hljs-type">ValueMetaInterface</span> <span class="hljs-variable">sourceMeta</span> <span class="hljs-operator">=</span> getInputRowMeta().getValueMeta(data.keynrs[i]);<br>        <span class="hljs-keyword">if</span> (sourceMeta.isDate()) &#123;<br>          <span class="hljs-keyword">if</span> (meta.getFieldFormatType()[i] == MySQLBulkLoaderMeta.FIELD_FORMAT_TYPE_DATE) &#123;<br>            data.bulkFormatMeta[i] = data.bulkDateMeta.clone();<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (meta.getFieldFormatType()[i] == MySQLBulkLoaderMeta.FIELD_FORMAT_TYPE_TIMESTAMP) &#123;<br>            data.bulkFormatMeta[i] = data.bulkTimestampMeta.clone(); <span class="hljs-comment">// 默认为时间戳</span><br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sourceMeta.isNumeric() &amp;&amp; meta.getFieldFormatType()[i] == MySQLBulkLoaderMeta.FIELD_FORMAT_TYPE_NUMBER) &#123;<br>          data.bulkFormatMeta[i] = data.bulkNumberMeta.clone();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (data.bulkFormatMeta[i] == <span class="hljs-literal">null</span> &amp;&amp; !sourceMeta.isStorageBinaryString()) &#123;<br>          data.bulkFormatMeta[i] = sourceMeta.clone();<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 执行客户端语句...</span><br>      <span class="hljs-comment">//</span><br>      execute(meta);<br>    &#125;<br><br>    <span class="hljs-comment">// 每处理一定数量的行，重新开始批量加载过程，以便索引等适应MySQL服务器的内存</span><br>    <span class="hljs-comment">// 如果不这样做，性能可能会下降。</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span> (data.bulkSize &gt; <span class="hljs-number">0</span> &amp;&amp; getLinesOutput() &gt; <span class="hljs-number">0</span> &amp;&amp; (getLinesOutput() % data.bulkSize) == <span class="hljs-number">0</span>) &#123;<br>      closeOutput();<br>      executeLoadCommand();<br>    &#125;<br><br>    writeRowToBulk(getInputRowMeta(), r); <span class="hljs-comment">// 将行数据写入批量加载</span><br>    putRow(getInputRowMeta(), r); <span class="hljs-comment">// 将行数据传递给下一个步骤</span><br>    incrementLinesOutput(); <span class="hljs-comment">// 增加输出行数计数器</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    logError(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Log.ErrorInStep&quot;</span>), e); <span class="hljs-comment">// 记录错误日志</span><br>    setErrors(<span class="hljs-number">1</span>); <span class="hljs-comment">// 设置步骤错误数</span><br>    stopAll();<br>    setOutputDone(); <span class="hljs-comment">// 向接收器发送结束信号</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="closeoutput">closeOutput</h3><p>用于关闭输出流和等待MySQL加载命令线程完成处理。该方法用于关闭输出流和等待MySQL加载命令线程完成处理。它会关闭输出流，然后等待一段时间，让MySQL加载命令线程完成处理。在等待期间，方法会输出等待消息。一旦MySQL加载命令线程完成处理，方法会检查是否有异常抛出。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeOutput</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-keyword">if</span> (data.fifoStream != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 关闭输出流</span><br>    data.fifoStream.close();<br>    data.fifoStream = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (data.sqlRunner != <span class="hljs-literal">null</span>) &#123;<br>    logDebug(<span class="hljs-string">&quot;Waiting up to &quot;</span> + <span class="hljs-built_in">this</span>.threadWaitTimeText + <span class="hljs-string">&quot; for the MySQL load command thread to finish processing.&quot;</span>); <span class="hljs-comment">// 输出等待消息</span><br>    data.sqlRunner.join(<span class="hljs-built_in">this</span>.threadWaitTime); <span class="hljs-comment">// 等待MySQL加载命令线程完成处理</span><br>    <span class="hljs-type">SqlRunner</span> <span class="hljs-variable">sqlRunner</span> <span class="hljs-operator">=</span> data.sqlRunner;<br>    data.sqlRunner = <span class="hljs-literal">null</span>;<br>    sqlRunner.checkExcn(); <span class="hljs-comment">// 检查MySQL加载命令线程是否抛出异常</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="writerowtobulk">writeRowToBulk</h3><p>用于将输入行数据写入到批量加载流中。该方法将输入行数据写入到批量加载流中。它遍历每个字段，根据字段的数据类型进行处理，并将数据写入到输出流中。具体的处理方式包括写入字符串、整数、日期、布尔值、数字和大数等。在写入过程中，还会根据需要添加分隔符和引号，并在一定条件下刷新输出流。如果在写入过程中发生异常，方法会处理异常并抛出KettleException。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeRowToBulk</span><span class="hljs-params">(RowMetaInterface rowMeta, Object[] r)</span> <span class="hljs-keyword">throws</span> KettleException &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; data.keynrs.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>        data.fifoStream.write(data.separator); <span class="hljs-comment">// 写入分隔符</span><br>      &#125;<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> data.keynrs[i];<br>      <span class="hljs-type">ValueMetaInterface</span> <span class="hljs-variable">valueMeta</span> <span class="hljs-operator">=</span> rowMeta.getValueMeta(index);<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">valueData</span> <span class="hljs-operator">=</span> r[index];<br><br>      <span class="hljs-keyword">if</span> (valueData == <span class="hljs-literal">null</span>) &#123;<br>        data.fifoStream.write(<span class="hljs-string">&quot;NULL&quot;</span>.getBytes()); <span class="hljs-comment">// 写入NULL值</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">switch</span> (valueMeta.getType()) &#123;<br>          <span class="hljs-keyword">case</span> ValueMetaInterface.TYPE_STRING:<br>            data.fifoStream.write(data.quote); <span class="hljs-comment">// 写入引号</span><br>            <span class="hljs-keyword">if</span> (valueMeta.isStorageBinaryString()<br>                &amp;&amp; meta.getFieldFormatType()[i] == MySQLBulkLoaderMeta.FIELD_FORMAT_TYPE_OK) &#123;<br>              data.fifoStream.write((<span class="hljs-type">byte</span>[]) valueData); <span class="hljs-comment">// 写入二进制字符串</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> valueMeta.getString(valueData);<br>              <span class="hljs-keyword">if</span> (string != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (meta.getFieldFormatType()[i] == MySQLBulkLoaderMeta.FIELD_FORMAT_TYPE_STRING_ESCAPE) &#123;<br>                  string = Const.replace(string, meta.getEscapeChar(), meta.getEscapeChar() + meta.getEscapeChar());<br>                  string = Const.replace(string, meta.getEnclosure(), meta.getEscapeChar() + meta.getEnclosure());<br>                &#125;<br>                data.fifoStream.write(string.getBytes()); <span class="hljs-comment">// 写入字符串</span><br>              &#125;<br>            &#125;<br>            data.fifoStream.write(data.quote); <span class="hljs-comment">// 写入引号</span><br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> ValueMetaInterface.TYPE_INTEGER:<br>            <span class="hljs-keyword">if</span> (valueMeta.isStorageBinaryString() &amp;&amp; data.bulkFormatMeta[i] == <span class="hljs-literal">null</span>) &#123;<br>              data.fifoStream.write(valueMeta.getBinaryString(valueData)); <span class="hljs-comment">// 写入二进制整数</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-type">Long</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> valueMeta.getInteger(valueData);<br>              <span class="hljs-keyword">if</span> (integer != <span class="hljs-literal">null</span>) &#123;<br>                data.fifoStream.write(data.bulkFormatMeta[i].getString(integer).getBytes()); <span class="hljs-comment">// 写入整数</span><br>              &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> ValueMetaInterface.TYPE_DATE:<br>            <span class="hljs-keyword">if</span> (valueMeta.isStorageBinaryString() &amp;&amp; data.bulkFormatMeta[i] == <span class="hljs-literal">null</span>) &#123;<br>              data.fifoStream.write(valueMeta.getBinaryString(valueData)); <span class="hljs-comment">// 写入二进制日期</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> valueMeta.getDate(valueData);<br>              <span class="hljs-keyword">if</span> (date != <span class="hljs-literal">null</span>) &#123;<br>                data.fifoStream.write(data.bulkFormatMeta[i].getString(date).getBytes()); <span class="hljs-comment">// 写入日期</span><br>              &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> ValueMetaInterface.TYPE_BOOLEAN:<br>            <span class="hljs-keyword">if</span> (valueMeta.isStorageBinaryString() &amp;&amp; data.bulkFormatMeta[i] == <span class="hljs-literal">null</span>) &#123;<br>              data.fifoStream.write(valueMeta.getBinaryString(valueData)); <span class="hljs-comment">// 写入二进制布尔值</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-type">Boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> valueMeta.getBoolean(valueData);<br>              <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>                data.fifoStream.write(data.bulkFormatMeta[i].getString(b).getBytes()); <span class="hljs-comment">// 写入布尔值</span><br>              &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> ValueMetaInterface.TYPE_NUMBER:<br>            <span class="hljs-keyword">if</span> (valueMeta.isStorageBinaryString() &amp;&amp; data.bulkFormatMeta[i] == <span class="hljs-literal">null</span>) &#123;<br>              data.fifoStream.write((<span class="hljs-type">byte</span>[]) valueData); <span class="hljs-comment">// 写入二进制数字</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">if</span> (getLinesWritten() == <span class="hljs-number">0</span>) &#123;<br>                data.bulkFormatMeta[i].setConversionMask(<span class="hljs-literal">null</span>);<br>              &#125;<br>              <span class="hljs-type">Double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> valueMeta.getNumber(valueData);<br>              <span class="hljs-keyword">if</span> (d != <span class="hljs-literal">null</span>) &#123;<br>                data.fifoStream.write(data.bulkFormatMeta[i].getString(d).getBytes()); <span class="hljs-comment">// 写入数字</span><br>              &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> ValueMetaInterface.TYPE_BIGNUMBER:<br>            <span class="hljs-keyword">if</span> (valueMeta.isStorageBinaryString() &amp;&amp; data.bulkFormatMeta[i] == <span class="hljs-literal">null</span>) &#123;<br>              data.fifoStream.write((<span class="hljs-type">byte</span>[]) valueData); <span class="hljs-comment">// 写入二进制大数</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">bn</span> <span class="hljs-operator">=</span> valueMeta.getBigNumber(valueData);<br>              <span class="hljs-keyword">if</span> (bn != <span class="hljs-literal">null</span>) &#123;<br>                data.fifoStream.write(data.bulkFormatMeta[i].getString(bn).getBytes()); <span class="hljs-comment">// 写入大数</span><br>              &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    data.fifoStream.write(data.newline); <span class="hljs-comment">// 写入换行符</span><br><br>    <span class="hljs-keyword">if</span> ((getLinesWritten() % <span class="hljs-number">5000</span>) == <span class="hljs-number">0</span>) &#123;<br>      data.fifoStream.flush(); <span class="hljs-comment">// 刷新输出流</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      logError(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.IOERROR&quot;</span>, <span class="hljs-built_in">this</span>.threadWaitTimeText));<br>      <span class="hljs-keyword">try</span> &#123;<br>        data.sqlRunner.join(<span class="hljs-built_in">this</span>.threadWaitTime);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>        <span class="hljs-comment">// 空操作</span><br>      &#125;<br>      data.sqlRunner.checkExcn();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception loadEx) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.ERRORSERIALIZING&quot;</span>), loadEx);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.ERRORSERIALIZING&quot;</span>), e);<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e2) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.ERRORSERIALIZING&quot;</span>), e2);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="verifydatabaseconnection">verifyDatabaseConnection</h3><p>用于验证数据库连接是否已定义。该方法用于验证数据库连接是否已定义。它检查MySQLBulkLoaderMeta对象中的数据库元数据是否为空，如果为空，则抛出KettleException异常，表示未定义数据库连接。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verifyDatabaseConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> KettleException &#123;<br>  <span class="hljs-keyword">if</span> (meta.getDatabaseMeta() == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KettleException</span>(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoaderMeta.GetSQL.NoConnectionDefined&quot;</span>)); <span class="hljs-comment">// 如果数据库连接未定义，则抛出异常</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="init">init</h3><p><code>init</code>方法的实现，用于初始化步骤。该方法用于初始化步骤。它首先获取步骤的元数据和数据，然后验证数据库连接是否已定义。接下来，根据元数据配置设置引号、分隔符和换行符，并设置数据编码和元数据对象用于转换数据格式。最后，设置批量大小和模式与表名的组合，并返回初始化是否成功的结果。如果初始化失败，将返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">init</span><span class="hljs-params">(StepMetaInterface smi, StepDataInterface sdi)</span> &#123;<br>  meta = (MySQLBulkLoaderMeta) smi;<br>  data = (MySQLBulkLoaderData) sdi;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">super</span>.init(smi, sdi)) &#123;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      verifyDatabaseConnection(); <span class="hljs-comment">// 验证数据库连接是否已定义</span><br>    &#125; <span class="hljs-keyword">catch</span> (KettleException ex) &#123;<br>      logError(ex.getMessage());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置引号和分隔符</span><br>    <span class="hljs-keyword">if</span> (Utils.isEmpty(meta.getEnclosure())) &#123;<br>      data.quote = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[] &#123;&#125;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      data.quote = environmentSubstitute(meta.getEnclosure()).getBytes();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Utils.isEmpty(meta.getDelimiter())) &#123;<br>      data.separator = <span class="hljs-string">&quot;\t&quot;</span>.getBytes();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      data.separator = environmentSubstitute(meta.getDelimiter()).getBytes();<br>    &#125;<br>    data.newline = Const.CR.getBytes();<br><br>    <span class="hljs-comment">// 设置数据编码和元数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">realEncoding</span> <span class="hljs-operator">=</span> environmentSubstitute(meta.getEncoding());<br>    data.bulkTimestampMeta = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueMetaDate</span>(<span class="hljs-string">&quot;timestampMeta&quot;</span>);<br>    data.bulkTimestampMeta.setConversionMask(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    data.bulkTimestampMeta.setStringEncoding(realEncoding);<br><br>    data.bulkDateMeta = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueMetaDate</span>(<span class="hljs-string">&quot;dateMeta&quot;</span>);<br>    data.bulkDateMeta.setConversionMask(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>    data.bulkDateMeta.setStringEncoding(realEncoding);<br><br>    data.bulkNumberMeta = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueMetaNumber</span>(<span class="hljs-string">&quot;numberMeta&quot;</span>);<br>    data.bulkNumberMeta.setConversionMask(<span class="hljs-string">&quot;#.#&quot;</span>);<br>    data.bulkNumberMeta.setGroupingSymbol(<span class="hljs-string">&quot;,&quot;</span>);<br>    data.bulkNumberMeta.setDecimalSymbol(<span class="hljs-string">&quot;.&quot;</span>);<br>    data.bulkNumberMeta.setStringEncoding(realEncoding);<br><br>    <span class="hljs-comment">// 设置批量大小</span><br>    data.bulkSize = Const.toLong(environmentSubstitute(meta.getBulkSize()), -<span class="hljs-number">1L</span>);<br><br>    <span class="hljs-comment">// 设置模式和表名</span><br>    data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(<br>        environmentSubstitute(meta.getSchemaName()),<br>        environmentSubstitute(meta.getTableName())<br>    );<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="dispose">dispose</h3><p><code>dispose</code>方法的实现，用于清理资源并释放步骤。该方法用于清理步骤所使用的资源，包括关闭FIFO 流、等待 SQL 执行线程结束、断开与数据库的连接以及删除 FIFO文件。如果在清理过程中发生异常，会设置步骤的错误数并记录错误日志。最后，调用父类的<code>dispose</code> 方法释放其他资源。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispose</span><span class="hljs-params">(StepMetaInterface smi, StepDataInterface sdi)</span> &#123;<br>  meta = (MySQLBulkLoaderMeta) smi;<br>  data = (MySQLBulkLoaderData) sdi;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (data.fifoStream != <span class="hljs-literal">null</span>) &#123;<br>      data.fifoStream.close(); <span class="hljs-comment">// 关闭 FIFO 流</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (data.sqlRunner != <span class="hljs-literal">null</span>) &#123;<br>      data.sqlRunner.join(); <span class="hljs-comment">// 等待 SQL 执行线程结束</span><br>      data.sqlRunner = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (data.db != <span class="hljs-literal">null</span>) &#123;<br>      data.db.disconnect(); <span class="hljs-comment">// 断开与数据库的连接</span><br>      data.db = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (data.fifoFilename != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(data.fifoFilename).delete(); <span class="hljs-comment">// 删除 FIFO 文件</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logError(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.UNABLETODELETE&quot;</span>, data.fifoFilename), e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    setErrors(<span class="hljs-number">1L</span>);<br>    logError(BaseMessages.getString(PKG, <span class="hljs-string">&quot;MySQLBulkLoader.Message.UNEXPECTEDERRORCLOSING&quot;</span>), e);<br>  &#125;<br><br>  <span class="hljs-built_in">super</span>.dispose(smi, sdi); <span class="hljs-comment">// 调用父类的 dispose 方法进行资源释放</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="openfifo">OpenFifo</h3><p>静态内部类 <code>OpenFifo</code>。该静态内部类 <code>OpenFifo</code>继承自 <code>Thread</code>，用于在单独的线程中打开 FIFO文件并创建缓冲输出流。在 <code>run</code>方法中，通过打开文件并创建缓冲输出流，将结果保存在<code>fifoStream</code>变量中。如果在打开过程中出现异常，会将异常对象保存在 <code>ex</code>变量中。<code>checkExcn</code>方法用于在主线程上下文中重新抛出保存的异常对象。<code>getFifoStream</code>方法用于获取 FIFO 流对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenFifo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">fifoStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// FIFO 流</span><br>  <span class="hljs-keyword">private</span> Exception ex; <span class="hljs-comment">// 异常对象</span><br>  <span class="hljs-keyword">private</span> String fifoName; <span class="hljs-comment">// FIFO 文件名</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">// 缓冲区大小</span><br><br>  OpenFifo(String fifoName, <span class="hljs-type">int</span> size) &#123;<br>    <span class="hljs-built_in">this</span>.fifoName = fifoName;<br>    <span class="hljs-built_in">this</span>.size = size;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      fifoStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(OpenFifo.<span class="hljs-built_in">this</span>.fifoName), <span class="hljs-built_in">this</span>.size); <span class="hljs-comment">// 打开 FIFO 文件并创建缓冲输出流</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>      <span class="hljs-built_in">this</span>.ex = ex; <span class="hljs-comment">// 如果出现异常，将异常对象保存起来</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkExcn</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 该方法从主线程上下文中被调用，用于重新抛出任何保存的异常</span><br>    <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> ex; <span class="hljs-comment">// 如果保存的异常对象非空，则抛出异常</span><br>    &#125;<br>  &#125;<br><br>  BufferedOutputStream <span class="hljs-title function_">getFifoStream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> fifoStream; <span class="hljs-comment">// 获取 FIFO 流对象</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="sqlrunner">SqlRunner</h3><p>静态内部类 <code>SqlRunner</code>。该静态内部类<code>SqlRunner</code> 继承自<code>Thread</code>，用于在单独的线程中执行 MySQL 数据库的加载命令。在<code>run</code> 方法中，调用 <code>data.db.execStatement</code>方法执行加载命令。如果在执行过程中出现异常，会将异常对象保存在<code>ex</code> 变量中。<code>checkExcn</code>方法用于在主线程上下文中重新抛出保存的异常对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlRunner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">private</span> MySQLBulkLoaderData data; <span class="hljs-comment">// 数据对象</span><br>  <span class="hljs-keyword">private</span> String loadCommand; <span class="hljs-comment">// 加载命令</span><br>  <span class="hljs-keyword">private</span> Exception ex; <span class="hljs-comment">// 异常对象</span><br><br>  SqlRunner(MySQLBulkLoaderData data, String loadCommand) &#123;<br>    <span class="hljs-built_in">this</span>.data = data;<br>    <span class="hljs-built_in">this</span>.loadCommand = loadCommand;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      data.db.execStatement(loadCommand); <span class="hljs-comment">// 执行加载命令</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>      <span class="hljs-built_in">this</span>.ex = ex; <span class="hljs-comment">// 如果出现异常，将异常对象保存起来</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkExcn</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> ex; <span class="hljs-comment">// 如果保存的异常对象非空，则抛出异常</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开源之夏2023</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kettle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kettle插件设计</title>
    <link href="/post/428c1d60.html"/>
    <url>/post/428c1d60.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对Kettle 插件进行相关总结</p><span id="more"></span><h1 id="kettle插件设计">Kettle插件设计</h1><p>Kettle组件就是一个step，它有四个类构建而成，每个类职责不同，各司其职。</p><ul><li>BaseStep:step类，实现了StepInterface接口，它是每个组件实际的业务处理类，组件的功能在这个类里实现。</li><li>BaseStepMeta:step元数据类，实现了StepMetaInterface接口，它的职责是保存和序列化组件的配置。</li><li>BaseStepData:step数据类，实现了StepDataInterface接口，用于存放每个组件在执行过程中的数据。</li><li>BaseStepDialog:step界面类，实现了StepDialogInterface接口，实现组件和用户进行交互的界面，提供一个对组件进行配置的界面。</li></ul><h2 id="创建step-plugin">创建Step Plugin</h2><p>transformationstep在ETL数据流中实现数据处理任务。它对数据行流进行操作。转换step是为输入、处理或输出而设计的。</p><p>input Step从外部数据源（如文件或数据库）获取数据行。processingstep处理数据行、执行字段计算和流操作，例如连接或过滤。outputstep将处理后的数据写回存储、文件或数据库。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/img/202306020036069.png" /></p><p>step plugin通过实现四个不同的 Java 接口与 PDI 集成。每个接口代表由PDIstep执行的一组职责。每个接口都有一个基类，该基类实现接口的大部分，以简化插件开发。</p><p>所有step接口和相应的基类都在 org.pentaho.di.trans.step 包中。</p><table><colgroup><col style="width: 15%" /><col style="width: 35%" /><col style="width: 49%" /></colgroup><thead><tr class="header"><th>Java接口</th><th>基类</th><th>主要职责</th></tr></thead><tbody><tr class="odd"><td>StepMetaInterface</td><td>BaseStepMeta</td><td>维护step设置<br />验证step设置<br />序列化step设置<br />提供对step类的访问<br />执行行布局更改</td></tr><tr class="even"><td>StepDialogInterface</td><td>org.pentaho.di.ui.trans.step.BaseStepDialog</td><td>step设置对话框</td></tr><tr class="odd"><td>StepInterface</td><td>BaseStep</td><td>处理行</td></tr><tr class="even"><td>StepDataInterface</td><td>BaseStepData</td><td>存储处理状态，并在行处理过程中声明和作为字段变量的地方</td></tr></tbody></table><blockquote><p>一个step plugin至少需要实现如上四个接口：org.pentaho.di.trans.step.StepMetaInterface：元数据的处理，加载xml，校验，主要是对一个step的定义的基本数据。org.pentaho.di.trans.step.StepDataInterface：数据处理涉及的具体数据，以及对数据的状态的设置和回收。org.pentaho.di.trans.step.StepInterface：负责数据处理，转换和流转。这里面主要由processRow()方法来处理。org.pentaho.di.trans.step.StepDialogInterface：提供GUI/dialog，编辑step的元数据。</p></blockquote><h3id="stepmetainterfacebasestepmeta">StepMetaInterface(BaseStepMeta)</h3><p>StepMetaInterface 是插件实现的主要 Java 接口。</p><table><colgroup><col style="width: 11%" /><col style="width: 88%" /></colgroup><thead><tr class="header"><th>Java接口</th><th><ahref="https://javadoc.pentaho.com/kettle530/kettle-engine-5.3.0.0-javadoc/org/pentaho/di/trans/step/StepMetaInterface.html">org.pentaho.di.trans.step.StepMetaInterface</a></th></tr></thead><tbody><tr class="odd"><td><strong>基类</strong></td><td><ahref="https://javadoc.pentaho.com/kettle530/kettle-engine-5.3.0.0-javadoc/org/pentaho/di/trans/step/BaseStepMeta.html">org.pentaho.di.trans.step.BaseStepMeta</a></td></tr></tbody></table><ul><li><p>跟踪Step设置</p><p>实现类使用带有相应 get 和 set 方法的私有字段跟踪step设置。实现StepDialogInterface的对话框类使用这些方法在对话框内外复制用户提供的配置。</p><ul><li><p><code>void setDefault()</code></p><p>每次创建新step并将step配置分配或设置为合理的默认值时，都会调用此方法。创建新step时，PDI客户端 (Spoon)使用此处设置的值。这是确保将step设置初始化为非空值的好地方。空值在序列化和对话填充中处理起来可能很麻烦，因此大多数PDI step实现坚持所有step设置的非空值。</p></li><li><p><code>public Object clone()</code></p><p>当在 PDI客户端中复制step时调用此方法。它返回step元对象的深层副本。如果step配置存储在可修改的对象（例如列表或自定义帮助程序对象）中，则实现类必须创建适当的深层副本。</p></li></ul></li><li><p>序列化Step设置</p><p>该插件将其设置序列化为 XML 和 PDI存储库。这些接口方法提供此功能。</p><ul><li><p><code>public String getXML()</code></p><p>只要step将其设置序列化为 XML，PDI 就会调用此方法。在 PDI客户端中保存转换时调用它。该方法返回包含序列化step设置的 XML字符串。该字符串包含一系列 XML 标记，每个设置一个标记。帮助程序类<code>org.pentaho.di.core.xml.XMLHandler</code>构造 XML字符串。</p></li><li><p><code>public void loadXML()</code></p><p>每当step从 XML 读取其设置时，PDI 就会调用此方法。包含step设置的 XML节点作为参数传入。同样，帮助程序类<code>org.pentaho.di.core.xml.XMLHandler</code>从 XML节点读取step设置。</p></li><li><p><code>public void saveRep()</code></p><p>只要step将其设置保存到 PDI 存储库，PDI就会调用此方法。作为第一个参数传入的存储库对象提供了一组用于序列化step设置的方法。在调用存储库序列化方法时，step使用传入的转换ID 和step ID 作为标识符。</p></li><li><p><code>public void readRep()</code></p><p>每当step从 PDI 存储库读取其配置时，PDI就会调用此方法。在使用存储库序列化方法时，参数中给出的step ID用作标识符。</p></li></ul><p>开发插件时，请确保序列化代码与step对话框中可用的设置同步。当在 PDI客户端中测试一个step时，PDI在执行它之前在内部保存和加载转换的副本。</p></li><li><p>提供其他plugin类的实例</p><p>插件<code>StepMetaInterface</code>类是主类，与 PDI体系结构的其余部分结合在一起。它负责提供实现<code>StepDialogInterface</code>、<code>StepInterface</code>和的其他插件类的实例<code>StepDataInterface</code>。以下方法涵盖了这些职责。每个方法实现都会构造相应类的一个新实例，将传入的参数转发给构造函数。</p><ul><li><code>public StepDialogInterface getDialog()</code></li><li><code>public StepInterface getStep()</code></li><li><code>public StepDataInterface getStepData()</code></li></ul><p><code>StepDialogInterface</code>这些方法中的每一个都返回一个实现、<code>StepInterface</code>和的插件类的新实例<code>StepDataInterface</code>。</p></li><li><p>向行流报告step的变化</p><p>PDI需要知道step如何影响行结构。一个step可能是添加或删除字段，以及修改字段的元数据。实现step插件这一方面的方法是<code>getFields()</code></p><ul><li><p><code>public void getFields()</code></p><p>给定输入行的描述，插件会对其进行修改以匹配其输出字段的结构。该实现修改传入的<code>RowMetaInterface</code>对象以反映对行流的更改。一个step将字段添加到行结构。这是通过创建<code>ValueMeta</code>对象，例如<code>ValueMetaInterface</code>的PDI默认实现，并将它们附加到<code>RowMetaInterface</code>对象来完成的。</p></li></ul></li><li><p>验证step设置</p><p>PDI 客户端支持<strong>ValidateTransformation</strong>功能，该功能会触发所有step的自检。PDI调用<code>check()</code>画布上每个step的方法，允许每个step验证其设置。</p><ul><li><p><code>public void check()</code></p><p>每个step都有机会验证其设置并验证用户给出的配置是否合理。此外，step检查它是否连接到前面或后面的step，如果step的性质需要那种连接。例如，一个输入step可能期望没有前面的step。check方法传入检查注释列表，该方法将其验证结果附加到该列表。PDI客户端显示从step中收集的备注列表，允许您在出现验证警告或错误时采取纠正措施。</p></li></ul></li><li><p>与PDI插件系统的接口</p><p>类实现<code>StepMetaInterface</code>必须使用<ahref="http://javadoc.pentaho.com/kettle/org/pentaho/di/core/annotations/Step.html">Step</a>Java 注释进行注释。提供以下注释属性：</p><table><colgroup><col style="width: 25%" /><col style="width: 74%" /></colgroup><thead><tr class="header"><th>属性</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>id</code></td><td>该step的全局唯一ID</td></tr><tr class="even"><td><code>image</code></td><td>step的 png 图标图像的资源位置</td></tr><tr class="odd"><td><code>name</code></td><td>step的简短标签</td></tr><tr class="even"><td><code>description</code></td><td>该step的详细说明</td></tr><tr class="odd"><td><code>categoryDescription</code></td><td>step应该出现在 PDI step树中的类别。例如输入、输出、转换等。</td></tr><tr class="even"><td><code>i18nPackageName</code></td><td>如果<code>i18nPackageName</code>在注释属性中提供了该属性，则名称、描述和类别描述的值将被解释为<code>i18n</code>与给定包中包含的消息包相关的键。密钥可以在扩展形式<code>i18n:&lt;packagename&gt;</code>密钥中提供，以指定与属性中给定的包不同的包<code>i18nPackageName</code>。</td></tr></tbody></table></li></ul><h3id="stepdialoginterfacebasestepdialog">StepDialogInterface(BaseStepDialog)</h3><p>本节介绍如何在插件中创建step设置对话框。</p><p>StepDialogInterface 是实现插件设置对话框的 Java 接口。</p><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr class="header"><th><strong>Java接口</strong></th><th><ahref="http://javadoc.pentaho.com/kettle530/kettle-engine-5.3.0.0-javadoc/org/pentaho/di/trans/step/StepDialogInterface.html">org.pentaho.di.trans.step.StepDialogInterface</a></th></tr></thead><tbody><tr class="odd"><td><strong>基类</strong></td><td><ahref="http://javadoc.pentaho.com/kettle530/kettle-ui-swt-5.3.0.0-javadoc/org/pentaho/di/ui/trans/step/BaseStepDialog.html">org.pentaho.di.ui.trans.step.BaseStepDialog</a></td></tr></tbody></table><ul><li><p>维护step设置对话框</p><p>该类<code>dialog</code>负责构建和打开step的设置对话框。每当在 PDI客户端（Spoon）中打开step设置时，系统都会实例化<code>dialog</code>传入对象<code>StepMetaInterface</code>并调用<code>open()</code>对话框的类。<ahref="http://www.eclipse.org/swt/">SWT</a>是 PDI客户端的本地窗口环境，是用于实现step对话框的框架。</p><ul><li><p><code>public String open()</code></p><p>此方法仅在对话框被确认或取消后返回。该方法必须符合这些规则。</p><ul><li>如果确认对话框<ul><li><code>StepMetaInterface</code>必须更新对象以反映新的step设置</li><li>如果您更改了任何step设置，则对象标志的更改标志<code>StepMetaInterface</code>必须设置为<code>true</code></li><li><code>open()</code>返回step的名称</li></ul></li><li>如果对话框被取消<ul><li><code>StepMetaInterface</code>不得更改对象</li><li>对象的 Changed 标志<code>StepMetaInterface</code>必须设置为对话框打开时的值</li><li><code>open()</code>必须返回<code>null</code></li></ul></li></ul></li></ul><p>该<code>StepMetaInterface</code>对象有一个内部<em>Changed</em>标志，可以使用<code>hasChanged()</code>和访问<code>setChanged()</code>。PDI客户端根据<em>Changed</em>标志决定转换是否有未保存的更改，因此对话适当设置标志很重要。</p></li></ul><h3 id="stepinterfacebasestep">StepInterface(BaseStep)</h3><p>本节介绍如何在插件中实现行处理。</p><p>实现 StepInterface 的类负责转换运行时的实际行处理。</p><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr class="header"><th><strong>Java接口</strong></th><th><ahref="http://javadoc.pentaho.com/kettle530/kettle-engine-5.3.0.0-javadoc/org/pentaho/di/trans/step/StepInterface.html">org.pentaho.di.trans.step.StepInterface</a></th></tr></thead><tbody><tr class="odd"><td><strong>基类</strong></td><td><ahref="http://javadoc.pentaho.com/kettle530/kettle-engine-5.3.0.0-javadoc/org/pentaho/di/trans/step/BaseStep.html">org.pentaho.di.trans.step.BaseStep</a></td></tr></tbody></table><p>实现类可以依赖基类，它自己实现的重要方法只有三个。这三个方法实现了转换执行过程中的step生命周期：初始化、行处理和清理。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/img/202306020116452.png" /></p><p>在初始化过程中，PDI调用<code>init()</code>一次step的方法。在所有step都已初始化后，PDI<code>processRow()</code>重复调用，直到该step发出信号表明它已完成对所有行的处理。该step完成处理行后，PDI调用<code>dispose()</code>.</p><p>方法签名有一个<ahref="http://javadoc.pentaho.com/kettle530/kettle-engine-5.3.0.0-javadoc/org/pentaho/di/trans/step/StepMetaInterface.html">StepMetaInterface</a>对象和一个<ahref="http://javadoc.pentaho.com/kettle530/kettle-engine-5.3.0.0-javadoc/org/pentaho/di/trans/step/StepDataInterface.html">StepDataInterface</a>对象。这两个对象都可以安全地转换为step的特定实现类。</p><p>除了它需要实现的方法之外，还有一条非常重要的附加规则：该类不得声明任何字段。所有变量都必须保留为实现类的一部分<code>StepDataInterface</code>。实际上这不是问题，因为对象实现<code>StepDataInterface</code>被传递给所有相关方法，并且使用它的字段而不是本地字段。这条规则的原因是需要将step变量与<code>StepInterface</code>.这使 PDI 能够实现不同的线程模型来执行转换。</p><ul><li><p>step初始化</p><p><code>init()</code>当转换准备开始执行时调用该方法。</p><ul><li><p><code>public boolean init()</code></p><p>每一步都有机会执行一次性初始化任务，例如打开文件或建立数据库连接。对于从派生的任何step<code>BaseStep</code>，必须<code>super.init()</code>调用以确保正确的行为。该方法<code>true</code>在step正确初始化的情况下返回，<code>false</code>如果存在初始化错误则返回。如果任何step在初始化时返回，PDI将中止转换的执行 <code>false</code>。</p></li></ul></li><li><p>行处理</p><p>转换开始后，它会进入一个紧密循环，调用<code>processRow()</code>每个step，直到方法返回<code>false</code>。在大多数情况下，每个step从输入流中读取一行，更改行结构和字段，并将该行传递给下一步。某些step，例如输入、分组和排序step，会批量读取行，或者可以在将读取的行传递给下一步之前保留读取的行以执行其他处理。</p><ul><li><p><code>public boolean processRow()</code></p><p>PDIstep通过调用查询传入的输入行<code>getRow()</code>，这是一个返回行对象的阻塞调用，或者<code>null</code>在没有更多输入的情况下。如果有输入行，该step将执行必要的行处理并调用<code>putRow()</code>以将该行传递给下一步。如果没有更多行，该step将调用<code>setOutputDone()</code>并返回<code>false</code>。</p></li></ul><p>该方法必须符合这些规则。</p><ul><li>如果该step处理完所有行，则该方法调用<code>setOutputDone()</code>并返回<code>false</code>。</li><li>如果该step未处理完所有行，则该方法返回<code>true</code>。在这种情况下，PDI再次调用 <code>processRow()</code>。</li></ul><p>与此相反，输入step通常不期望任何来自先前step的传入行。它们旨在执行<code>processRow(</code>)恰好一次，从外部世界获取数据，并通过重复调用直到完成将它们放入行流中<code>putRow()</code>。检查现有的PDI step是设计方法的良好指南<code>processRow()</code>。</p><p>行结构对象在第一次调用期间用于<code>processRow()</code>确定step所操作的字段的索引。该类<code>BaseStep</code>已经提供了一个方便的 First标志，以帮助在第一次调用<code>processRow()</code>.由于行结构对于所有输入行都是相同的，因此step将字段索引信息缓存在其<code>StepDataInterface</code>对象的变量中。</p></li><li><p>step清理</p><p>转换完成后，PDI 调用 <code>dispose()</code>所有step。</p><ul><li><p><code>Public void dispose()</code></p><p>需要采取step来解除分配在行处理期间<code>init()</code>或后续行处理期间分配的资源。您的实现应该清除对象的所有字段<code>StepDataInterface</code>，并确保所有打开的文件或连接都已正确关闭。对于从派生的任何step<code>BaseStep</code>，必须<code>super.dispose()</code>调用它以确保正确解除分配。</p></li></ul></li></ul><h3id="stepdatainterfacebasestepdata">StepDataInterface(BaseStepData)</h3><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr class="header"><th><strong>Java接口</strong></th><th><ahref="http://javadoc.pentaho.com/kettle530/kettle-engine-5.3.0.0-javadoc/org/pentaho/di/trans/step/StepDataInterface.html">org.pentaho.di.trans.step.StepDataInterface</a></th></tr></thead><tbody><tr class="odd"><td><strong>基类</strong></td><td><ahref="http://javadoc.pentaho.com/kettle530/kettle-engine-5.3.0.0-javadoc/org/pentaho/di/trans/step/BaseStepData.html">org.pentaho.di.trans.step.BaseStepData</a></td></tr></tbody></table><p>类实现<code>StepInterface</code>不在其任何字段中存储处理状态。相反，一个额外的类实现<code>StepDataInterface</code>用于存储处理状态，包括状态标志、索引、缓存表、数据库连接、文件句柄等。<code>StepDataInterface</code>声明行处理期间使用的字段并添加访问器函数的实现。本质上，类实现<code>StepDataInterface</code>用作行处理期间字段变量的位置。</p><p>PDI在适当的时间创建类实现的实例，并在适当的方法调用中将<code>StepDataInterface</code>其传递给对象。<code>StepInterface</code>基类已经实现了与PDI 的所有必要交互，无需覆盖任何基类方法。</p><h2 id="相关概念">相关概念</h2><h3 id="行处理">行处理</h3><p>PDI 中的一行由 Java 对象数组表示，<code>Object[]</code>.每个字段值都存储在行中的一个索引处。虽然数组表示形式可以有效地传递数据，但并不清楚如何确定与数组一起使用的字段名称和类型。行数组本身不携带此元数据。此外，表示一行的对象数组通常在其末尾有空槽，因此一行可以有效地容纳其他字段。因此，行数组的长度不等于行中字段的数量。以下部分解释了如何安全地访问行数组中的字段。</p><p><ahref="http://javadoc.pentaho.com/kettle530/kettle-core-5.3.0.0-javadoc/org/pentaho/di/core/row/RowMetaInterface.html">PDI使用实现RowMetaInterface</a>的内部对象来描述和操作行结构。在step中<code>processRow()</code>可以通过调用来检索传入行的结构<code>getInputRowMeta()</code>，这是由<code>BaseStep</code>类提供的。该step克隆该<code>RowMetaInterface</code>对象并将其传递给<code>getFields()</code>其元类，以反映由该step本身引起的行结构的任何更改。现在，该step具有<code>RowMetaInterface</code>描述输入和输出行的对象。这说明了如何使用<code>RowMetaInterface</code>对象来检查行结构。</p><p>有一个类似的对象保存有关各个行字段的信息。<ahref="http://javadoc.pentaho.com/kettle530/kettle-core-5.3.0.0-javadoc/org/pentaho/di/core/row/ValueMetaInterface.html">PDI使用实现ValueMetaInterface的</a>内部对象来描述和操作字段信息，例如字段名称、数据类型、格式掩码等。</p><p>step在第一次执行时查找相关字段的索引和类型<code>processRow()</code>。这些方法<code>RowMetaInterface</code>可用于实现此目的。</p><table><colgroup><col style="width: 36%" /><col style="width: 63%" /></colgroup><thead><tr class="header"><th>方法</th><th>目的</th></tr></thead><tbody><tr class="odd"><td><code>indexOfValue(String valueName)</code></td><td>给定一个字段名，确定该字段在行中的索引。</td></tr><tr class="even"><td><code>getFieldNames()</code></td><td>返回字段名称数组。字段名称的索引与行数组中的字段索引匹配。</td></tr><tr class="odd"><td><code>searchValueMeta(String valueName)</code></td><td>给定一个字段名称，确定该字段的元数据。</td></tr><tr class="even"><td><code>getValueMeta(int index)</code></td><td>给定字段索引，确定该字段的元数据。</td></tr><tr class="odd"><td><code>getValueMetaList()</code></td><td>返回所有字段描述的列表。字段描述的索引与行数组中的字段索引匹配。</td></tr></tbody></table><p>如果某个step需要创建行的副本，请使用 的方法<code>cloneRow()</code>创建<code>RowMetaInterface</code>适当的副本。如果某个step需要添加或删除行数组中的字段，请使用<ahref="http://javadoc.pentaho.com/kettle530/kettle-core-5.3.0.0-javadoc/org/pentaho/di/core/row/RowDataUtil.html">RowDataUtil</a>的静态帮助器方法。例如，如果一个step是向行中添加一个字段，请调用<code>resizeArray()</code>,以添加该字段。如果数组有足够的槽，则原始数组按原样重新排列。如果数组没有足够的槽，则返回数组的调整大小的副本。如果某个step需要从头开始创建新行，请使用<code>allocateRowData()</code>，它会返回一个稍微过度分配的对象数组以适应所需的字段数。</p><p>行处理类和接口汇总表</p><table><colgroup><col style="width: 71%" /><col style="width: 28%" /></colgroup><thead><tr class="header"><th>接口</th><th>目的</th></tr></thead><tbody><tr class="odd"><td><ahref="http://javadoc.pentaho.com/kettle530/kettle-core-5.3.0.0-javadoc/org/pentaho/di/core/row/RowMetaInterface.html">RowMetaInterface</a></td><td>描述和操作行结构</td></tr><tr class="even"><td><ahref="http://javadoc.pentaho.com/kettle530/kettle-core-5.3.0.0-javadoc/org/pentaho/di/core/row/ValueMetaInterface.html">ValueMetaInterface</a></td><td>描述和操作字段类型和格式</td></tr><tr class="odd"><td><ahref="http://javadoc.pentaho.com/kettle530/kettle-core-5.3.0.0-javadoc/org/pentaho/di/core/row/RowDataUtil.html">RowDataUtil</a></td><td>在行数组中分配空间</td></tr></tbody></table><h3 id="相关字段">相关字段</h3><h4 id="数据类型">数据类型</h4><p><ahref="http://javadoc.pentaho.com/kettle530/kettle-core-5.3.0.0-javadoc/org/pentaho/di/core/row/ValueMetaInterface.html">ValueMetaInterface</a>对象用于确定行字段的特征。它们通常是从一个<code>RowMetaInterface</code>对象中获得的，该对象是通过调用<code>getInputRowMeta()</code>. 该方法返回<ahref="http://javadoc.pentaho.com/kettle530/kettle-core-5.3.0.0-javadoc/org/pentaho/di/core/row/ValueMetaInterface.html">ValueMetaInterface</a><code>getType()</code>声明的静态常量之一，以指示PDI 字段类型。每个字段类型都映射到实际值的相应本机 Java类型。下表说明了最常用字段类型的映射。</p><table><colgroup><col style="width: 13%" /><col style="width: 15%" /><col style="width: 24%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th>PDI 数据类型</th><th>类型常量</th><th>Java数据类型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>String</td><td>TYPE_STRING</td><td><code>java.lang.String</code></td><td>以 UTF-8 (Unicode) 编码的可变无限长度文本</td></tr><tr class="even"><td>Integer</td><td>TYPE_INTEGER</td><td><code>java.lang.Long</code></td><td>带符号的长 64 位整数</td></tr><tr class="odd"><td>NUMBER</td><td>TYPE_NUMBER</td><td><code>java.lang.Double</code></td><td>双精度浮点值</td></tr><tr class="even"><td>BIGNUMBER</td><td>TYPE_BIGNUMBER</td><td><code>java.math.BigDecimal</code></td><td>任意无限精度数</td></tr><tr class="odd"><td>DATE</td><td>TYPE_DATE</td><td><code>java.util.Date</code></td><td>具有毫秒精度的日期时间值</td></tr><tr class="even"><td>BOOLEAN</td><td>TYPE_BOOLEAN</td><td><code>java.lang.Boolean</code></td><td>布尔值<code>true</code>或<code>false</code></td></tr><tr class="odd"><td>BINARY</td><td>TYPE_BINARY</td><td><code>java.lang.byte[]</code></td><td>包含任何类型的二进制数据的字节数组。</td></tr></tbody></table><p>不要假设行字段的 Java值直接匹配这些数据类型。根据字段使用的存储类型，这可能是正确的，也可能不是正确的。</p><h4 id="存储类型">存储类型</h4><p>除了字段的数据类型之外，存储类型<code>getStorageType()</code>/<code>setStorageType()</code>还用于解释行数组中的实际字段值。这些存储类型可用。</p><table><colgroup><col style="width: 24%" /><col style="width: 18%" /><col style="width: 57%" /></colgroup><thead><tr class="header"><th>常量</th><th>实际字段类型</th><th>Interpretation</th></tr></thead><tbody><tr class="odd"><td>STORAGE_TYPE_NORMAL</td><td>跟上面列表相同</td><td>行数组中的值是上面数据类型表中列出的类型，直接表示字段值。</td></tr><tr class="even"><td>STORAGE_TYPE_BINARY_STRING</td><td><code>java.lang.byte[]</code></td><td>该字段是使用惰性转换功能创建的。这意味着它是从外部介质（通常是文件）读取的未更改的字节序列。</td></tr><tr class="odd"><td>STORAGE_TYPE_INDEXED</td><td><code>java.lang.Integer</code></td><td>行值是可能值的固定数组的整数索引。该对象在<em>/</em><code>ValueMetaInterface</code>中维护可能值的集合<code>getIndex()``setIndex()</code></td></tr></tbody></table><h4 id="访问行值">访问行值</h4><p>在典型的数据处理场景中，一个step对处理存储类型的复杂性不感兴趣。它只需要对其进行处理的实际数据值。为了安全地读取字段的值，该<code>ValueMetaInterface</code>对象提供了一组访问器方法来获取实际的Java值。参数是来自与<code>ValueMetaInterface</code>对象对应的行数组的值。无论字段存储类型如何，访问器方法始终返回正确的数据值。</p><ul><li><code>getString()</code></li><li><code>getInteger()</code></li><li><code>getNumber()</code></li><li><code>getBigNumber()</code></li><li><code>sgetDate()</code></li><li><code>getBoolean()</code></li><li><code>getBinary()</code></li></ul><p>对于这些方法中的每一个，<code>RowMetaInterface</code>都有相应的方法需要行数组和字段的索引作为参数。</p><h4 id="格外字段">格外字段</h4><p><ahref="http://javadoc.pentaho.com/kettle530/kettle-core-5.3.0.0-javadoc/org/pentaho/di/core/row/ValueMetaInterface.html">ValueMetaInterface</a>表示PDI字段的所有方面，包括转换掩码、修剪类型等。所有这些都可以使用相应的访问器方法获得，例如<ahref="http://javadoc.pentaho.com/kettle/org/pentaho/di/core/row/ValueMetaInterface.html#getConversionMask()">getConversionMask()</a>和<ahref="http://javadoc.pentaho.com/kettle/org/pentaho/di/core/row/ValueMetaInterface.html#getTrimType()">getTrimType()</a>。</p><h3 id="错误处理">错误处理</h3><p>转换step可能会在许多级别遇到错误。他们可能会遇到意想不到的数据，或者执行环境的问题。根据错误的性质，该step可能决定通过抛出异常来停止转换，或者支持PDI 错误处理功能，这允许您将坏行转移到错误处理step。</p><h4 id="抛出-kettleexception调用强制停止">抛出KettleException：调用强制停止</h4><p>如果某个step在行处理期间遇到错误，它可能会记录错误并停止转换。这是通过调用<code>setErrors(1)</code>、<code>stopAll()</code>、<code>setOutputDone()</code>并返回<code>false</code>来完成的<code>processRow()</code>。或者该step可以抛出一个<ahref="http://javadoc.pentaho.com/kettle530/kettle-core-5.3.0.0-javadoc/org/pentaho/di/core/exception/KettleException.html"><code>KettleException</code></a>，这也会导致转换停止。</p><p>当环境或step配置出现问题时停止转换是明智的。例如，当无法建立数据库连接、所需文件不存在或行流中不存在预期字段时。这些错误会影响整个转换的执行。另一方面，如果错误与行数据相关，则该step应实现对PDI 错误处理功能的支持。</p><h4 id="行计数器">行计数器</h4><p>在转换执行期间，每个 PDI step都会跟踪一组step指标。这些显示在 PDI客户端 (Spoon) 的 <strong>Step Metrics</strong>选项卡中。</p><h2 id="部署step插件">部署step插件</h2><ol type="1"><li><p>创建一个包含插件类和资源的 JAR 文件</p></li><li><p>创建一个新文件夹，然后将 JAR 文件放在该文件夹中</p></li><li><p>将刚刚创建的插件文件夹放在特定位置，供 PDI 查找。</p><p>根据使用 PDI的方式，需要将插件文件夹复制到一个或多个位置，如下所示。</p><ul><li>部署到 PDI 客户端 (Spoon) 或 Carte：<ol type="1"><li>将插件文件夹复制到此位置：design-tools/data-integration/plugins/steps。</li><li>重新启动 PDI 客户端。重新启动 PDI客户端后，新的作业条目就可以使用了。</li></ol></li><li>部署到 Pentaho 服务器：<ol type="1"><li>将数据集成插件文件夹复制到此位置：server/pentaho-server/pentaho-solutions/system/kettle/plugins/steps。</li><li>将业务分析插件文件夹复制到此位置：server/pentaho-server/pentaho-solutions/system/kettle/plugins/steps。</li><li>重新启动服务器。重启 Pentaho Server后，插件就可以在服务器上使用了。</li></ol></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>开源之夏2023</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kettle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VTK学习笔记（四）</title>
    <link href="/post/ba05651e.html"/>
    <url>/post/ba05651e.html</url>
    
    <content type="html"><![CDATA[<p>本系列文章主要对<ahref="https://vtk.org/">VTK</a>的相关知识进行总结。 <span id="more"></span></p><h1 id="vtk学习笔记四">VTK学习笔记（四）</h1><h2 id="图像颜色映射">图像颜色映射📸</h2><h4 id="图像灰度映射">图像灰度映射🥫</h4><p>vtkImageLuminance负责将一个RGB彩色图像转换为一个单组分的灰度图像。映射公式如下：</p><p><span class="math inline">\(luminance = 0.3*R + 0.59*G +0.11*B\)</span></p><p>该公式中，R为输入图像的第一分量（红色），G为第二分量（绿色），B为第三分量（蓝色）。这个计算结果计算一个RGB颜色的亮度。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br><br>    vtkSmartPointer&lt;vtkImageLuminance&gt; luminanceFilter = vtkSmartPointer&lt;vtkImageLuminance&gt;::<span class="hljs-built_in">New</span>();<br>    luminanceFilter-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>    luminanceFilter-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageActor&gt; originalActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>originalActor-&gt;<span class="hljs-built_in">SetInputData</span>(reader-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; shiftscaleActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>shiftscaleActor-&gt;<span class="hljs-built_in">SetInputData</span>(luminanceFilter-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br><span class="hljs-type">double</span> originalViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> shiftscaleViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> &#125;;<br><br>vtkSmartPointer&lt;vtkRenderer&gt; originalRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>originalRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(originalViewport);<br>originalRenderer-&gt;<span class="hljs-built_in">AddActor</span>(originalActor);<br>originalRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>originalRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; shiftscaleRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(shiftscaleViewport);<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">AddActor</span>(shiftscaleActor);<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(originalRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(shiftscaleRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">640</span>, <span class="hljs-number">320</span>);<br>renderWindow-&gt;<span class="hljs-built_in">Render</span>();<br><br>vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>vtkSmartPointer&lt;vtkInteractorStyleImage&gt; style = vtkSmartPointer&lt;vtkInteractorStyleImage&gt;::<span class="hljs-built_in">New</span>();<br><br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renderWindow);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Initialize</span>();<br><br>renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212071541869.png" style="zoom:67%;" /></p><p>上例中读入一副RGB彩色图像，通过vtkImageLuminance转换为灰度图像。</p><hr /><h4 id="提取颜色分量">提取颜色分量🥙</h4><p>VTK中利用vtkImageExtractComponents可以方便的提取出彩色图像的各个颜色分量，该类的使用比较简单，只需要设置要提取的分量序号即可。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br><br>vtkSmartPointer&lt;vtkImageExtractComponents&gt; extractRedFilter = vtkSmartPointer&lt;vtkImageExtractComponents&gt;::<span class="hljs-built_in">New</span>();<br>extractRedFilter-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>extractRedFilter-&gt;<span class="hljs-built_in">SetComponents</span>(<span class="hljs-number">0</span>);<br>extractRedFilter-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageExtractComponents&gt; extractGreenFilter = vtkSmartPointer&lt;vtkImageExtractComponents&gt;::<span class="hljs-built_in">New</span>();<br>extractGreenFilter-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>extractGreenFilter-&gt;<span class="hljs-built_in">SetComponents</span>(<span class="hljs-number">1</span>);<br>extractGreenFilter-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageExtractComponents&gt; extractBlueFilter = vtkSmartPointer&lt;vtkImageExtractComponents&gt;::<span class="hljs-built_in">New</span>();<br>extractBlueFilter-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>extractBlueFilter-&gt;<span class="hljs-built_in">SetComponents</span>(<span class="hljs-number">2</span>);<br>extractBlueFilter-&gt;<span class="hljs-built_in">Update</span>();<br><br><span class="hljs-comment">// Create actors</span><br>vtkSmartPointer&lt;vtkImageActor&gt; inputActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>inputActor-&gt;<span class="hljs-built_in">SetInputData</span>(reader-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; redActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>redActor-&gt;<span class="hljs-built_in">SetInputData</span>(extractRedFilter-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; greenActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>greenActor-&gt;<span class="hljs-built_in">SetInputData</span>(extractGreenFilter-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; blueActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>blueActor-&gt;<span class="hljs-built_in">SetInputData</span>(extractBlueFilter-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br><span class="hljs-type">double</span> inputViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> redViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.25</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> greenViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.75</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> blueViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.75</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> &#125;;<br><br>vtkSmartPointer&lt;vtkRenderer&gt; inputRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>inputRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(inputViewport);<br>inputRenderer-&gt;<span class="hljs-built_in">AddActor</span>(inputActor);<br>inputRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>inputRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; redRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>redRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(redViewport);<br>redRenderer-&gt;<span class="hljs-built_in">AddActor</span>(redActor);<br>redRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>redRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; greenRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>greenRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(greenViewport);<br>greenRenderer-&gt;<span class="hljs-built_in">AddActor</span>(greenActor);<br>greenRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>greenRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; blueRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>blueRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(blueViewport);<br>blueRenderer-&gt;<span class="hljs-built_in">AddActor</span>(blueActor);<br>blueRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>blueRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(inputRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(redRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(greenRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(blueRenderer);<br><br>renderWindow-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">1200</span>, <span class="hljs-number">300</span>);<br>renderWindow-&gt;<span class="hljs-built_in">Render</span>();<br><br>vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>vtkSmartPointer&lt;vtkInteractorStyleImage&gt; style = vtkSmartPointer&lt;vtkInteractorStyleImage&gt;::<span class="hljs-built_in">New</span>();<br><br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renderWindow);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Initialize</span>();<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212071541419.png" style="zoom: 67%;" /></p><p>代码中定义了三个vtkImageExtractComponents对象，分别用来提取红、绿和蓝色分量图像，函数SetComponents用来设置要提取的分量号，红绿蓝分别对应0,1和2。设置完毕后执行Update()即可得到每个一个分量部分。其输出为vtkImageData，每一个颜色分量数据即是一个灰度图像。</p><hr /><h4 id="图像彩色映射">图像彩色映射☕</h4><p>图像彩色映射的原理是首先生成一个颜色查找表，然后根据图像的一个标量值向颜色查找表中查找对应的颜色，并用新颜色值替代原来的像素值。VTK中vtkImageMapToColors负责图像彩色映射，vtkLookUpTable负责生成颜色查找表。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vtkSmartPointer&lt;vtkJPEGReader&gt; reader = vtkSmartPointer&lt;vtkJPEGReader&gt;::<span class="hljs-built_in">New</span>();<br>reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena-gray.jpg&quot;</span>);<br><br>vtkSmartPointer&lt;vtkLookupTable&gt; colorTable = vtkSmartPointer&lt;vtkLookupTable&gt;::<span class="hljs-built_in">New</span>();<br>colorTable-&gt;<span class="hljs-built_in">SetRange</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">255.0</span>);<br>colorTable-&gt;<span class="hljs-built_in">SetHueRange</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.5</span>);<br>colorTable-&gt;<span class="hljs-built_in">SetValueRange</span>(<span class="hljs-number">0.6</span>, <span class="hljs-number">1.0</span>);<br>colorTable-&gt;<span class="hljs-built_in">Build</span>();<br><br>vtkSmartPointer&lt;vtkImageMapToColors&gt; colorMap = vtkSmartPointer&lt;vtkImageMapToColors&gt;::<span class="hljs-built_in">New</span>();<br>colorMap-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>colorMap-&gt;<span class="hljs-built_in">SetLookupTable</span>(colorTable);<br>colorMap-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageActor&gt; originalActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>originalActor-&gt;<span class="hljs-built_in">SetInputData</span>(reader-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; shiftscaleActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>shiftscaleActor-&gt;<span class="hljs-built_in">SetInputData</span>(colorMap-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br><span class="hljs-type">double</span> originalViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> shiftscaleViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> &#125;;<br><br>vtkSmartPointer&lt;vtkRenderer&gt; originalRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>originalRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(originalViewport);<br>originalRenderer-&gt;<span class="hljs-built_in">AddActor</span>(originalActor);<br>originalRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>originalRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; shiftscaleRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(shiftscaleViewport);<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">AddActor</span>(shiftscaleActor);<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.8</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(originalRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(shiftscaleRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">900</span>, <span class="hljs-number">300</span>);<br>renderWindow-&gt;<span class="hljs-built_in">Render</span>();<br><br>vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>vtkSmartPointer&lt;vtkInteractorStyleImage&gt; style = vtkSmartPointer&lt;vtkInteractorStyleImage&gt;::<span class="hljs-built_in">New</span>();<br><br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renderWindow);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Initialize</span>();<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212071541543.png" style="zoom:67%;" /></p><p>首先读取了一个灰度图像，然后生成vtkLookUpTable颜色查找表。构造颜色查找表有两种方法，一种是直接添加颜色，另一种是设置HSV颜色空间变化范围（hue,saturation,value），然后自动生成颜色表。这里采用的是第二种方法，SetRange设置要映射的标量数据的范围；SetHueRange设置HSV颜色空间的Hue值范围，最大范围为[0,1];SetValueRange设置HSV颜色空间的Value范围，最大范围为[0,1]；设置完后，调用Build()来生成颜色查找表。接下来定义vtkImageMapToColors对象，SetLookupTable()设置相应的颜色查找表，执行Update()后，其输出为一副彩色图像。</p><hr /><h4 id="颜色合成">颜色合成🥝</h4><p>我们可以将灰度图像合并成为一个彩色图像。VTK中提供vtkImageAppendComponents类来合成彩色图像，其输入需要提供三个灰度图像。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vtkSmartPointer&lt;vtkImageCanvasSource2D&gt; red = vtkSmartPointer&lt;vtkImageCanvasSource2D&gt;::<span class="hljs-built_in">New</span>();<br>red-&gt;<span class="hljs-built_in">SetScalarTypeToUnsignedChar</span>();<br>red-&gt;<span class="hljs-built_in">SetNumberOfScalarComponents</span>(<span class="hljs-number">1</span>);<br>red-&gt;<span class="hljs-built_in">SetExtent</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>red-&gt;<span class="hljs-built_in">SetDrawColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>red-&gt;<span class="hljs-built_in">FillBox</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>red-&gt;<span class="hljs-built_in">SetDrawColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>red-&gt;<span class="hljs-built_in">FillBox</span>(<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">20</span>, <span class="hljs-number">40</span>);<br>red-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageCanvasSource2D&gt; green = vtkSmartPointer&lt;vtkImageCanvasSource2D&gt;::<span class="hljs-built_in">New</span>();<br>green-&gt;<span class="hljs-built_in">SetScalarTypeToUnsignedChar</span>();<br>green-&gt;<span class="hljs-built_in">SetNumberOfScalarComponents</span>(<span class="hljs-number">1</span>);<br>green-&gt;<span class="hljs-built_in">SetExtent</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>green-&gt;<span class="hljs-built_in">SetDrawColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>green-&gt;<span class="hljs-built_in">FillBox</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>green-&gt;<span class="hljs-built_in">SetDrawColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>green-&gt;<span class="hljs-built_in">FillBox</span>(<span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span>);<br>green-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageCanvasSource2D&gt; blue = vtkSmartPointer&lt;vtkImageCanvasSource2D&gt;::<span class="hljs-built_in">New</span>();<br>blue-&gt;<span class="hljs-built_in">SetScalarTypeToUnsignedChar</span>();<br>blue-&gt;<span class="hljs-built_in">SetNumberOfScalarComponents</span>(<span class="hljs-number">1</span>);<br>blue-&gt;<span class="hljs-built_in">SetExtent</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>blue-&gt;<span class="hljs-built_in">SetDrawColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>blue-&gt;<span class="hljs-built_in">FillBox</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>blue-&gt;<span class="hljs-built_in">SetDrawColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>blue-&gt;<span class="hljs-built_in">FillBox</span>(<span class="hljs-number">40</span>, <span class="hljs-number">60</span>, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>);<br>blue-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageAppendComponents&gt; appendFilter = vtkSmartPointer&lt;vtkImageAppendComponents&gt;::<span class="hljs-built_in">New</span>();<br>appendFilter-&gt;<span class="hljs-built_in">SetInputConnection</span>(<span class="hljs-number">0</span>, red-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>appendFilter-&gt;<span class="hljs-built_in">AddInputConnection</span>(<span class="hljs-number">0</span>, green-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>appendFilter-&gt;<span class="hljs-built_in">AddInputConnection</span>(<span class="hljs-number">0</span>, blue-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>appendFilter-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageActor&gt; redActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>redActor-&gt;<span class="hljs-built_in">SetInputData</span>(red-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; greenActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>greenActor-&gt;<span class="hljs-built_in">SetInputData</span>(green-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; blueActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>blueActor-&gt;<span class="hljs-built_in">SetInputData</span>(blue-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; combinedActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>combinedActor-&gt;<span class="hljs-built_in">SetInputData</span>(appendFilter-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br><span class="hljs-comment">// Define viewport ranges</span><br><span class="hljs-comment">// (xmin, ymin, xmax, ymax)</span><br><span class="hljs-type">double</span> redViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> greenViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.25</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> blueViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.75</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> combinedViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.75</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> &#125;;<br><br><span class="hljs-comment">// Setup renderers</span><br>vtkSmartPointer&lt;vtkRenderer&gt; redRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>redRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(redViewport);<br>redRenderer-&gt;<span class="hljs-built_in">AddActor</span>(redActor);<br>redRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>redRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; greenRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>greenRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(greenViewport);<br>greenRenderer-&gt;<span class="hljs-built_in">AddActor</span>(greenActor);<br>greenRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>greenRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; blueRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>blueRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(blueViewport);<br>blueRenderer-&gt;<span class="hljs-built_in">AddActor</span>(blueActor);<br>blueRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>blueRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; combinedRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>combinedRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(combinedViewport);<br>combinedRenderer-&gt;<span class="hljs-built_in">AddActor</span>(combinedActor);<br>combinedRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>combinedRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(redRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(greenRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(blueRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(combinedRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">1200</span>, <span class="hljs-number">300</span>);<br>renderWindow-&gt;<span class="hljs-built_in">Render</span>();<br><br>vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>vtkSmartPointer&lt;vtkInteractorStyleImage&gt; style = vtkSmartPointer&lt;vtkInteractorStyleImage&gt;::<span class="hljs-built_in">New</span>();<br><br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renderWindow);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Initialize</span>();<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212071541488.png" style="zoom:67%;" /></p><p>上面代码中利用vtkImageCanvasSource2D定义了3个二值图像，每个图像中绘制了一个白色矩形，并且三个矩形有部分重叠，然后定义vtkImageAppendComponents对象，并将三个图像设置为vtkImageAppendComponents对象的输入来合成图像。合成的效果为三个图像中对应的三个像素点像素值合成为输出图像的RGB像素值，如三个图像中第100个像素的像素值分别为，255，0和0，那么该点在输出图像中的像素值为（255,0, 0），显示为红色。</p><hr /><h2 id="区域提取">区域提取🌸</h2><h4 id="提取感兴趣区域">提取感兴趣区域🛩️</h4><p>感兴趣区域（Volum ofInterest）是指图像内部的一个子区域。在VTK中vtkExtractVOI类实现由用户指定的区域范围提取图像的子图像。该Filter的输入和输出都是一个vtkImageData，因此其结果可以直接作为图像保存。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>reader-&gt;<span class="hljs-built_in">Update</span>();<br><br><span class="hljs-type">int</span> dims[<span class="hljs-number">3</span>];<br>reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetDimensions</span>(dims);<br><br>vtkSmartPointer&lt;vtkExtractVOI&gt; extractVOI = vtkSmartPointer&lt;vtkExtractVOI&gt;::<span class="hljs-built_in">New</span>();<br>extractVOI-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>extractVOI-&gt;<span class="hljs-built_in">SetVOI</span>(dims[<span class="hljs-number">0</span>] / <span class="hljs-number">4.</span>, <span class="hljs-number">3.</span> * dims[<span class="hljs-number">0</span>] / <span class="hljs-number">4.</span>, dims[<span class="hljs-number">1</span>] / <span class="hljs-number">4.</span>, <span class="hljs-number">3.</span> * dims[<span class="hljs-number">1</span>] / <span class="hljs-number">4.</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>extractVOI-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageActor&gt; originalActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>originalActor-&gt;<span class="hljs-built_in">SetInputData</span>(reader-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; voiActor =<br>vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>voiActor-&gt;<span class="hljs-built_in">SetInputData</span>(extractVOI-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br><span class="hljs-type">double</span> originalViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> voiviewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> &#125;;<br><br>vtkSmartPointer&lt;vtkRenderer&gt; originalRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>originalRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(originalViewport);<br>originalRenderer-&gt;<span class="hljs-built_in">AddActor</span>(originalActor);<br>originalRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>originalRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; shiftscaleRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(voiviewport);<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">AddActor</span>(voiActor);<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>shiftscaleRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(originalRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(shiftscaleRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">900</span>, <span class="hljs-number">300</span>);<br>renderWindow-&gt;<span class="hljs-built_in">Render</span>();<br><br><br>vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>vtkSmartPointer&lt;vtkInteractorStyleImage&gt; style = vtkSmartPointer&lt;vtkInteractorStyleImage&gt;::<span class="hljs-built_in">New</span>();<br><br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renderWindow);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Initialize</span>();<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212071541550.png" style="zoom:50%;" /></p><p>上例代码实现了提取一副图像的子区域。首先读取一个图像，并获取图像的维数。然后定义vtkExtractVOI对象，该对象接收两个输入一个是图像数据，第二个是区域大小。设置区域大小的函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetVOI</span><span class="hljs-params">(<span class="hljs-type">int</span> _arg1, <span class="hljs-type">int</span> _arg2, <span class="hljs-type">int</span> _arg3, <span class="hljs-type">int</span> _arg4, <span class="hljs-type">int</span> _arg5, <span class="hljs-type">int</span> _arg6)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetVOI</span><span class="hljs-params">(<span class="hljs-type">int</span> _arg[])</span></span>;<br></code></pre></div></td></tr></table></figure><p>其参数是提取的区域各个方向的大小，共6个参数，依次表示x方向最小值，x方向最大值，y方向最小值，y方向最大值，z方向最小值和z方向最大值。上例中由于读取的是二维图像，因此z方向的区域为[0,0]，而在x方向范围为[<span class="math inline">\(\frac{dim[0]}{4}\)</span>, <spanclass="math inline">\(\frac{3*dim[0]}{4}\)</span>]，y方向范围为[ <spanclass="math inline">\(\frac{dim[1]}{4}\)</span> , <spanclass="math inline">\(\frac{3*dim[1]}{4}\)</span>]，即提取图像原图中间<spanclass="math inline">\(\frac{1}{4}\)</span>图像。</p><hr /><h4 id="三维图像切片提取">三维图像切片提取🏐</h4><p>切片是指三维图像中的一个切面对应的图像。切面可以是过图像内部一点且平行于XY、YZ、XZ平面的平面，也可以是任意的过三维图像内部一点任意方向的平面。通过提取切片可以方便的浏览和分析图像内部组织结构，是医学图像浏览软件中的一个重要的功能。在VTK中vtkImageReslice类实现图像切片提取功能。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vtkSmartPointer&lt;vtkMetaImageReader&gt; reader = vtkSmartPointer&lt;vtkMetaImageReader&gt;::<span class="hljs-built_in">New</span>();<br>reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;brain.mhd&quot;</span>);<br>reader-&gt;<span class="hljs-built_in">Update</span>();<br><br><span class="hljs-type">int</span> extent[<span class="hljs-number">6</span>];<br><span class="hljs-type">double</span> spacing[<span class="hljs-number">3</span>];<br><span class="hljs-type">double</span> origin[<span class="hljs-number">3</span>];<br><br>reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetExtent</span>(extent);<br>reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetSpacing</span>(spacing);<br>reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetOrigin</span>(origin);<br><br><span class="hljs-type">double</span> center[<span class="hljs-number">3</span>];<br>center[<span class="hljs-number">0</span>] = origin[<span class="hljs-number">0</span>] + spacing[<span class="hljs-number">0</span>] * <span class="hljs-number">0.5</span> * (extent[<span class="hljs-number">0</span>] + extent[<span class="hljs-number">1</span>]);<br>center[<span class="hljs-number">1</span>] = origin[<span class="hljs-number">1</span>] + spacing[<span class="hljs-number">1</span>] * <span class="hljs-number">0.5</span> * (extent[<span class="hljs-number">2</span>] + extent[<span class="hljs-number">3</span>]);<br>center[<span class="hljs-number">2</span>] = origin[<span class="hljs-number">2</span>] + spacing[<span class="hljs-number">2</span>] * <span class="hljs-number">0.5</span> * (extent[<span class="hljs-number">4</span>] + extent[<span class="hljs-number">5</span>]);<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> axialElements[<span class="hljs-number">16</span>] = &#123;<br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>&#125;;<br><br>vtkSmartPointer&lt;vtkMatrix4x4&gt; resliceAxes = vtkSmartPointer&lt;vtkMatrix4x4&gt;::<span class="hljs-built_in">New</span>();<br>resliceAxes-&gt;<span class="hljs-built_in">DeepCopy</span>(axialElements);<br>resliceAxes-&gt;<span class="hljs-built_in">SetElement</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, center[<span class="hljs-number">0</span>]);<br>resliceAxes-&gt;<span class="hljs-built_in">SetElement</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, center[<span class="hljs-number">1</span>]);<br>resliceAxes-&gt;<span class="hljs-built_in">SetElement</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, center[<span class="hljs-number">2</span>]);<br><br>vtkSmartPointer&lt;vtkImageReslice&gt; reslice = vtkSmartPointer&lt;vtkImageReslice&gt;::<span class="hljs-built_in">New</span>();<br>reslice-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>reslice-&gt;<span class="hljs-built_in">SetOutputDimensionality</span>(<span class="hljs-number">2</span>);<br>reslice-&gt;<span class="hljs-built_in">SetResliceAxes</span>(resliceAxes);<br>reslice-&gt;<span class="hljs-built_in">SetInterpolationModeToLinear</span>();<br><br>vtkSmartPointer&lt;vtkLookupTable&gt; colorTable = vtkSmartPointer&lt;vtkLookupTable&gt;::<span class="hljs-built_in">New</span>();<br>colorTable-&gt;<span class="hljs-built_in">SetRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>);<br>colorTable-&gt;<span class="hljs-built_in">SetValueRange</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>colorTable-&gt;<span class="hljs-built_in">SetSaturationRange</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br>colorTable-&gt;<span class="hljs-built_in">SetRampToLinear</span>();<br>colorTable-&gt;<span class="hljs-built_in">Build</span>();<br><br>vtkSmartPointer&lt;vtkImageMapToColors&gt; colorMap = vtkSmartPointer&lt;vtkImageMapToColors&gt;::<span class="hljs-built_in">New</span>();<br>colorMap-&gt;<span class="hljs-built_in">SetLookupTable</span>(colorTable);<br>colorMap-&gt;<span class="hljs-built_in">SetInputConnection</span>(reslice-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>colorMap-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageActor&gt; imgActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>imgActor-&gt;<span class="hljs-built_in">SetInputData</span>(colorMap-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkRenderer&gt; renderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>renderer-&gt;<span class="hljs-built_in">AddActor</span>(imgActor);<br>renderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(renderer);<br>renderWindow-&gt;<span class="hljs-built_in">Render</span>();<br>renderWindow-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>vtkSmartPointer&lt;vtkInteractorStyleImage&gt; imagestyle = vtkSmartPointer&lt;vtkInteractorStyleImage&gt;::<span class="hljs-built_in">New</span>();<br><br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(imagestyle);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renderWindow);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Initialize</span>();<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212071540729.png" style="zoom:67%;" /></p><p>首先通过vtkMetaImageReader读取一副医学三维图像，并获取得到图像范围（extent），原点和像素间隔；由这三个参数可以计算图像的中心位置center；接下来定义了切面的变换矩阵axialElements，该矩阵的前三列分别表示x、y和z方向向量，第四列为中心点坐标；代码中的axialElements表示切面变换矩阵与当前坐标系一致，且切面为过中心点center，并平行于XY平面的平面。当前，定义该切面时，也可以是其他平面，甚至是任意平面，但是必须要过图像内部点。下面给出了一个常用的变换矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">double</span> coronalElements[<span class="hljs-number">16</span>] = &#123;<br> <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br> <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;;   <span class="hljs-comment">//提取平行于XZ平面的切片</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> sagittalElements[<span class="hljs-number">16</span>] = &#123;<br> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>,<br> <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br> <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;;   <span class="hljs-comment">//提取平行于YZ平面的切片</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> obliqueElements[<span class="hljs-number">16</span>] = &#123;<br> <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br> <span class="hljs-number">0</span>, <span class="hljs-number">0.866025</span>, <span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>,<br> <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.866025</span>, <span class="hljs-number">0</span>,<br> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;;   <span class="hljs-comment">//提取斜切切片</span><br></code></pre></div></td></tr></table></figure><p>注意使用这些变换矩阵的时候，需要将第四列替换为切片经过图像的一个点坐标，上例中将图像的中心添加到axialElements矩阵，并通过函数SetResliceAxes设置变换矩阵，SetOutputDimensionality(2)指定输出的图像为一个二维图像；而函数SetInterpolationModeToLinear()则指定了切面提取中的差值方式为线性差值，另外该类中还提供了其他的差值方式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">SetInterpolationModeToNearestNeighbor</span>();  <span class="hljs-comment">//最近邻方式</span><br><span class="hljs-built_in">SetInterpolationModeToCubic</span>();  <span class="hljs-comment">//三次线性差值</span><br></code></pre></div></td></tr></table></figure><p>设置完毕后，执行Update()即可完成切面计算。</p><hr /><h4 id="扩展">扩展💎</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">vtkImageInteractionCallback</span> : <span class="hljs-keyword">public</span> vtkCommand<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> vtkImageInteractionCallback* <span class="hljs-title">New</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> vtkImageInteractionCallback;<br>&#125;<br><br><span class="hljs-built_in">vtkImageInteractionCallback</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Slicing = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">this</span>-&gt;ImageReslice = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">this</span>-&gt;Interactor = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetImageReslice</span><span class="hljs-params">(vtkImageReslice* reslice)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;ImageReslice = reslice;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetImageMapToColors</span><span class="hljs-params">(vtkImageMapToColors *mapToColors)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;mapToColors = mapToColors;<br>&#125;<br><br><span class="hljs-function">vtkImageReslice* <span class="hljs-title">GetImageReslice</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;ImageReslice;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetInteractor</span><span class="hljs-params">(vtkRenderWindowInteractor* interactor)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;Interactor = interactor;<br>&#125;<br><br><span class="hljs-function">vtkRenderWindowInteractor* <span class="hljs-title">GetInteractor</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;Interactor;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">(vtkObject*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> event, <span class="hljs-type">void</span>*)</span></span><br><span class="hljs-function"></span>&#123;<br>vtkRenderWindowInteractor* interactor = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">GetInteractor</span>();<br><br><span class="hljs-type">int</span> lastPos[<span class="hljs-number">2</span>];<br>interactor-&gt;<span class="hljs-built_in">GetLastEventPosition</span>(lastPos);<br><span class="hljs-type">int</span> currPos[<span class="hljs-number">2</span>];<br>interactor-&gt;<span class="hljs-built_in">GetEventPosition</span>(currPos);<br><br><span class="hljs-keyword">if</span> (event == vtkCommand::LeftButtonPressEvent)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Slicing = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event == vtkCommand::LeftButtonReleaseEvent)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Slicing = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event == vtkCommand::MouseMoveEvent)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Slicing)<br>&#123;<br>vtkImageReslice* reslice = <span class="hljs-keyword">this</span>-&gt;ImageReslice;<br><br><span class="hljs-comment">// Increment slice position by deltaY of mouse</span><br><span class="hljs-type">int</span> deltaY = lastPos[<span class="hljs-number">1</span>] - currPos[<span class="hljs-number">1</span>];<br><br>reslice-&gt;<span class="hljs-built_in">Update</span>();<br><span class="hljs-type">double</span> sliceSpacing = reslice-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetSpacing</span>()[<span class="hljs-number">2</span>];<br>vtkMatrix4x4* matrix = reslice-&gt;<span class="hljs-built_in">GetResliceAxes</span>();<br><span class="hljs-comment">// move the center point that we are slicing through</span><br><span class="hljs-type">double</span> point[<span class="hljs-number">4</span>];<br><span class="hljs-type">double</span> center[<span class="hljs-number">4</span>];<br>point[<span class="hljs-number">0</span>] = <span class="hljs-number">0.0</span>;<br>point[<span class="hljs-number">1</span>] = <span class="hljs-number">0.0</span>;<br>point[<span class="hljs-number">2</span>] = sliceSpacing * deltaY;<br>point[<span class="hljs-number">3</span>] = <span class="hljs-number">1.0</span>;<br>matrix-&gt;<span class="hljs-built_in">MultiplyPoint</span>(point, center);<br>matrix-&gt;<span class="hljs-built_in">SetElement</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, center[<span class="hljs-number">0</span>]);<br>matrix-&gt;<span class="hljs-built_in">SetElement</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, center[<span class="hljs-number">1</span>]);<br>matrix-&gt;<span class="hljs-built_in">SetElement</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, center[<span class="hljs-number">2</span>]);<br><br>mapToColors-&gt;<span class="hljs-built_in">Update</span>();<br>interactor-&gt;<span class="hljs-built_in">Render</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>vtkInteractorStyle* style = vtkInteractorStyle::<span class="hljs-built_in">SafeDownCast</span>(<br>interactor-&gt;<span class="hljs-built_in">GetInteractorStyle</span>());<br><span class="hljs-keyword">if</span> (style)<br>&#123;<br>style-&gt;<span class="hljs-built_in">OnMouseMove</span>();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> Slicing;<br>vtkImageReslice* ImageReslice;<br>vtkRenderWindowInteractor* Interactor;<br>vtkImageMapToColors* mapToColors;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vtkSmartPointer&lt;vtkMetaImageReader&gt; reader = vtkSmartPointer&lt;vtkMetaImageReader&gt;::<span class="hljs-built_in">New</span>();<br>reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;brain.mhd&quot;</span>);<br>reader-&gt;<span class="hljs-built_in">Update</span>();<br><br><span class="hljs-type">int</span> extent[<span class="hljs-number">6</span>];<br><span class="hljs-type">double</span> spacing[<span class="hljs-number">3</span>];<br><span class="hljs-type">double</span> origin[<span class="hljs-number">3</span>];<br><br>reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetExtent</span>(extent);<br>reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetSpacing</span>(spacing);<br>reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetOrigin</span>(origin);<br><br><span class="hljs-type">double</span> center[<span class="hljs-number">3</span>];<br>center[<span class="hljs-number">0</span>] = origin[<span class="hljs-number">0</span>] + spacing[<span class="hljs-number">0</span>] * <span class="hljs-number">0.5</span> * (extent[<span class="hljs-number">0</span>] + extent[<span class="hljs-number">1</span>]);<br>center[<span class="hljs-number">1</span>] = origin[<span class="hljs-number">1</span>] + spacing[<span class="hljs-number">1</span>] * <span class="hljs-number">0.5</span> * (extent[<span class="hljs-number">2</span>] + extent[<span class="hljs-number">3</span>]);<br>center[<span class="hljs-number">2</span>] = origin[<span class="hljs-number">2</span>] + spacing[<span class="hljs-number">2</span>] * <span class="hljs-number">0.5</span> * (extent[<span class="hljs-number">4</span>] + extent[<span class="hljs-number">5</span>]);<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> axialElements[<span class="hljs-number">16</span>] = &#123;<br><span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>&#125;;<br><br>vtkSmartPointer&lt;vtkMatrix4x4&gt; resliceAxes = vtkSmartPointer&lt;vtkMatrix4x4&gt;::<span class="hljs-built_in">New</span>();<br>resliceAxes-&gt;<span class="hljs-built_in">DeepCopy</span>(axialElements);<br><br>resliceAxes-&gt;<span class="hljs-built_in">SetElement</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, center[<span class="hljs-number">0</span>]);<br>resliceAxes-&gt;<span class="hljs-built_in">SetElement</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, center[<span class="hljs-number">1</span>]);<br>resliceAxes-&gt;<span class="hljs-built_in">SetElement</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, center[<span class="hljs-number">2</span>]);<br><br>vtkSmartPointer&lt;vtkImageReslice&gt; reslice = vtkSmartPointer&lt;vtkImageReslice&gt;::<span class="hljs-built_in">New</span>();<br>reslice-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>reslice-&gt;<span class="hljs-built_in">SetOutputDimensionality</span>(<span class="hljs-number">2</span>);<br>reslice-&gt;<span class="hljs-built_in">SetResliceAxes</span>(resliceAxes);<br>reslice-&gt;<span class="hljs-built_in">SetInterpolationModeToLinear</span>();<br><br>vtkSmartPointer&lt;vtkLookupTable&gt; colorTable = vtkSmartPointer&lt;vtkLookupTable&gt;::<span class="hljs-built_in">New</span>();<br>colorTable-&gt;<span class="hljs-built_in">SetRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>);<br>colorTable-&gt;<span class="hljs-built_in">SetValueRange</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>colorTable-&gt;<span class="hljs-built_in">SetSaturationRange</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br>colorTable-&gt;<span class="hljs-built_in">SetRampToLinear</span>();<br>colorTable-&gt;<span class="hljs-built_in">Build</span>();<br><br>vtkSmartPointer&lt;vtkImageMapToColors&gt; colorMap = vtkSmartPointer&lt;vtkImageMapToColors&gt;::<span class="hljs-built_in">New</span>();<br>colorMap-&gt;<span class="hljs-built_in">SetLookupTable</span>(colorTable);<br>colorMap-&gt;<span class="hljs-built_in">SetInputConnection</span>(reslice-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>colorMap-&gt;<span class="hljs-built_in">Update</span>();<br><br>vtkSmartPointer&lt;vtkImageActor&gt; imgActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>imgActor-&gt;<span class="hljs-built_in">SetInputData</span>(colorMap-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkRenderer&gt; renderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>renderer-&gt;<span class="hljs-built_in">AddActor</span>(imgActor);<br>renderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">.4</span>, <span class="hljs-number">.5</span>, <span class="hljs-number">.6</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>renderWindow-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(renderer);<br><br>vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>vtkSmartPointer&lt;vtkInteractorStyleImage&gt; imagestyle = vtkSmartPointer&lt;vtkInteractorStyleImage&gt;::<span class="hljs-built_in">New</span>();<br><br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(imagestyle);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renderWindow);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Initialize</span>();<br><br>vtkSmartPointer&lt;vtkImageInteractionCallback&gt; callback = vtkSmartPointer&lt;vtkImageInteractionCallback&gt;::<span class="hljs-built_in">New</span>();<br>callback-&gt;<span class="hljs-built_in">SetImageReslice</span>(reslice);<br>callback-&gt;<span class="hljs-built_in">SetInteractor</span>(renderWindowInteractor);<br>callback-&gt;<span class="hljs-built_in">SetImageMapToColors</span>(colorMap);<br><br>imagestyle-&gt;<span class="hljs-built_in">AddObserver</span>(vtkCommand::MouseMoveEvent, callback);<br>imagestyle-&gt;<span class="hljs-built_in">AddObserver</span>(vtkCommand::LeftButtonPressEvent, callback);<br>imagestyle-&gt;<span class="hljs-built_in">AddObserver</span>(vtkCommand::LeftButtonReleaseEvent, callback);<br><br>renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212071647371.png" style="zoom: 67%;" /></p><p>vtkImageInteractionCallback继承自vtkCommand类，并覆盖父类函数Execute()。该类提供了两个接口：SetImageReslice和SetInteractor。SetImageReslice用以设置vtkImageSlice对象，vtkImageSlice根据设置的变换矩阵提取三维图像切片。SetInteractor用以设置vtkRenderWindowInteractor，vtkRenderWindowInteractor类对象负责每次提取切片后刷新视图。</p><p>下面我们重点来看一下Execute函数，该函数提供了具体的切片提取功能。在该函数里面，主要监听了三个消息：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkCommand::LeftButtonPressEvent<br>vtkCommand::LeftButtonReleaseEvent<br>vtkCommand::MouseMoveEvent<br></code></pre></div></td></tr></table></figure><p>前两个消息分别是鼠标左键的按下和弹起消息。当鼠标左键按下时，就设置切片提取标志为1，而当弹起时，将标志置为0。这样在鼠标移动时，只有在确定切片提取标志为1时，执行切片提取功能。</p><p>vtkCommand::MouseMoveEvent即为鼠标移动消息。当检测到该消息时，首先检查切片提取标志，当为1时提取切片。提取切片时，需要为vtkImageSlice对象设置变换矩阵。这里在函数开始时，首先获取了鼠标滑动的前后两次点的位置lastPos和currPos。然后根据两点的Y坐标差deltaY，计算新的中心点center并变换至vtkImageSlice当前变换矩阵中，得到变换中心点，将其设置到原来的变换矩阵matrix中，并设置到vtkImageSlice中，最后执行interactor-&gt;Render()即可不断的根据鼠标移动刷新图像。</p><p>Command对象定义完毕后，即可为交互对象InteractorStyle添加观察者，响应鼠标消息。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkImageInteractionCallback&gt; callback = vtkSmartPointer&lt;vtkImageInteractionCallback&gt;::<span class="hljs-built_in">New</span>();<br>callback-&gt;<span class="hljs-built_in">SetImageReslice</span>(reslice);<br>callback-&gt;<span class="hljs-built_in">SetInteractor</span>(renderWindowInteractor);<br>callback-&gt;<span class="hljs-built_in">SetImageMapToColors</span>(colorMap);<br><br>imagestyle-&gt;<span class="hljs-built_in">AddObserver</span>(vtkCommand::MouseMoveEvent, callback);<br>imagestyle-&gt;<span class="hljs-built_in">AddObserver</span>(vtkCommand::LeftButtonPressEvent, callback);<br>imagestyle-&gt;<span class="hljs-built_in">AddObserver</span>(vtkCommand::LeftButtonReleaseEvent, callback);<br><br>renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br></code></pre></div></td></tr></table></figure><p>这里主要是定义了vtkImageInteractionCallback对象，并设置vtkImageSlice对象和vtkRenderWindowInteractor对象。然后为交互对象vtkInteractorStyle添加观察者来监控相应的消息，这里主要是三个消息：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkCommand::LeftButtonPressEvent<br>vtkCommand::LeftButtonReleaseEvent<br>vtkCommand::MouseMoveEvent<br></code></pre></div></td></tr></table></figure><p>当响应到这三个消息时，立即执行vtkImageInteractionCallback的Execute函数，以便实现切片的实时提取和更新。完成以后，运行程序，当鼠标在图像上移动时，会发现图像会跟着鼠标的移动而变化。</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VTK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VTK学习笔记（三）</title>
    <link href="/post/d287c7b.html"/>
    <url>/post/d287c7b.html</url>
    
    <content type="html"><![CDATA[<p>本系列文章主要对<ahref="https://vtk.org/">VTK</a>的相关知识进行总结。 <span id="more"></span></p><h1 id="vtk学习笔记三">VTK学习笔记（三）</h1><h2 id="vtk图像数据结构">VTK图像数据结构🦭</h2><p>数字图像文件内容由两个部分组成：图像头信息和数据。图像头信息定义了图像的基本信息，主要包括起点位置（Origin），像素间隔（space）和维数（dimension）。通过这三个参数即可以决定图像空间位置和规模。图像可以看做是空间中的一个规则网格，网格中的每个最小单元称之为一个像素（二维）或者体素（三维），这样网格在每个方向上的像素或者体素个数即为图像在该方向的维数。像素索引表示每个像素在图像网格中的位置，是图像内部的网格坐标。而在医学图像中，每个图像除了内部坐标外，还存在一个世界坐标。这个世界坐标依赖于成像设备。在医学图像中起点位置（Origin），像素间隔（space）和图像维数决定了世界坐标系。这样通过起点位置，像素间隔和像素索引即可计算每个像素的世界坐标位置。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212031654586.png" style="zoom:80%;" /></p><p>上图表示一个4x2x3的图像，即图像的维数，每一个小球表示一个像素；而图像的原点为(5.1,10.0,6.5)，两两像素之间的间隔表示像素间隔，每个方向的像素间隔为1.5，1.5和1.8。</p><p>图像数据即为图像像素的像素值，一般采用一维数组来表示和存储。已知像素索引和图像维数下，即可计算每个像素对应的像素值。通常图像的像素值为一个标量，例如一般灰度图像；图像像素值也可以是一个向量，例如彩色图像；另外图像像素值还可以是张量，如梯度场图像。医学图像处理中大部分的图像都是灰度图像。</p><p>这里需要注意灰度图像的灰度值的数据类型，在一般的灰度图像处理中不需要考虑，因为其范围默认为0-255，可以采用一个unsignedchar类型类表示。但是在医学图像处理中，256灰度级远远不能满足要求，因此灰度范围往往大于256级。常见的医学图像的像素数据类型为unsignedshort，灰度范围为0-65536。另外，有时为了精度的考虑，也会使用int、float甚至double类型，因此需要格外注意。</p><p>利用vtkImageData，我们可以方便的创建、读写、和访问图像数据。</p><hr /><h2 id="vtk图像创建">VTK图像创建😼</h2><h4 id="通过source">通过Source🤥</h4><p>VTK中内置了多个创建图像的Source，利用这些Source可以快速的创建图像，其中以vtkImageCanvasSource2D为代表。该Source功能是创建一个画布（空白图像），并提供了多种几何图形（点、线段、圆、矩形以及图像等）的绘制填充功能。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkImageCanvasSource2D&gt; canvas = vtkSmartPointer&lt;vtkImageCanvasSource2D&gt;::<span class="hljs-built_in">New</span>();<br>    canvas-&gt;<span class="hljs-built_in">SetScalarTypeToUnsignedChar</span>();<br>    canvas-&gt;<span class="hljs-built_in">SetNumberOfScalarComponents</span>(<span class="hljs-number">1</span>);<br>    canvas-&gt;<span class="hljs-built_in">SetExtent</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    canvas-&gt;<span class="hljs-built_in">SetDrawColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    canvas-&gt;<span class="hljs-built_in">FillBox</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br><br>    canvas-&gt;<span class="hljs-built_in">SetDrawColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    canvas-&gt;<span class="hljs-built_in">FillBox</span>(<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">20</span>, <span class="hljs-number">40</span>);<br><br>    canvas-&gt;<span class="hljs-built_in">Update</span>();<br><br>    <span class="hljs-comment">// 生成渲染对象</span><br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; iren = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    vtkSmartPointer&lt;vtkImageViewer2&gt; viewer = vtkSmartPointer&lt;vtkImageViewer2&gt;::<span class="hljs-built_in">New</span>();<br>    viewer-&gt;<span class="hljs-built_in">SetInputConnection</span>(canvas-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>    viewer-&gt;<span class="hljs-built_in">SetupInteractor</span>(iren);<br>    iren-&gt;<span class="hljs-built_in">Initialize</span>();<br>    iren-&gt;<span class="hljs-built_in">Start</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212031736847.png" style="zoom:67%;" /></p><p>在上面代码片段中，首先定义了一个vtkImageCanvasSource2D的指针，然后设置画布的像素数据类型，像素成分数目和画布的大小。然后，在该画布中，利用FillBox绘制两个填充矩形，并通过SetDrawColor()来设置两个矩形的颜色。</p><p>除了vtkImageCanvasSource2D外，VTK中还提供了其他类似的source类来快速生成特定的图像，例如vtkImageEllipsoidSource，该类根据指定的中心，各个轴的半径来生成一个前景为椭圆（球）的二值图像；vtkImageGaussianSource类生成一副像素值服从高斯分布的图像；vtkImageGridSource用于生成网格线图像；vtkImageNoiseSource生成一个像素值为随机数的噪声图像；vtkImageSinusoidSource生成的图像像素值由正弦函数决定。</p><hr /><h4 id="通过手动">通过手动🏂🏻</h4><p>利用上述图像Source可以快速的生成特定的图像，不过相对来说，在实际应用中较少用到他们。VTK中可以手动生成图像，然后根据需要进行像素赋值。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> main<br>&#123;<br>    vtkSmartPointer&lt;vtkImageData&gt; img = vtkSmartPointer&lt;vtkImageData&gt;::<span class="hljs-built_in">New</span>();<br>    vtkSmartPointer&lt;vtkInformation&gt; info = vtkSmartPointer&lt;vtkInformation&gt;::<span class="hljs-built_in">New</span>();<br>    img-&gt;<span class="hljs-built_in">SetDimensions</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    img-&gt;<span class="hljs-built_in">SetScalarType</span>(VTK_UNSIGNED_CHAR, info);<br>    img-&gt;<span class="hljs-built_in">SetNumberOfScalarComponents</span>(<span class="hljs-number">1</span>,info); <span class="hljs-comment">// 每个像素需要表示的组份 =1是指标量图</span><br>    img-&gt;<span class="hljs-built_in">AllocateScalars</span>(info);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* ptr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)img-&gt;<span class="hljs-built_in">GetScalarPointer</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span> * <span class="hljs-number">10</span> * <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        *ptr++ = i % <span class="hljs-number">256</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 生成渲染对象</span><br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; iren = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    vtkSmartPointer&lt;vtkImageViewer2&gt; viewer = vtkSmartPointer&lt;vtkImageViewer2&gt;::<span class="hljs-built_in">New</span>();<br>    viewer-&gt;<span class="hljs-built_in">SetInputData</span>(img);<br>    viewer-&gt;<span class="hljs-built_in">SetupInteractor</span>(iren);<br>    iren-&gt;<span class="hljs-built_in">Initialize</span>();<br>    iren-&gt;<span class="hljs-built_in">Start</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062100953.png" alt="" style="zoom:67%;" /></p><p>首先定义vtkImageData指针，然后指定图像的维数，而图像的原点和像素间隔则都是采用默认值，因此不需要设置。SetScalarType指定图像的每个像素值的数据类型为unsignedchar，SetNumberOfScalarComponents则指定了每个像素值的数据成分为1，每个像素值为1个标量值，参数设置完毕后，调用AllocateScalars()分配内存，生成图像数据。图像生成后，默认所有像素值为0。可以通过访问图像数据数组来设置每个像素值，GetScalarPointer()即返回图像的数据数组（图像数据数组都采用一维数组），然后根据图像的大小，访问每个像素并为其赋值。</p><hr /><h2 id="vtk图像显示">VTK图像显示🌃</h2><h4 id="vtkimageviewer2">vtkImageViewer2🚞</h4><p>在VTK早期版本中，提供了vtkImageViewer类来显示图像。随着版本的发展，目前使用vtkImageViewer2来代替vtkImageViewer实现图像的显示。vtkImageViewer2中封装了VTK图像显示的管线，包括vtkActor，vtkRender，vtkRenderWindow，vtkInteractorStypeImage等对象，可以方便的完成图像显示和交互。该类提供的主要交互操作有：图像放缩，窗宽窗位调节，并提供切片选择，切片方向设置接口，尤其适合三维图像的显示。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkMetaImageReader&gt;reader = vtkSmartPointer&lt;vtkMetaImageReader&gt;::<span class="hljs-built_in">New</span>();<br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;brain.mhd&quot;</span>);<br>    reader-&gt;<span class="hljs-built_in">Update</span>();<br><br>    vtkSmartPointer&lt;vtkImageViewer2&gt; imageViewer = vtkSmartPointer&lt;vtkImageViewer2&gt;::<span class="hljs-built_in">New</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">SetupInteractor</span>(renderWindowInteractor);<br><br>    imageViewer-&gt;<span class="hljs-built_in">SetColorLevel</span>(<span class="hljs-number">500</span>);<br>    imageViewer-&gt;<span class="hljs-built_in">SetColorWindow</span>(<span class="hljs-number">2000</span>);<br>    imageViewer-&gt;<span class="hljs-built_in">SetSlice</span>(<span class="hljs-number">40</span>);<br>    imageViewer-&gt;<span class="hljs-built_in">SetSliceOrientationToXY</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">Render</span>();<br><br>    renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062100488.png" style="zoom: 50%;" /></p><p>首先使用vtkMetaImageReader读入一个mhd图像，然后定义一个vtkImageViewer2对象显示图像。接下来定义了一个vtkRenderWindowInteractor对象，并传递给vtkImageViewer2对象，用于完成鼠标、键盘等消息响应，便于进行图像的交互操作。接下来分别设置了四个参数，窗位(ColorLevel)、窗宽(ColorWindow)、切片(Slice)和切片方向(Orientation)。另外，按下鼠标左键拖动鼠标，可以调节图像的窗宽窗位，从而显示不同灰度范围内容；按下鼠标右键拖动鼠标可以放缩图像。当然这些交互操作可以由用户根据需要自己定义vtkInteractorStyle子类，并响应相应的操作。</p><p>窗宽是CT图像上显示的CT值范围。一般显示器的灰度范围为256级，而X光图像的灰度范围则远远大于该范围，因此通过显示器显示时不能显示所有灰度级。因此需要窗宽来定义需要显示的灰度范围。当灰度值高于该范围的最大值时，均以白影显示；而低于该范围时均显示为黑色。增大窗宽，显示具有不同灰度值的组织结构增多，但是会降低组织之间的对比度。减小窗宽，则可视的不同灰度组织结构会减少，同时增大组织结构的对比度。</p><p>窗位是窗的中心位置。窗宽只是确定了CT图像灰度范围上的可视部分范围，还需要窗位来确定可视灰度范围的具体位置。同样的窗宽，会根据窗位的位置变化来显示不同的组织结构。比如，窗宽为200时，当窗位为100时，可视灰度范围为0至200；当窗位为500时，则可视灰度范围为400至600。当窗宽窗位确定以后，显示时底层会将可视灰度范围转换到256灰度级进行显示。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062100201.png" style="zoom:80%;" /></p><p>而显示三维图像时，需要确定当前显示切片和方向。vtkImageViewer2提供了SetSlice()函数设置切片号，SetSliceOrientationToXY()则将切片的方向设置为垂直XY平面方向。此外还可以设置为垂直YZ或者XZ平面方向，其对应函数分别为SetSliceOrientationToYZ()和SetSliceOrientationToXZ()。默认情况下切片方向为垂直于XY平面即沿着Z轴方向，根据设置的切片号获取Z轴方向的具体切片进行显示。</p><p>切片（slice）与切面是三维图像比较常用的概念。尤其是在医学图像中，不同方向的切面都有特定的名字。矢状面（sagital）是沿着身体前后径所做的与地面垂直的切面；冠状面（coronal）是沿着身体左右径所做的与地面垂直的切面；而横断面（transverse/axial）是指横断身体与地面平行的切面。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062100035.png" style="zoom:60%;" /></p><p>设置切片的方向即是通过不同的方向来观察人体内部组织结构。因此，常见的医学图像可视化软件常常提供四个视图用来显示图像：横断面视图，矢状面视图，冠状面视图和三维视图。</p><hr /><h4 id="vtkimageactor">vtkImageActor💴</h4><p>vtkImageActor是一个三维图像渲染Actor，通过纹理映射将图像映射到一个多边形上进行显示。使用vtkImageActor较vtkImageViewer2要复杂一些，需要建立完整的渲染管线：包括vtkImageActor，vtkRender，vtkRenderWindow，vtkRenderWindowInteractor管线。另外，作为图像二维浏览器，不需要在三维空间中进行旋转操作，因此还需要为vtkRenderWindow定义一个vtkInteractorStyleImage对象。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>    reader-&gt;<span class="hljs-built_in">Update</span>();<br><br>    vtkSmartPointer&lt;vtkImageActor&gt; imgActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>    imgActor-&gt;<span class="hljs-built_in">SetInputData</span>(reader-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>    vtkSmartPointer&lt;vtkRenderer&gt; renderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>    renderer-&gt;<span class="hljs-built_in">AddActor</span>(imgActor);<br>    renderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">0.4</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>);<br><br>    vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>    renderWindow-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);<br>    renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(renderer);<br>    renderWindow-&gt;<span class="hljs-built_in">Render</span>();<br><br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    vtkSmartPointer&lt;vtkInteractorObserver&gt; style = vtkSmartPointer&lt;vtkInteractorStyle&gt;::<span class="hljs-built_in">New</span>();<br><br>    renderWindowInteractor-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br>    renderWindowInteractor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renderWindow);<br>    renderWindowInteractor-&gt;<span class="hljs-built_in">Initialize</span>();<br><br>    renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062100024.png" style="zoom:67%;" /></p><p>上面代码中在读入图像后，依次建立vtkImageActor，vtkRender，vtkRenderWindow，vtkRenderWindowInteractor，并组装为管线。为了屏蔽旋转操作，建立vtkInteractorStyleImage对象，并通过renderWindowInteractor-&gt;SetInteractorStyle(style)设置交互对象。需要注意的是，vtkImageActor接收的图像vtkImageData数据类型必须为unsignedchar类型，因此在显示之前，需要利用vtkImageCast将图像数据类型转换为unsignedchar。</p><hr /><h4 id="图像融合">图像融合🤿</h4><p>上面两种方法都是在一个窗口中显示一个图像。但是在常见的医学处理软件中，经常会遇到在一个窗口中显示多个图像，这就会用到图像融合技术。图像融合是利用图像的alpha通道和不透明度来实现。VTK中vtkImageBlend实现图像的融合。</p><p>vtkImageBlend可以接收多个图像输入，输出为融合图像。输出图像的像素间隔、原点、范围（extent）以及像素组分个数与第一个图像一致。该类提供了两种融合模式，第一种是标准模式，也是默认的融合方式。</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">output &lt;- <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[0]</span><br>foreach <span class="hljs-selector-tag">input</span> <span class="hljs-selector-tag">i</span> &#123;<br>    foreach pixel px &#123;<br>        r &lt;- <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[i]</span>(px)(alpha)* <span class="hljs-attribute">opacity</span><span class="hljs-selector-attr">[i]</span><br>        f &lt;- (<span class="hljs-number">255</span> - r)<br>        <span class="hljs-built_in">output</span>(px) &lt;- <span class="hljs-built_in">output</span>(px) * f + <span class="hljs-selector-tag">input</span>(px) *r<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第二种是混合模式（Compound）。该模式下输出结果经过alpha/opacity不透明度的和做过归一化。另外还可以设置一个阈值，当alpha*opacity小于等于该阈值时会忽略该像素。</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-built_in">output</span> &lt;- <span class="hljs-number">0</span><br><span class="hljs-built_in">foreach</span> pixel px &#123;<br>    sum &lt;- <span class="hljs-number">0</span><br>    <span class="hljs-built_in">foreach</span> <span class="hljs-built_in">input</span> i &#123;<br>        r &lt;- <span class="hljs-built_in">input</span>[i](px)(alpha) * opacity(i)<br>        sum &lt;- sum + r<br>        <span class="hljs-keyword">if</span> r &gt; threshold &#123;<br>        <span class="hljs-built_in">output</span>(px) &lt;- <span class="hljs-built_in">output</span>(px) + <span class="hljs-built_in">input</span>(px) *r<br>    &#125;<br>    &#125;<br><span class="hljs-built_in">output</span>(px) &lt;- <span class="hljs-built_in">output</span>(px) / sum<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面的代码中读入了一副灰度图像，并生成了一个二值图像；然后定义了vtkImageBlend对象，函数SetInput()设置两个图像作为输入。这里设置输入图像时，由于可以输入多个图像，因此需要给定图像的id号来设置输入。SetOpacity()用于设置对应id号的图像不透明度的大小，当不透明度为1.0时，为完全不透明。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkJPEGReader&gt;reader = vtkSmartPointer&lt;vtkJPEGReader&gt;::<span class="hljs-built_in">New</span>();<br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.jpg&quot;</span>);<br>    reader-&gt;<span class="hljs-built_in">Update</span>();<br><br>    vtkSmartPointer&lt;vtkImageCanvasSource2D&gt; imageSource = vtkSmartPointer&lt;vtkImageCanvasSource2D&gt;::<span class="hljs-built_in">New</span>();<br>    imageSource-&gt;<span class="hljs-built_in">SetNumberOfScalarComponents</span>(<span class="hljs-number">1</span>);<br>    imageSource-&gt;<span class="hljs-built_in">SetScalarTypeToUnsignedChar</span>();<br>    imageSource-&gt;<span class="hljs-built_in">SetExtent</span>(<span class="hljs-number">0</span>, <span class="hljs-number">512</span>, <span class="hljs-number">0</span>, <span class="hljs-number">512</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    imageSource-&gt;<span class="hljs-built_in">SetDrawColor</span>(<span class="hljs-number">0.0</span>);<br>    imageSource-&gt;<span class="hljs-built_in">FillBox</span>(<span class="hljs-number">0</span>, <span class="hljs-number">512</span>, <span class="hljs-number">0</span>, <span class="hljs-number">512</span>);<br>    imageSource-&gt;<span class="hljs-built_in">SetDrawColor</span>(<span class="hljs-number">255.0</span>);<br>    imageSource-&gt;<span class="hljs-built_in">FillBox</span>(<span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>);<br>    imageSource-&gt;<span class="hljs-built_in">Update</span>();<br><br>    vtkSmartPointer&lt;vtkImageBlend&gt; imageBlend = vtkSmartPointer&lt;vtkImageBlend&gt;::<span class="hljs-built_in">New</span>();<br>imageBlend-&gt;<span class="hljs-built_in">AddInputData</span>(reader-&gt;<span class="hljs-built_in">GetOutput</span>());<br>    imageBlend-&gt;<span class="hljs-built_in">AddInputData</span>(imageSource-&gt;<span class="hljs-built_in">GetOutput</span>());<br>    imageBlend-&gt;<span class="hljs-built_in">SetOpacity</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>);<br>    imageBlend-&gt;<span class="hljs-built_in">SetOpacity</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.6</span>);<br>    imageBlend-&gt;<span class="hljs-built_in">Update</span>();<br><br><span class="hljs-comment">// Create actors</span><br>vtkSmartPointer&lt;vtkImageActor&gt; originalActor1 = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>originalActor1-&gt;<span class="hljs-built_in">SetInputData</span>(reader-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; originalActor2 = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>originalActor2-&gt;<span class="hljs-built_in">SetInputData</span>(imageSource-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkImageActor&gt; blendActor = vtkSmartPointer&lt;vtkImageActor&gt;::<span class="hljs-built_in">New</span>();<br>blendActor-&gt;<span class="hljs-built_in">SetInputData</span>(imageBlend-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br><span class="hljs-comment">// Define viewport ranges</span><br><span class="hljs-comment">// (xmin, ymin, xmax, ymax)</span><br><span class="hljs-type">double</span> leftViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.33</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> midViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.33</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.66</span>, <span class="hljs-number">1.0</span> &#125;;<br><span class="hljs-type">double</span> rightViewport[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0.66</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> &#125;;<br><br><span class="hljs-comment">// Setup renderers</span><br>vtkSmartPointer&lt;vtkRenderer&gt; originalRenderer1 = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>originalRenderer1-&gt;<span class="hljs-built_in">SetViewport</span>(leftViewport);<br>originalRenderer1-&gt;<span class="hljs-built_in">AddActor</span>(originalActor1);<br>originalRenderer1-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>originalRenderer1-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; originalRenderer2 = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>originalRenderer2-&gt;<span class="hljs-built_in">SetViewport</span>(midViewport);<br>originalRenderer2-&gt;<span class="hljs-built_in">AddActor</span>(originalActor2);<br>originalRenderer2-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>originalRenderer2-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; blendRenderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>blendRenderer-&gt;<span class="hljs-built_in">SetViewport</span>(rightViewport);<br>blendRenderer-&gt;<span class="hljs-built_in">AddActor</span>(blendActor);<br>blendRenderer-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>blendRenderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(originalRenderer1);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(originalRenderer2);<br>renderWindow-&gt;<span class="hljs-built_in">AddRenderer</span>(blendRenderer);<br>renderWindow-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">640</span>, <span class="hljs-number">320</span>);<br>renderWindow-&gt;<span class="hljs-built_in">Render</span>();<br><br>vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>vtkSmartPointer&lt;vtkInteractorObserver&gt; style = vtkSmartPointer&lt;vtkInteractorStyleImage&gt;::<span class="hljs-built_in">New</span>();<br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renderWindow);<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Initialize</span>();<br>renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062100647.png" style="zoom:80%;" /></p><hr /><h2 id="vtkimagedata基本操作">vtkImageData基本操作🏘️</h2><h4 id="图像信息访问和修改">图像信息访问和修改🫐</h4><p>图像处理离不开一些基本的图像数据操作，例如获取和修改图像的基本信息，访问和修改图像像素值，图像显示，图像类型转换等等。熟练掌握这些基本操作有助于使用VTK进行图像处理的快速开发。</p><p>vtkImageData中提供了多个函数用于访问或者获取图像的基本信息，这些函数通常使用Set或者Get加上相应的信息名的形式，例如获取图像维数的方法定义为GetDimensions()。当然这里主要从类的层次上进行VTK的学习，这里不再具体赘述每个函数的基本名称和使用，用户可以查阅相应的类文档。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>    reader-&gt;<span class="hljs-built_in">Update</span>();<br><br>    <span class="hljs-type">int</span> dims[<span class="hljs-number">3</span>];<br>    reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetDimensions</span>(dims);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;图像维数:&quot;</span> &lt;&lt; dims[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; dims[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; dims[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-type">double</span> origin[<span class="hljs-number">3</span>];<br>    reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetOrigin</span>(origin);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;图像原点:&quot;</span> &lt;&lt; origin[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; origin[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; origin[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-type">double</span> spaceing[<span class="hljs-number">3</span>];<br>    reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetSpacing</span>(spaceing);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;像素间隔:&quot;</span> &lt;&lt; spaceing[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; spaceing[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; spaceing[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br><br><br>    vtkSmartPointer&lt;vtkImageViewer2&gt; imageViewer = vtkSmartPointer&lt;vtkImageViewer2&gt;::<span class="hljs-built_in">New</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>()); <br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">SetupInteractor</span>(renderWindowInteractor);<br>    imageViewer-&gt;<span class="hljs-built_in">Render</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">GetRenderer</span>()-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">Render</span>();<br><br>    renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062100151.png" style="zoom: 50%;" /></p><p>上例中主要获取了图像的三个信息，图像维数，图像原点和像素间隔。VTK中二维和三维图像都用vtkImageData表示，因此第六行中定义图像维数为dims[3]，然后利用GetDimensions()函数获取图像的维数；图像的原点和像素间隔都是物理空间数值，因此都是定义double类型。本例读入了二维lena图像，上图中显示了获取的图像信息。其中，图像维数为512*512*1，通过维数可以看成z方向的维数为1，说明该图像为二维图像；而图像的原点为(0,0,0)点，而像素间隔为(1,1,1)。</p><hr /><p>vtkImageData中提供了多个Set函数用于设置图像的基本信息。当对一个管线的输出修改图像信息后，如果管线重新Update，那么这些修改都会恢复回原来的值。而vtkChangeImageInformation可以作为管线中的一个filter来修改图像信息。利用这个filter可以修改图像的原点，像素间隔，以及范围起点（extent），另外还可以对图像平移缩放等操作。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>    reader-&gt;<span class="hljs-built_in">Update</span>();<br><br>    <span class="hljs-type">int</span> dims[<span class="hljs-number">3</span>];<br>    <span class="hljs-type">double</span> origin[<span class="hljs-number">3</span>];<br>    <span class="hljs-type">double</span> spaceing[<span class="hljs-number">3</span>];<br><br>    reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetDimensions</span>(dims);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;原图像维数:&quot;</span> &lt;&lt; dims[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; dims[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; dims[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br>    reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetOrigin</span>(origin);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;原图像原点:&quot;</span> &lt;&lt; origin[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; origin[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; origin[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br>    reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetSpacing</span>(spaceing);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;原像素间隔:&quot;</span> &lt;&lt; spaceing[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; spaceing[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; spaceing[<span class="hljs-number">2</span>] &lt;&lt; std::endl &lt;&lt; std::endl;<br><br>    vtkSmartPointer&lt;vtkImageChangeInformation&gt; changer =  vtkSmartPointer&lt;vtkImageChangeInformation&gt;::<span class="hljs-built_in">New</span>();<br>    changer-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>    changer-&gt;<span class="hljs-built_in">SetOutputOrigin</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>);<br>    changer-&gt;<span class="hljs-built_in">SetOutputSpacing</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>);<br>    changer-&gt;<span class="hljs-built_in">SetCenterImage</span>(<span class="hljs-number">1</span>);<br>    changer-&gt;<span class="hljs-built_in">Update</span>();<br><br><br>    changer-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetDimensions</span>(dims);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;修改后图像维数:&quot;</span> &lt;&lt; dims[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; dims[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;&quot;</span> &lt;&lt; dims[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br>    changer-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetOrigin</span>(origin);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;修改图像原点:&quot;</span> &lt;&lt; origin[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; origin[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;&quot;</span> &lt;&lt; origin[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br>    changer-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetSpacing</span>(spaceing);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;修改后像素间隔:&quot;</span> &lt;&lt; spaceing[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; spaceing[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;&quot;</span> &lt;&lt; spaceing[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br><br><br>    vtkSmartPointer&lt;vtkImageViewer2&gt; imageViewer = vtkSmartPointer&lt;vtkImageViewer2&gt;::<span class="hljs-built_in">New</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">SetInputConnection</span>(changer-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br><br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">SetupInteractor</span>(renderWindowInteractor);<br>    imageViewer-&gt;<span class="hljs-built_in">Render</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">GetRenderer</span>()-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">Render</span>();<br><br>    renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062101523.png" style="zoom: 50%;" /></p><p>上例中首先读入图像，由vtkImageData提供函数接口获取图像的维数，原点和像素间隔。然后定义vtkImageChangeInformation指针，并设置输出图像原点为（100,100, 0），输出图像像素间隔为（5, 5,1），然后调用CenterImage()函数将图像的原点置于图像的中心。</p><p>从上面结果中可以看出，操作后的结果使得图像的原点位于(-1277.5,-1275.5, 0)，SetOutputOrigin(100, 100,0)并没有起作用。原因在哪里呢？如果看下CenterImage()函数的注释，可以发现该函数的作用是将（0,0,0）点置于图像的中心。当CenterImage该函数执行时会重写SetOutputOrigin()，所以SetOutputOrigin函数不会产生任何作用。那(-1277.5,-1275.5,0)又是如何计算出来的呢？如下图，根据图像的维数和像素间隔计算得到新的图像的宽度和高度为(512-1)*5，初始图像的原点位于（0,0,0），现在将图像的中心平移至原点，平移量为（-(512-1)*5/2,(512-1)*5/2,0） = (-1277.5, -1275.5,0)。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062101233.png" style="zoom: 80%;" /></p><hr /><h4 id="图像像素值访问和修改">图像像素值访问和修改🎨</h4><p>图像像素值的访问与修改是最常用的一个操作。VTK中提供了两种访问图像像素值的方法。第一种是直接访问vtkImageData的数据数组。这种方式最直接。在第一节上新建图像赋值也是采用的这种方法。vtkImageData中提供了GetScalarPointer()函数获取数据数组指针，该函数有三种形式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> *<span class="hljs-title">GetScalarPointer</span><span class="hljs-params">(<span class="hljs-type">int</span> coordinates[<span class="hljs-number">3</span>])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> *<span class="hljs-title">GetScalarPointer</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> *<span class="hljs-title">GetScalarPointer</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><p>前两种形式根据给定的像素索引得到指定的像素值，注意返回的是第(x,y,z)个像素值的地址。而第三种方式是返回图像数据数组的头指针，然后根据头指针可以依次访问索引像素。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>    reader-&gt;<span class="hljs-built_in">Update</span>();<br><br>    <span class="hljs-type">int</span> dims[<span class="hljs-number">3</span>];<br>    reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetDimensions</span>(dims);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; dims[<span class="hljs-number">2</span>]; k++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; dims[<span class="hljs-number">1</span>]; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dims[<span class="hljs-number">0</span>]; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">100</span> &amp;&amp; j &lt; <span class="hljs-number">100</span>)<br>                &#123;<br>                    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* pixel = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)(reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetScalarPointer</span>(i, j, k));<br>                    *pixel = <span class="hljs-number">0</span>;<br>                    *(pixel + <span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;<br>                    *(pixel + <span class="hljs-number">2</span>) = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vtkSmartPointer&lt;vtkImageViewer2&gt; imageViewer = vtkSmartPointer&lt;vtkImageViewer2&gt;::<span class="hljs-built_in">New</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">SetupInteractor</span>(renderWindowInteractor);<br>    imageViewer-&gt;<span class="hljs-built_in">Render</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">GetRenderer</span>()-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">Render</span>();<br><br>    renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062101893.png" style="zoom:67%;" /></p><p>上面代码实现了将图像的100*100大小的区域设置为黑色。首先定义一个reader读取一副bmp图像，通过vtkImageData函数GetDimensions()获取图像的大小。建立三次循环，通过GetScalarPointer(i,j,k)函数获取访问图像像素值。需要注意的是，GetScalarPointer()函数返回的是void<em>类型，因此需要根据图像的实际类型进行强制转换。如上面代码中将像素值数组的头指针类型转换为unsignedchar</em>。如果对于数据类型不确定的话，还可以先通过vtkImageCast将图像数据类型强制转换为特定的数据类型，再进行遍历。</p><p>另外还有一个需要注意地方，彩色以及向量图像采用的是类似下图这种像素存储格式：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062101901.png" style="zoom:67%;" /></p><p>因此在修改RGB图像以及向量图像像素时，需要根据像素的元组的组分数目来访问。上例中，需要修改每个像素的RGB值时，首先获得第(i,j,k)个像素的地址也就是R值的地址，然后将地址加1来访问后续G值以及B值。如果对于像素的元组组分不确定时，可以通过函数GetNumberOfScalarComponents()来获取。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> nbOfComp = reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetNumberOfScalarComponents</span>();<br></code></pre></div></td></tr></table></figure><hr /><p>VTK中提供了vtkImageIterator类来利用迭代器方法访问图像像素。该类是一个模板类，使用时，需要提供迭代的图像像素类型以及迭代的区域大小。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkBMPReader&gt;reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>    reader-&gt;<span class="hljs-built_in">Update</span>();<br><br>    <span class="hljs-type">int</span> subRegion[<span class="hljs-number">6</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">300</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-function">vtkImageIterator&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">it</span><span class="hljs-params">(reader-&gt;GetOutput(), subRegion)</span></span>;<br><br>    <span class="hljs-keyword">while</span> (!it.<span class="hljs-built_in">IsAtEnd</span>())<br>    &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* inSI = it.<span class="hljs-built_in">BeginSpan</span>();<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* inSIEnd = it.<span class="hljs-built_in">EndSpan</span>();<br><br>        <span class="hljs-keyword">while</span> (inSI != inSIEnd)<br>        &#123;<br>            *inSI = <span class="hljs-number">255</span> - *inSI;<br>            ++inSI;<br>        &#125;<br>    it.<span class="hljs-built_in">NextSpan</span>();<br>    &#125;<br><br>    vtkSmartPointer&lt;vtkImageViewer2&gt; imageViewer = vtkSmartPointer&lt;vtkImageViewer2&gt;::<span class="hljs-built_in">New</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">SetupInteractor</span>(renderWindowInteractor);<br>    imageViewer-&gt;<span class="hljs-built_in">Render</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">GetRenderer</span>()-&gt;<span class="hljs-built_in">ResetCamera</span>();<br>    imageViewer-&gt;<span class="hljs-built_in">Render</span>();<br><br>    renderWindowInteractor-&gt;<span class="hljs-built_in">Start</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212062101936.png" style="zoom:67%;" /></p><p>上面代码中首先读取了一副bmp图像，然后定义了一个子区域。注意在定义子区域的时候，不要超过图像的大小范围。subRegion的六个值分别表示区域中x的最小最大值，y的最小最大值，z的最小最大值。由于处理的图像为二维图像，因此z的取值范围为[0,0]。然后根据图像类型unsignedchar定义实例化一个图像迭代器it，定义it时有两个参数：一个是要访问的图像，另外一个是访问的图像区域。设置完毕后，迭代器开始工作。注意，上面代码中有两个while循环。</p><p>首先看第一个while循环，这里判断迭代器是否结束。进入循环后，对于每个迭代器it，又存在第二个循环。这个循环判断的是当前像素的组分是否迭代完毕。由于vtk中所有类型的图像格式都是vtkImageData，因此每个像素可能是标量，也可能是向量。因此，每当访问到一个像素时，需要迭代当前像素的组分。组分迭代时，inSI= it.BeginSpan()获取第一个组分，inSIEnd =it.EndSpan()表示组分迭代完毕，通过++inSI不断迭代组分，并对像素的组分值进行处理，当inSI与inSIEnd相等时组分迭代完毕。然后继续迭代像素it，直至迭代完毕所有像素。上面代码中将指定区域的像素值取反。</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VTK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VTK学习笔记（二）</title>
    <link href="/post/4036df29.html"/>
    <url>/post/4036df29.html</url>
    
    <content type="html"><![CDATA[<p>本系列文章主要对<ahref="https://vtk.org/">VTK</a>的相关知识进行总结。 <span id="more"></span></p><h1 id="vtk学习笔记二">VTK学习笔记（二）</h1><h2 id="vtkobjectbase和vtkobject">vtkObjectBase和vtkObject🃏</h2><p>vtkObjectBase是一个抽象基类，派生出绝大多数的VTK类。它是VTK里所有引用计数(ReferenceCounting)类的基类，著名的子类包括：vtkCommand，vtkInformationKey和vtkObject。</p><p>如果很多对象有相同的值，将这个值存储多次是很无聊的。更好的办法是让所有的对象共享这个值的实现。这么做不但节省内存，而且可以使得程序运行更快，因为不需要构造和析构这个值的拷贝。引用计数就是这样一个技巧，它允许多个有相同值的对象共享这个值的实现。引用计数是个简单的垃圾回收体系，只要其它对象引用某对象(记为对象O)，对象O就会存在一个引用计数，当最后引用对象O的对象移除，O对象就会自动析构。VTK里使用引用计数的好处是，可以实现数据之间的共享而不用拷贝，从而达到节省内存的目的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkSmartPointer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkBMPReader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkImageData.h&quot;</span></span><br><br><span class="hljs-comment">// 因为我没有使用 CMake 进行配置，所以需要下面语句</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vtkAutoInit.h&gt;</span></span><br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkRenderingOpenGL2);<br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkInteractionStyle);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vtkSmartPointer&lt;vtkBMPReader&gt;reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>reader-&gt;<span class="hljs-built_in">Update</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Reference Count of reader-&gt;GetOutput (BeforeAssignment) = &quot;</span> <br>        &lt;&lt; reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetReferenceCount</span>() &lt;&lt; std::endl;<br>vtkSmartPointer&lt;vtkImageData&gt; image1 = reader-&gt;<span class="hljs-built_in">GetOutput</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Reference Count of reader-&gt;GetOutput (Assignto image1) = &quot;</span> <br>        &lt;&lt; reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetReferenceCount</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Reference Count of image1 = &quot;</span> &lt;&lt; image1-&gt;<span class="hljs-built_in">GetReferenceCount</span>() &lt;&lt; std::endl;<br>vtkSmartPointer&lt;vtkImageData&gt; image2 = reader-&gt;<span class="hljs-built_in">GetOutput</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Reference Count of reader-&gt;GetOutput (Assignto image2) = &quot;</span> <br>        &lt;&lt; reader-&gt;<span class="hljs-built_in">GetOutput</span>()-&gt;<span class="hljs-built_in">GetReferenceCount</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Reference Count of image2 = &quot;</span> &lt;&lt; image2-&gt;<span class="hljs-built_in">GetReferenceCount</span>() &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212011516764.png" style="zoom:80%;" /></p><p>在上例里，我们先用vtkBMPReader读入一幅BMP图像lena.bmp，在赋值之前我们输出了reader-&gt;GetOutput()的引用计数值，其值为1(使用方法New()创建对象以后，初始的引用计数值就等于1)；然后我们创建了一个vtkImageData类型的对象image1，并把reader的输出赋给了image1，这时image1就指向了reader的输出，也就是说，reader的输出多了一个引用，这个时候输出的reader-&gt;GetOutput()和image1的引用计数都为2；接着我们又创建一个类型同样为vtkImageData的对象image2，同样也是把reader的输出赋值给image2，这时，image2也指向reader的输出，亦即reader的输出又多了一个引用，所以输出的reader-&gt;GetOutput()和image2的引用计数值变成了3。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212011520669.png" style="zoom:80%;" /></p><p>一旦某个对象的引用计数等于0时，就表明没有别的对象再引用它，它的使命也宣告完成，程序就会自动的析构这个对象。在这个示例里，我们看不到引用计数减少的相关代码，这是因为我们使用了智能指针vtkSmartPointer。</p><hr /><h2 id="智能指针">智能指针🥶</h2><p>智能指针会自动管理引用计数的增加与减少，如果检测到某对象的引用计数值减少为0，则会自动地释放该对象的资源，从而达到自动管理内存的目的。</p><p>VTK里，要创建一个对象可以用两种方法，一种是使用vtkObjectBase里的静态成员变量New()，用Delete()方法析构；另一种就是我们示例里使用多次的使用智能指针vtkSmartPointer<T>。</p><p>对于第一种方法，用New()创建的对象，程序最后必须要调用Delete()方法释放对应的内存，而且由于vtkObjectBase及其子类的构造函数都是声明为受保护的，这意味着它们不能在栈区(栈区上的内存是由编译器自动分配与释放的，堆区上的内存则是由程序员分配和手动释放的。)上分配内存。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//创建vtkBMPReader对象</span><br>vtkBMPReader*reader = vtkBMPReader::<span class="hljs-built_in">New</span>(); <br>...<br><span class="hljs-comment">//程序最后要调用Delete()，这里并没有直接析构对象，而是使引用计数值减1。</span><br>reader-&gt;<span class="hljs-built_in">Delete</span>();<br></code></pre></div></td></tr></table></figure><p>用New()创建的对象，如果没有用Delete()方法删除的话，程序有可能会出现内存泄漏，即用户负责对象内存的管理。</p><p>如果使用智能指针创建的对象，则无需手动调用Delete()方法让引用计数减少，因为引用计数的增加与减少都是由智能指针自动完成的。使用智能指针时，首先是要包含智能指针的头文件：<code>#include "vtkSmartPointer.h"</code>。vtkSmartPointer是一个模板类，所需的模板参数就是待创建的对象的类名，如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 注意等号两端都要加上vtkSmartPointer</span><br>vtkSmartPointer&lt;vtkImageData&gt;image = vtkSmartPointer&lt;vtkImageData&gt;::<span class="hljs-built_in">New</span>();<br></code></pre></div></td></tr></table></figure><p>智能指针可以做函数返回值、类成员变量。在做类成员变量时，不需要在析构函数中进行删除。</p><p><strong>当你创建一个智能指针类型的对象，然后改变它的指向，这时引用计数就会出错。</strong>例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkImageData&gt; imageData = vtkSmartPointer&lt;vtkImageData&gt;::<span class="hljs-built_in">New</span>();<br>imageData = Reader-&gt;<span class="hljs-built_in">GetOutput</span>();<br></code></pre></div></td></tr></table></figure><p>上面两行代码里，我们首先创建一个imageData，并给他分配好了内存，接着我们又把imageData指向Reader的输出，而不是一直指向我们创建的那块内存。对于这种情况，我们只要简单地调用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkImageData*imageData = Reader-&gt;<span class="hljs-built_in">GetOutput</span>();<br></code></pre></div></td></tr></table></figure><p>这里没有必要使用智能指针，因为我们没有实际创建任何新的对象。</p><hr /><h2 id="运行时类型识别rtti">运行时类型识别（RTTI）🌞</h2><p>在C++里，对象类型是通过typeid(需要包含头文件#include<type_info>)获取的；VTK里在vtkObjectBase定义了获取对象类型的方法：GetClassName()和IsA()。GetClassName()返回的是该对象类名的字符串(VTK用类名来识别各个对象)，如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkBMPReader&gt;Reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br><span class="hljs-comment">//返回“vtkBMPReader”字符串</span><br>constchar* type = Reader-&gt;<span class="hljs-built_in">GetClassName</span>(); <br></code></pre></div></td></tr></table></figure><p>IsA()方法用于测试某个对象是否为指定字符串的类型或其子类，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 这里IsA()会返回真。</span><br><span class="hljs-keyword">if</span>(Reader-&gt;<span class="hljs-built_in">IsA</span>(“vtkImageReader”) ) &#123;……&#125;; <br></code></pre></div></td></tr></table></figure><p>类比C++里的操作RTTI操作符，除了typeid之外，还有dynamic_cast，主要用于基类向子类的类型转换，称为向下转型。VTK里同样提供了类似的方法，也就是vtkObject里定义的SafeDownCast()，它是vtkObject里的静态成员函数，意味着它是属于类的，而不是属于对象的，即可以用vtkObject::SafeDownCast()直接调用，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkImageReader&gt;ReaderBase = vtkSmartPointer&lt;vtkImageReader&gt;::<span class="hljs-built_in">New</span>();<br>vtkBMPReader* bmpReader = vtkBMPReader::<span class="hljs-built_in">SafeDownCast</span>(ReaderBase);<br></code></pre></div></td></tr></table></figure><p>与dynamic_cast类似，SafeDownCast也是运行时才转换的，这种转换只有当bmpReader的类型确实是ReaderBase的派生类时才有效，否则返回空指针。</p><p>除了运行时类型识别，vtkObjectBase还提供了用于调试的状态输出接口Print()。虽然vtkObjectBase里除了Print()还提供PrintSelf()、PrintHeader()、PrintTrailer()等公共接口，但在调试VTK程序时，如果需要输出某个对象的状态信息时，一般都是调用Print()函数，如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">bmpReader-&gt;<span class="hljs-built_in">Print</span>(std::cout);<br></code></pre></div></td></tr></table></figure><hr /><h2 id="vtkobject">vtkObject👾</h2><p>vtkObject里定义了与程序调试相关的一些公共接口，包括：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">DebugOn</span>() | <span class="hljs-built_in">DebugOff</span>() | <span class="hljs-built_in">GetDebug</span>() | <span class="hljs-built_in">SetDebug</span>(unsignedchar)<br><span class="hljs-built_in">SetGlobalWarningDisplay</span>(<span class="hljs-type">int</span>) | <span class="hljs-built_in">GetGlobalWarningDisplay</span>() | <span class="hljs-built_in">GlobalWarningDisplayOn</span>() | <span class="hljs-built_in">GlobalWarningDisplayOff</span>()<br></code></pre></div></td></tr></table></figure><p>其中后四个是静态成员函数。</p><hr /><p>vtkObject实现了观察者/命令设计模式</p><p>vtkObject定义了与观察者Observer相关的方法(如，AddObserver()/RemoveObserver())，观察者模式主要针对两个对象：Object和Observer。一个Object可以有多个Observer，它定义对象间的一种一对多的依赖关系，当—个Object对象的状态发生改变时，所有依赖于它的Observer对象都得到通知被自动更新。</p><p>命令模式属于对象行为模式，它将—个请求封装为一个对象，并提供一致性发送请求的接口，当一个事件发生时，它不直接把事件传递到事件调用者，而是在命令和调用者之间增加一个中间者，将这种直接关系切断，同时两者之间都隔离。事件调用者只是和接口打交道，不和具体实现交互。命令模式的实现是由vtkObjectBase的另外一个重要子类vtkCommand及其派生类实现的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkSmartPointer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkBMPReader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkImageViewer2.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkRenderWindowInteractor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkCallbackCommand.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vtkAutoInit.h&gt;</span></span><br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkRenderingOpenGL2);<br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkInteractionStyle);<br><br><span class="hljs-type">long</span> pressCounts = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//第一步，定义回调函数。</span><br><span class="hljs-comment">//注意回调函数的签名，不能更改。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyCallbackFunc</span><span class="hljs-params">(vtkObject*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eid, <span class="hljs-type">void</span>* clientdata,<span class="hljs-type">void</span> *calldata)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;You have clicked:&quot;</span>&lt;&lt;++pressCounts&lt;&lt;<span class="hljs-string">&quot; times.&quot;</span>&lt;&lt;std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>reader-&gt;<span class="hljs-built_in">Allow8BitBMPOn</span>();<br>reader-&gt;<span class="hljs-built_in">SetDebug</span>(<span class="hljs-number">0</span>);<br>reader-&gt;<span class="hljs-built_in">GlobalWarningDisplayOff</span>();<br>reader-&gt;<span class="hljs-built_in">Update</span>();<br>vtkSmartPointer&lt;vtkImageViewer2&gt; viewer = vtkSmartPointer&lt;vtkImageViewer2&gt;::<span class="hljs-built_in">New</span>();<br>viewer-&gt;<span class="hljs-built_in">SetInputData</span>(reader-&gt;<span class="hljs-built_in">GetOutput</span>());<br><br>vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; interactor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>viewer-&gt;<span class="hljs-built_in">SetupInteractor</span>(interactor);<br>viewer-&gt;<span class="hljs-built_in">Render</span>();<br><span class="hljs-comment">//第二步，设置回调函数。</span><br>vtkSmartPointer&lt;vtkCallbackCommand&gt; mouseCallback = vtkSmartPointer&lt;vtkCallbackCommand&gt;::<span class="hljs-built_in">New</span>();<br>mouseCallback-&gt;<span class="hljs-built_in">SetCallback</span>(MyCallbackFunc);<br><span class="hljs-comment">//第三步，将vtkCallbackCommand对象添加到观察者列表。</span><br>interactor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(viewer-&gt;<span class="hljs-built_in">GetRenderWindow</span>());<br>interactor-&gt;<span class="hljs-built_in">AddObserver</span>(vtkCommand::LeftButtonPressEvent, mouseCallback);<br>interactor-&gt;<span class="hljs-built_in">Initialize</span>();<br>interactor-&gt;<span class="hljs-built_in">Start</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021022024.png" style="zoom: 50%;" /></p><p>首先，定义回调函数。回调函数的签名只能是以下形式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyCallbackFunc</span><span class="hljs-params">(vtkObject*obj,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eid, <span class="hljs-type">void</span>* clientdata, <span class="hljs-type">void</span> *calldata)</span></span>;<br></code></pre></div></td></tr></table></figure><p>其次是创建一个vtkCallbackCommand对象，并调用vtkCallbackCommand::SetCallback()设置第一步定义的回调函数。</p><p>最后是将vtkCallbackCommand对象添加到对象的观察者列表。</p><p>下面说另一种使用回调函数的方法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkSmartPointer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkConeSource.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkPolyDataMapper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkRenderWindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkRenderWindowInteractor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkCamera.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkActor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkRenderer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkCommand.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkBoxWidget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkTransform.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vtkInteractorStyleTrackballCamera.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vtkAutoInit.h&gt;</span></span><br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkRenderingOpenGL2);<br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkInteractionStyle);<br><br><span class="hljs-comment">//第一步</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vtkMyCallback</span> : <span class="hljs-keyword">public</span> vtkCommand<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> vtkMyCallback* <span class="hljs-title">New</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> vtkMyCallback; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">(vtkObject* caller, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eventId, <span class="hljs-type">void</span>* callData)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vtkTransform* t = vtkTransform::<span class="hljs-built_in">New</span>();<br>        vtkBoxWidget* widget = <span class="hljs-built_in">reinterpret_cast</span>&lt;vtkBoxWidget*&gt;(caller);<br>        widget-&gt;<span class="hljs-built_in">GetTransform</span>(t);<br>        widget-&gt;<span class="hljs-built_in">GetProp3D</span>()-&gt;<span class="hljs-built_in">SetUserTransform</span>(t);<br>        t-&gt;<span class="hljs-built_in">Delete</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkConeSource&gt; cone = vtkSmartPointer&lt;vtkConeSource&gt;::<span class="hljs-built_in">New</span>();<br>    cone-&gt;<span class="hljs-built_in">SetHeight</span>(<span class="hljs-number">3.0</span>);<br>    cone-&gt;<span class="hljs-built_in">SetRadius</span>(<span class="hljs-number">1.0</span>);<br>    cone-&gt;<span class="hljs-built_in">SetResolution</span>(<span class="hljs-number">10</span>);<br><br>    vtkSmartPointer&lt;vtkPolyDataMapper&gt; coneMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::<span class="hljs-built_in">New</span>();<br>    coneMapper-&gt;<span class="hljs-built_in">SetInputConnection</span>(cone-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br><br>    vtkSmartPointer&lt;vtkActor&gt; coneActor = vtkSmartPointer&lt;vtkActor&gt;::<span class="hljs-built_in">New</span>();<br>    coneActor-&gt;<span class="hljs-built_in">SetMapper</span>(coneMapper);<br><br>    vtkSmartPointer&lt;vtkRenderer&gt; ren1 = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>    ren1-&gt;<span class="hljs-built_in">AddActor</span>(coneActor);<br>    ren1-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>);<br><br>    vtkSmartPointer&lt;vtkRenderWindow&gt; renWin = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>    renWin-&gt;<span class="hljs-built_in">AddRenderer</span>(ren1);<br>    renWin-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br><br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; iren = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    iren-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renWin);<br><br>    vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt; style = vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt;::<span class="hljs-built_in">New</span>();<br>    iren-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br><br>    <span class="hljs-comment">//通过vtkBoxWidget可以控制coneActor的变换矩阵，从而实现coneActor的形变</span><br>    vtkSmartPointer&lt;vtkBoxWidget&gt; boxWidget = vtkSmartPointer&lt;vtkBoxWidget&gt;::<span class="hljs-built_in">New</span>();<br>    boxWidget-&gt;<span class="hljs-built_in">SetInteractor</span>(iren);<br>    boxWidget-&gt;<span class="hljs-built_in">SetPlaceFactor</span>(<span class="hljs-number">1.25</span>);<br>    boxWidget-&gt;<span class="hljs-built_in">SetProp3D</span>(coneActor);<br>    boxWidget-&gt;<span class="hljs-built_in">PlaceWidget</span>();<br><br>    <span class="hljs-comment">//第二步</span><br>    vtkSmartPointer&lt;vtkMyCallback&gt; callback = vtkSmartPointer&lt;vtkMyCallback&gt;::<span class="hljs-built_in">New</span>();<br>    <span class="hljs-comment">//第三步</span><br>    boxWidget-&gt;<span class="hljs-built_in">AddObserver</span>(vtkCommand::InteractionEvent, callback);<br><br>    <span class="hljs-comment">//激活Widget。按“i”键可以关闭或激活Widget。</span><br>    boxWidget-&gt;<span class="hljs-built_in">On</span>();<br><br>    iren-&gt;<span class="hljs-built_in">Initialize</span>();<br>    iren-&gt;<span class="hljs-built_in">Start</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021108926.png" style="zoom:67%;" /></p><p>首先我们从vtkCommand派生出类vtkMyCallback，该类主要实现两个方法，一个是New()，用于为创建的对象申请内存；一个是Execute()，这是父类vtkCommand里定义的纯虚函数，其原型为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">(vtkObject *caller, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eventId,<span class="hljs-type">void</span> *callData)</span> </span>= <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><p>这意味着，只要从vtkCommand派生的类，都必须实现这个方法。而这个方法的作用就是一旦监听到所要监听的事件，就会自动地调用该方法。监听到事件后，要完成什么样的操作，都是在Execute()方法里实现。</p><hr /><p>在vtkObject.h文件里面有一个受保护的数据成员MTime，与这个MTime相关的公共接口有GetMTime()(返回MTime的值)以及Modified()。MTime全称是ModificationTime，vtkObject实现了可视化管线。</p><hr /><h2 id="可视化管线">可视化管线😎</h2><p>在之前的例子中，我们可以找到以下列出的类或其子类：</p><p>vtkProp; vtkAbstractMapper;vtkProperty; vtkCamera; vtkLight;vtkRenderer; vtkRenderWindow;vtkRenderWindowInteractor; vtkTransform;vtkLookupTable</p><p>我们发现，这些类都是与数据显示或者说渲染相关的。用一个专业的词汇来说，它们构成了VTK的渲染引擎(RenderingEngine)。渲染引擎主要负责数据的可视化表达，它是VTK里的两个重要模块之一，另外一个重要的模块就是可视化管线(VisualizationPipeline)。</p><p>可视化管线是指用于获取或创建数据，处理数据，以及把数据写入文件或者把数据传递给渲染引擎进行显示，这样的一种结构在VTK里就称之为可视化管线。数据对象(DataObject)、处理对象(Process Object)和数据流方向(Direction of DataFlow)是可视化管线的三个基本要素。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkSmartPointer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkStructuredPointsReader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkRenderer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkRenderWindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkRenderWindowInteractor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkMarchingCubes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkPolyDataMapper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkActor.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vtkAutoInit.h&gt;</span></span><br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkRenderingOpenGL2);<br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkInteractionStyle);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//读入Structured_Points类型的vtk文件。</span><br>    vtkSmartPointer&lt;vtkStructuredPointsReader&gt; reader = vtkSmartPointer&lt;vtkStructuredPointsReader&gt;::<span class="hljs-built_in">New</span>();<br>    <span class="hljs-comment">// 此 vtk 文件地址 ： https://masterwangzx.com/assets/vtk_res/head.vtk</span><br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;head.vtk&quot;</span>);<br><br>    <span class="hljs-comment">//用移动立方体法提取等值面。</span><br>    vtkSmartPointer&lt;vtkMarchingCubes&gt; marchingCubes = vtkSmartPointer&lt;vtkMarchingCubes&gt;::<span class="hljs-built_in">New</span>();<br>    marchingCubes-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>    marchingCubes-&gt;<span class="hljs-built_in">SetValue</span>(<span class="hljs-number">0</span>, <span class="hljs-number">500</span>);<br><br>    <span class="hljs-comment">//将生成的等值面数据进行Mapper</span><br>    vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::<span class="hljs-built_in">New</span>();<br>    mapper-&gt;<span class="hljs-built_in">SetInputConnection</span>(marchingCubes-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br><br>    <span class="hljs-comment">//把Mapper的输出送入渲染引擎进行显示</span><br>    <span class="hljs-comment">//渲染引擎部分</span><br>    vtkSmartPointer&lt;vtkActor&gt; actor = vtkSmartPointer&lt;vtkActor&gt;::<span class="hljs-built_in">New</span>();<br>    actor-&gt;<span class="hljs-built_in">SetMapper</span>(mapper);<br><br>    vtkSmartPointer&lt;vtkRenderWindow&gt; renWin = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>    vtkSmartPointer&lt;vtkRenderer&gt; renderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; interactor = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br><br>    renderer-&gt;<span class="hljs-built_in">AddActor</span>(actor);<br>    renWin-&gt;<span class="hljs-built_in">AddRenderer</span>(renderer);<br>    interactor-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renWin);<br><br>    interactor-&gt;<span class="hljs-built_in">Initialize</span>();<br>    interactor-&gt;<span class="hljs-built_in">Start</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021639654.png" style="zoom:67%;" /></p><p>在我们之前的项目中，项目的可视化管线一般是这样的：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021455051.png" style="zoom: 80%;" /></p><p>在上面的例子中的可视化管线是这样的：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021456235.png" style="zoom:80%;" /></p><p>上例中多了一个vtkMarchingCubes用于处理读入的数据。<strong>在VTK里，我们把与vtkMarchingCubes类似的对数据做处理的类称为Filter</strong>。我们还可以抽象出更一般的VTK可视化管线结构图：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021457013.png" style="zoom: 80%;" /></p><p>Source是指用于创建数据(如vtkCylinderSource)或者读取数据(如vtkBMPReader、vtkStructuredPointsReader等)的类的统称，即VTK的数据源。Source输出的数据作为Filter的输入，经Filter处理以后(可以经多个Filter处理)，生成新的数据。Filter的输出可以直接写入文件，或者经Mapper变换后送入渲染引擎进行渲染、显示，结束可视化管线。我们知道，可视化管线的三要素分别是数据对象、处理对象和数据流方向，Source、Filter和Mapper一起就构成了处理对象，它们的区别是基于数据流的初始化、维持和终止。根据数据的生成方式，Source可以分为Procedural对象(如vtkCylinderSource，通过程序代码生成相关的数据)和Reader对象(如vtkBMPReader，从外部文件中导入数据)。</p><p>关于Source、Filter和Mapper的区别可以简单地通过下图表示。Source没有输入，但至少有一个输出；Filter可以有一个或多个输入，产生一个或多个输出；Mapper接受一个或多个的输出，但没有输出，写文件的Writer(如vtkBMPWriter)可以看作是Mapper，负责把数据写入文件或者流(Stream)中，因此，Mapper是可视化管线的终点，同时也是可视化管线和渲染引擎(有时也称之为图形管线)的桥梁。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021501637.png" style="zoom:80%;" /></p><p>可视化管线里各个模块的连接是通过接口SetInputConnection()和GetOutputPort()来完成的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">marchingCubes-&gt;<span class="hljs-built_in">SetInputConnection</span>(reader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br></code></pre></div></td></tr></table></figure><p>上行代码把reader的输出(由GetOutputPort()得到)作为marchingCubes的输入(SetInputConnection()设置其输入)。</p><p>vtkMarchingCubes作为Filter只接受一个输入，Filter概括起来有以下三种类型：单个输入，产生单个输出；多个输入，产生单个输出，但输出的数据可有多种用途，比如，我们读入数据以后，可以对其作等值面提取，另外还可以针对读入的数据生成轮廓线(Outline)；第三种Filter是单个输入，产生多个输出。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021505275.png" style="zoom:75%;" /></p><hr /><p>可视化管线连接完成后，必须有一种机制来控制管线的执行。比如某些时候，对某一部分数据做了改变，我们希望得到的结果是：改变的这部分数据在可视化管线里作更新，而其他没做改变的数据则不要去惊动它。下图中，假如FilterD的输入发生了变化，E和F是依赖于D的输入的，所以红色虚线框内的部分是需要重新执行的管线，而C和G是另外一个分支，D输入改变不影响C和G，所以，为了节省运行时间，C和G是不需要重新执行的。毕竟对于三维的应用程序来说，一般所处理的数据都是大得惊人的，如果真能做到这样，也有利于提高程序的运行速率。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021521475.png" style="zoom:80%;" /></p><p>VTK采用一种叫做“惰性赋值”(LazyEvaluation)的方案来控制管线的执行，惰性赋值是指根据每个对象的内部修改时间来决定什么时候执行管线，只有当你或者程序发出“请求数据”时，管线才会被执行(前面提到vtkObject里有一个重要的成员变量MTime，管线里的每个从vtkObject派生的类的对象都会跟踪自己的内部修改时间，当遇到“请求数据”时，该对象会比较这个修改时间，如果发现修改时间发生了改变，对象就会执行。)。换言之，VTK是采用命令驱动(DemandDriven)的方法来控制管线的执行，这种方法的好处是，当对数据对象作了更改时，不必立即作计算，只有当发出请求时才开始处理，这样能最小化计算所需的时间，以便更流畅地与数据进行交互。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkBMPReader&gt; reader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>    reader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br>    vtkImageData* imageData = reader-&gt;<span class="hljs-built_in">GetOutput</span>();<br>    <span class="hljs-comment">// 删除下面这行代码是有问题的</span><br>    <span class="hljs-comment">// reader-&gt;Update();</span><br>    <span class="hljs-type">int</span> extent[<span class="hljs-number">6</span>];<br>    imageData-&gt;<span class="hljs-built_in">GetExtent</span>(extent);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Extent of image:&quot;</span> &lt;&lt; extent[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; extent[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; extent[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span><br>        &lt;&lt; extent[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; extent[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; extent[<span class="hljs-number">5</span>] &lt;&lt; std::endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码是无法输出这张图片的长宽等信息的，主要原因在于在渲染引擎的最后，当我们调用Render()函数的时候，Actor就会收到渲染请求，接着Actor会请求Mapper给它发送数据，而Mapper又会请求上一层的Filter的数据，Filter最后去请求Source给它数据，于是，整条管线就被执行。除非像上面的代码段里列出的，读入数据以后，中间想要输出某些信息，在得到这些信息之前，你就应该显性地调用Update()函数。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212021537566.png" style="zoom:80%;" /></p><hr /><h2 id="总结">总结🪔</h2><p>vtkObjectBase和vtkObject是VTK里两个重要的父类，vtkObjectBase采用引用计数和智能指针的技术来管理VTK对象的内存分配与回收。vtkObjectBase定义了运行时类型识别及状态信息输出的相关接口，有助于调试VTK应用程序。VTK框架里，大多数的类都是从vtkObject派生，vtkObject实现了观察者/命令(Observer/Command)设计模式，内部维护一个修改时间，用于控制可视化管线的执行。可视化管线是VTK里的重要概念，管线的连接应该使用SetInputConnection()/GetOutputPort()接口进行连接。VTK采用“惰性赋值”(LazyEvaluation)的方案来控制管线的执行，只有当发出“请求数据”时，管线才会被执行。好处是，当对数据对象作了更改时，不必立即作计算，只有当发出请求时才开始处理，这样能最小化计算所需的时间，以便更流畅地进行交互。</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VTK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VTK学习笔记（一）</title>
    <link href="/post/702033f1.html"/>
    <url>/post/702033f1.html</url>
    
    <content type="html"><![CDATA[<p>本系列文章主要对<ahref="https://vtk.org/">VTK</a>的相关知识进行总结。 <span id="more"></span></p><h1 id="vtk学习笔记一">VTK学习笔记（一）</h1><h2 id="vtk简介">VTK简介🗻</h2><p>VTK，全称为VisualizationToolkit，也就是可视化工具包。是一个开源、跨平台、可自由获取、支持并行处理的图形应用函数库。</p><p>三维计算机图形、图像处理及可视化是VTK主要的应用方向。</p><p>VTK包含一个C++类库，众多的翻译接口层（与其他语言对接）。VTK是在三维函数库OpenGL的基础上采用面向对象的设计方法发展起来的，它将我们在可视化开发过程中会经常遇到的细节屏蔽起来，并将一些常用的算法封装起来。</p><h2 id="vtkitk编译安装">VTK、ITK编译安装🦜</h2><p>先来说一下我的电脑配置：</p><ul><li>VS2019 + QT5.15.2 + VTK8.2.0 + ITK5.2.1 + CMake3.24.3</li></ul><p>参考这个<ahref="https://blog.csdn.net/qq_41955524/article/details/120876226?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166927919116782429785768%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=166927919116782429785768&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-120876226-null-null.142%5Ev66%5Econtrol,201%5Ev3%5Econtrol_1,213%5Ev2%5Et3_esquery_v3&amp;utm_term=vs2019%2Bvtk8.2.0%2Bqt5.15&amp;spm=1018.2226.3001.4187">链接</a>进行安装即可</p><p><strong>需要注意的点：</strong></p><ol type="1"><li>QT、VTK、ITK都要设置系统环境变量，每次修改完环境变量都应该重启电脑（所以要重启三次）。</li><li>安装VTK时，我遇到的情况是CMake选中QT组件，在VS里编译会报错，只需要给报错的文件<code>include</code>相应的头文件即可。</li></ol><h2 id="vtk基本概念">VTK基本概念⚗️</h2><h4 id="一个例子">一个例子🦉</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkSmartPointer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkRenderWindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkRenderer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkRenderWindowInteractor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkInteractorStyleTrackballCamera.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkCylinderSource.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkPolyDataMapper.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vtkActor.h&quot;</span></span><br><br><span class="hljs-comment">// 因为我没有使用 CMake 进行配置，所以需要下面语句</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vtkAutoInit.h&gt;</span></span><br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkRenderingOpenGL2);<br><span class="hljs-built_in">VTK_MODULE_INIT</span>(vtkInteractionStyle);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vtkSmartPointer&lt;vtkCylinderSource&gt; cylinder = vtkSmartPointer&lt;vtkCylinderSource&gt;::<span class="hljs-built_in">New</span>();<br>    cylinder-&gt;<span class="hljs-built_in">SetHeight</span>(<span class="hljs-number">3.0</span>);<br>    cylinder-&gt;<span class="hljs-built_in">SetRadius</span>(<span class="hljs-number">1.0</span>);<br>    cylinder-&gt;<span class="hljs-built_in">SetResolution</span>(<span class="hljs-number">10</span>);<br><br>    vtkSmartPointer&lt;vtkPolyDataMapper&gt; cylinderMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::<span class="hljs-built_in">New</span>();<br>    cylinderMapper-&gt;<span class="hljs-built_in">SetInputConnection</span>(cylinder-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br><br>    vtkSmartPointer&lt;vtkActor&gt; cylinderActor = vtkSmartPointer&lt;vtkActor&gt;::<span class="hljs-built_in">New</span>();<br>    cylinderActor-&gt;<span class="hljs-built_in">SetMapper</span>(cylinderMapper);<br><br>    vtkSmartPointer&lt;vtkRenderer&gt; renderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>    renderer-&gt;<span class="hljs-built_in">AddActor</span>(cylinderActor);<br>    renderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>);<br><br>    vtkSmartPointer&lt;vtkRenderWindow&gt; renWin = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>    renWin-&gt;<span class="hljs-built_in">AddRenderer</span>(renderer);<br>    renWin-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br><br>    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; iren = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>    iren-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renWin);<br><br>    vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt; style = vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt;::<span class="hljs-built_in">New</span>();<br>    iren-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br><br>    iren-&gt;<span class="hljs-built_in">Initialize</span>();<br>    iren-&gt;<span class="hljs-built_in">Start</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下图：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202211271511223.png" style="zoom:80%;" /></p><p>下面解析相应代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkCylinderSource&gt; cylinder = vtkSmartPointer&lt;vtkCylinderSource&gt;::<span class="hljs-built_in">New</span>();<br>cylinder-&gt;<span class="hljs-built_in">SetHeight</span>(<span class="hljs-number">3.0</span>);<br>cylinder-&gt;<span class="hljs-built_in">SetRadius</span>(<span class="hljs-number">1.0</span>);<br>cylinder-&gt;<span class="hljs-built_in">SetResolution</span>(<span class="hljs-number">10</span>);<br></code></pre></div></td></tr></table></figure><p><code>vtkCylinderSource</code>：派生自vtkPolyDataAlgorithm。顾名思义，vtkCylinderSource生成的数据类型就是PolyData(vtkPolyData)的，它主要是生成一个中心在渲染场景原点的柱体，柱体的长轴沿着Y轴，柱体的高度、截面半径等都可以任意指定。</p><p>vtkCylinderSource::SetHeight() ：设置柱体的高。</p><p>vtkCylinderSource::SetRadius() ：设置柱体横截面的半径。</p><p>vtkCylinderSource::SetResolution()：设置柱体横截面的等边多边形的边数。</p><hr /><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkPolyDataMapper&gt; cylinderMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::<span class="hljs-built_in">New</span>();<br>cylinderMapper-&gt;<span class="hljs-built_in">SetInputConnection</span>(cylinder-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br></code></pre></div></td></tr></table></figure><p><code>vtkPolyDataMapper</code>：渲染多边形几何数据(vtkPolyData)，派生自类vtkMapper，将输入的数据转换为几何图元(点、线、多边形)进行渲染。</p><p>vtkPolyDataMapper::SetInputConnection()：VTK可视化管线的输入数据接口，对应的可视化管线输出数据的接口为GetOutputPort()；VTK5.0之前的版本使用SetInput()和GetOutput()作为输入输出接口，VTK5.0以后版本保留了对这两个接口的支持。</p><hr /><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkActor&gt; cylinderActor = vtkSmartPointer&lt;vtkActor&gt;::<span class="hljs-built_in">New</span>();<br>cylinderActor-&gt;<span class="hljs-built_in">SetMapper</span>(cylinderMapper);<br></code></pre></div></td></tr></table></figure><p><code>vtkActor</code>：派生自vtkProp类，渲染场景中数据的可视化表达是通过vtkProp的子类负责的。比如，本例要渲染一个柱体，柱体的数据类型是vtkPolyData，数据要在场景中渲染时，不是直接把数据加入渲染场景就可以，待渲染的数据是以vtkProp的形式存在于渲染场景中。三维空间中渲染对象最常用的vtkProp子类是vtkActor(表达场景中的几何数据)和vtkVolume(表达场景中的体数据)；二维空间中的数据则是用vtkActor2D表达。vtkProp子类负责确定渲染场景中对象的位置、大小和方向信息。Prop依赖于两个对象(Prop一词来源于戏剧里的“道具”，在VTK里表示的是渲染场景中可以看得到的对象。)，一个是Mapper(vtkMapper)对象，负责存放数据和渲染信息，另一个是属性(vtkProperty)对象，负责控制颜色、不透明度等参数。</p><hr /><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkRenderer&gt; renderer = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>renderer-&gt;<span class="hljs-built_in">AddActor</span>(cylinderActor);<br>renderer-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindow&gt; renWin = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>renWin-&gt;<span class="hljs-built_in">AddRenderer</span>(renderer);<br>renWin-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br></code></pre></div></td></tr></table></figure><p><code>vtkRenderWindow</code>：将操作系统与VTK渲染引擎连接到一起。不同平台下的vtkRenderWindow子类负责本地计算机系统中窗口创建和渲染过程管理。当使用VTK开发应用程序时，只需要使用平台无关的vtkRendererWindow类，运行时，系统会自动替换为平台相关的vtkRendererWindow子类。比如，Windows下运行上述的VTK程序，实际创建的是vtkWin32OpenGLRenderWindow(vtkRenderWindow的子类)对象。vtkRenderWindow中包含了vtkRenderer集合、渲染参数，如立体显示（Stereo），反走样，运动模糊（MotionBlur）和焦点深度（Focal Depth）等。</p><p>vtkRenderWindow::AddRenderer() ：加入vtkRenderer对象。</p><p>vtkRenderWindow::SetSize()：该方法是从vtkRenderWindow的父类vtkWindow继承过来的，用于设置窗口的大小，以像素为单位。</p><p><code>vtkRenderer</code>：负责管理场景的渲染过程。组成场景的所有对象包括Prop，照相机(Camera)和光照(Light)都被集中在一个vtkRenderer对象中。一个vtkRenderWindow中可以有多个vtkRenderer对象，而这些vtkRenderer可以渲染在窗口中不同的矩形区域中(即视口)，或者覆盖整个窗口区域。</p><p>vtkRenderer::AddActor() ：添加vtkProp类型的对象到渲染场景中。</p><p>vtkRenderer::SetBackground()：该方法是从vtkRenderer的父类vtkViewport继承的，用于设置渲染场景的背景颜色，用R、G、B的格式设置，三个分量的取值为0.0~1.0。(0.0,0.0, 0.0)为黑色，(1.0,1.0,1.0)为白色。除了可以设置单一的背景颜色之外，还可以设置渐变的背景颜色，vtkViewport::SetBackground2()用于设置渐变的另外一种颜色，但是要使背景颜色渐变生效或者关闭，必须调用以下的方法：</p><p>vtkViewport::SetGradientBackground(bool)：参数为0是关闭，反之，打开。</p><p>vtkViewport::GradientBackgroundOn() ：打开背景颜色渐变效果，相当于调用方法SetGradientBackground(1)。</p><p>vtkViewport::GradientBackgroundOff()：关闭背景颜色渐变效果。相当于调用方法SetGradientBackground(0)。</p><hr /><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; iren = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>iren-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renWin);<br></code></pre></div></td></tr></table></figure><p><code>vtkRenderWindowInteractor</code>：提供平台独立的响应鼠标、键盘和时钟事件的交互机制，通过VTK的Command/Observer设计模式将监听到的特定平台的鼠标、键盘和时钟事件交由vtkInteractorObserver或其子类，如vtkInteractorStyle进行处理。vtkInteractorStyle等监听这些消息并进行处理以完成旋转、拉伸和放缩等运动控制。vtkRenderWindowInteractor自动建立一个默认的3D场景交互器样式(InteractorStyle)：vtkInteractorStyleSwitch，当然也可以选择其他的交互器样式，或者是创建自己的交互器样式。在本例中，选择了其他的交互器样式来替代默认的：vtkInteractorStyleTrackballCamera。</p><p>vtkRenderWindowInteractor::SetRenderWindow()：设置渲染窗口，消息是通过渲染窗口捕获到的，所以必须要给交互器对象设置渲染窗口。</p><p>vtkRenderWindowInteractor::SetInteractorStyle()：定义交互器样式，默认的交互样式为vtkInteractorStyleSwitch。</p><p>vtkRenderWindowInteractor::Initialize()：为处理窗口事件做准备，交互器工作之前必须先调用这个方法进行初始化。</p><p>vtkRenderWindowInteractor::Start()：开始进入事件响应循环，交互器处于等待状态，等待用户交互事件的发生。进入事件响应循环之前必须先调用Initialize()方法。</p><hr /><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt; style = vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt;::<span class="hljs-built_in">New</span>();<br>iren-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br></code></pre></div></td></tr></table></figure><p><code>vtkInteractorStyleTrackballCamera</code>：交互器样式的一种，该样式下，用户是通过控制相机对物体作旋转、放大、缩小等操作。做个类比：在照相的时候如果要想物体看起来显得大一些，可以采取两种做法，第一种做法是相机不动，让我们要拍的物体靠近我们；第二种做法是物体不要动，我们把相机靠近物体，这样物体看起来也是大一些。第二种做法就是vtkInteractorStyleTrackballCamera的风格。其父类为vtkInteractorStyle，除了vtkInteractorStyleTrackballCamera之外，VTK还定义了其他多种交互器样式，如vtkInteractorStyleImage，主要用于显示二维图像时的交互。</p><hr /><p>下面举一个例子进行汇总：</p><p>当我们去看舞台剧的时候，我们坐在台下，展现在我们面前的是一个舞台，舞台上有各式的灯光，各样的演员。演员出场的时候肯定是会先化妆，有些演员可能会打扮成高富帅，有些演员可能会化妆成白富美。观众有时还会与台上的演员有一定的互动。</p><p>整个剧院就好比VTK程序的渲染窗口(vtkRenderWindow)；舞台就相当于渲染场景(vtkRenderer)；而那些高富帅、白富美就是我们程序中的Actor(有些文献翻译成“演员”，有些翻译成“角色”，这里我们不作翻译)；台上的演员与台下观众的互动可以看成是程序的交互(vtkRenderWindowInteractor)；演员与观众的互动方式有很多种，现场的观众可以直接上台跟演员们握手拥抱，电视机前的可以发短信，电脑、移动终端用户等可以微博关注、加粉等等，这就好比我们程序里的交互器样式(vtkInteractorStyle)；舞台上的演员我们都能一一分辨出来，不会把高富帅弄混淆，是因为他们化的妆、穿的服饰都不一样，这就相当于我们程序里vtkActor的不同属性(vtkProperty)；台下观众的眼睛可以看作是vtkCamera，前排的观众因为离得近，看台上演员会显得比较高大，而后排的观众看到的会显得小点，每个观众看到的东西在他的世界里都是唯一的，所以渲染场景Renderer里的vtkCamera对象也是只有一个；舞台上的灯光可以有多个，所以渲染场景里的vtkLight也存在多个。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202211301440523.png" style="zoom:80%;" /></p><hr /><h4 id="vtkactor及相关属性">vtkActor及相关属性⛺</h4><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/img/202211301529774.png" /></p><p>数据渲染时不是直接加入渲染场景，而是以vtkProp的形式存在的，因此有必要再详细讨论一下vtkProp及其子类，上图为vtkProp的类图。</p><p>vtkProp是任何存在于渲染窗口的对象的父类，包括二维或者三维的对象。换言之，在渲染窗口里能够看得到的对象(这些对象都称作Prop)，都是从vtkProp继承过来的。在这个类里定义了用于拾取(Picking)、LOD(Level-Of-Detail)操作的方法，同时也定义了确定Prop是否可见、可否被拾取以及可否被拖动等的变量。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">SetVisibility</span> (<span class="hljs-type">int</span>) | <span class="hljs-built_in">GetVisibility</span> () | <span class="hljs-built_in">VisibilityOn</span> () | <span class="hljs-built_in">VisibilityOff</span> () | <span class="hljs-built_in">Pick</span> () | <span class="hljs-built_in">SetPickable</span> (<span class="hljs-type">int</span>) | <span class="hljs-built_in">GetPickable</span> () | <span class="hljs-built_in">PickableOn</span>() | <span class="hljs-built_in">PickableOff</span> () | <span class="hljs-built_in">SetDragable</span> (<span class="hljs-type">int</span>) | <span class="hljs-built_in">GetDragable</span> () | <span class="hljs-built_in">DragableOn</span> () | <span class="hljs-built_in">DragableOff</span>()<br></code></pre></div></td></tr></table></figure><p>vtkProp3D从vtkProp直接派生，是对象在三维渲染场景中的表达形式。把一个对象放置在三维场景时，首先要考虑的是这个对象到底要放在场景中的哪个位置，摆放的方向如何等等，这些信息在vtkProp3D内部用一个4×4的矩阵来表示。默认构造的vtkProp3D对象原点为(0,0,0)，放置的位置为(0,0,0)，放置的方向为(0,0,0)，用户自定义的矩阵或者变换为空。以下是vtkProp3D定义的用于放置vtkProp3D对象的方法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 设置/获取各向同性的缩放比例。</span><br><span class="hljs-built_in">SetScale</span> (<span class="hljs-type">double</span>) / <span class="hljs-built_in">GetScale</span> ();<br><span class="hljs-comment">// 设置/获取各同异性的缩放比例。</span><br><span class="hljs-built_in">SetScale</span> (<span class="hljs-type">double</span>, <span class="hljs-type">double</span>,<span class="hljs-type">double</span>) / <span class="hljs-built_in">GetScale</span> (<span class="hljs-type">double</span>);<br><span class="hljs-comment">// 分别绕X、Y、Z轴旋转指定角度。 </span><br><span class="hljs-built_in">RotateX</span> (<span class="hljs-type">double</span>) / <span class="hljs-built_in">RotateY</span> (<span class="hljs-type">double</span>) / <span class="hljs-built_in">RotateZ</span> (<span class="hljs-type">double</span>);<br><span class="hljs-comment">// 绕指定的方向旋转指定的角度，第一个参数表示旋转角度，后三个参数确定一个方向。</span><br><span class="hljs-built_in">RotateWXYZ</span> (<span class="hljs-type">double</span>, <span class="hljs-type">double</span>,<span class="hljs-type">double</span>, <span class="hljs-type">double</span>);<br><span class="hljs-comment">// 用于获取对应的数据。</span><br><span class="hljs-built_in">GetOrientationWXYZ</span>();<br><span class="hljs-comment">// 设置vtkProp3D对象的方向。先绕Z轴旋转，然后绕X轴，最后绕Y轴旋转，从而确定vtkProp3D对象的方向。</span><br><span class="hljs-built_in">SetOrientation</span> (<span class="hljs-type">double</span>, <span class="hljs-type">double</span>,<span class="hljs-type">double</span>) / <span class="hljs-built_in">GetOrientation</span> ();<br><span class="hljs-comment">// 在vtkProp3D对象的当前方向增加一个给定的偏移。</span><br><span class="hljs-built_in">AddOrientation</span> (<span class="hljs-type">double</span>, <span class="hljs-type">double</span>,<span class="hljs-type">double</span>);<br><span class="hljs-comment">// 在世界坐标系下，指定/获取vtkProp3D对象的位置。</span><br><span class="hljs-built_in">SetPosition</span> (<span class="hljs-type">double</span>, <span class="hljs-type">double</span>,<span class="hljs-type">double</span>) / <span class="hljs-built_in">GetPosition</span> ();<br><span class="hljs-comment">// 在vtkProp3D对象的当前位置增加一个偏移。</span><br><span class="hljs-built_in">AddPosition</span> (<span class="hljs-type">double</span>, <span class="hljs-type">double</span>,<span class="hljs-type">double</span>);<br><span class="hljs-comment">// 设置/获取vtkProp3D对象的原点。</span><br><span class="hljs-built_in">SetOrigin</span> (<span class="hljs-type">double</span>, <span class="hljs-type">double</span>,<span class="hljs-type">double</span> ) / <span class="hljs-built_in">GetOrigin</span> ();<br></code></pre></div></td></tr></table></figure><hr /><p>Prop依赖于两个对象，一个是Mapper(vtkMapper)对象，负责存放数据和渲染信息，另一个是属性(vtkProperty)对象，负责控制颜色、不透明度等参数。对应的这两个方法就是在类vtkActor里定义的：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 设置定义Actor几何形状的Mapper。</span><br><span class="hljs-built_in">SetMapper</span> (vtkMapper *);<br><span class="hljs-comment">// 设置Actor的属性，包括表面属性，如环境光(Ambient)、散射光(Diffuse)、镜面光(Specular)、颜色、透明度等；纹理映射；点的大小，线的宽度设置等。</span><br><span class="hljs-built_in">SetProperty</span> (vtkProperty *);<br></code></pre></div></td></tr></table></figure><p>每一个Actor都有一个属性对象(vtkProperty的实例)与之相关联，如果没有给Acttor指定相应的属性，VTK会指定默认的属性对象。</p><hr /><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 设置 vtkActor的 Property</span><br><span class="hljs-comment">// 方法一</span><br><span class="hljs-comment">// cylinderActor-&gt;GetProperty()-&gt;SetColor(1, 0, 0);</span><br><br><span class="hljs-comment">// 方法二（推荐）</span><br>vtkSmartPointer&lt;vtkProperty&gt; cylinderProperty = vtkSmartPointer&lt;vtkProperty&gt;::<span class="hljs-built_in">New</span>();<br>cylinderProperty-&gt;<span class="hljs-built_in">SetColor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>cylinderActor-&gt;<span class="hljs-built_in">SetProperty</span>(cylinderProperty);<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202211301658575.png" style="zoom:80%;" /></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkBMPReader&gt; bmpReader = vtkSmartPointer&lt;vtkBMPReader&gt;::<span class="hljs-built_in">New</span>();<br>bmpReader-&gt;<span class="hljs-built_in">SetFileName</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>);<br><br>vtkSmartPointer&lt;vtkTexture&gt; texture = vtkSmartPointer&lt;vtkTexture&gt;::<span class="hljs-built_in">New</span>();<br>texture-&gt;<span class="hljs-built_in">SetInputConnection</span>(bmpReader-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>texture-&gt;<span class="hljs-built_in">InterpolateOn</span>();<br><br>cylinderActor-&gt;<span class="hljs-built_in">SetTexture</span>(texture);<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202211301735964.png" style="zoom:80%;" /></p><hr /><h4 id="光照">光照🌅</h4><p>剧场里有各式各样的灯光，三维渲染场景中也一样，可以有多个光照存在。光照和相机是三维渲染场景必备的因素，如果没有指定，vtkRender会自动地创建默认的光照和相机。VTK里用类vtkLight来表示渲染场景中的光照。与现实中的灯光类似，VTK中的vtkLight实例也可以打开、关闭，设置光照的颜色，照射位置(即焦点)，光照所在的位置，强度等等。</p><p>vtkLight可以分为位置光照(PositionalLight，即聚光灯)和方向光照(DirectionLight)。位置光照是光源位置在渲染场景中的某个位置，可以指定光照的衰减值、锥角等；方向光照即光源位置在无穷远，光线可以认为是平行的，比如自然界中的太阳光。光源的位置和焦点的连线定义光线的方向，默认的vtkLight即为方向光照。</p><p>vtkLight常的方法有：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 设置光照的颜色，以RGB的形式指定颜色。</span><br><span class="hljs-built_in">SetColor</span>();<br><span class="hljs-comment">// 设置光照位置。</span><br><span class="hljs-built_in">SetPosition</span>();<br><span class="hljs-comment">// 设置光照焦点。</span><br><span class="hljs-built_in">SetFocalPoint</span>();<br><span class="hljs-comment">// 设置光照的强度。</span><br><span class="hljs-built_in">SetIntensity</span>();<br><span class="hljs-comment">// 打开或关闭对应的光照。</span><br><span class="hljs-built_in">SetSwitch</span>() / <span class="hljs-built_in">SwitchOn</span>()/ <span class="hljs-built_in">SwitchOff</span>();<br></code></pre></div></td></tr></table></figure><p>我们在讲vtkProp的时候，该类有方法<code>SetVisibility (int) | GetVisibility() | VisibilityOn() | VisibilityOff()</code>等来控制vtkProp对象的可见与不可见的属性。同样，vtkLight里也有类似命名风格的方法：<code>SetSwitch() | GetSwitch() | SwitchOn() | SwitchOff()</code>。不难发现，在VTK里，某个属性的设置都是采取这一类方法，以vtkLight为例，SwitchOn()跟SetSwitch(1)实现的效果是一样，SwitchOff()则与SetSwitch(0)是一样的，GetSwitch()则是用于获取vtkLight对象关闭或打开这个属性的值。如果某个类有提供SetXXX()方法，一般也会提供GetXXX()方法来获取相应的值，这个我们在前面的内容也已经有一些了解。再比如，vtkLight还提供：<code>SetPositional() | GetPositional() | PositionalOn() | PositionalOff()</code>一类方法来设置位置光照。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkLight&gt; myLight = vtkSmartPointer&lt;vtkLight&gt;::<span class="hljs-built_in">New</span>();<br>myLight-&gt;<span class="hljs-built_in">SetColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>myLight-&gt;<span class="hljs-built_in">SetPosition</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>myLight-&gt;<span class="hljs-built_in">SetFocalPoint</span>(renderer-&gt;<span class="hljs-built_in">GetActiveCamera</span>()-&gt;<span class="hljs-built_in">GetFocalPoint</span>());<br>renderer-&gt;<span class="hljs-built_in">AddLight</span>(myLight);<br><br>vtkSmartPointer&lt;vtkLight&gt; myLight2 = vtkSmartPointer&lt;vtkLight&gt;::<span class="hljs-built_in">New</span>();<br>myLight2-&gt;<span class="hljs-built_in">SetColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>myLight2-&gt;<span class="hljs-built_in">SetPosition</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>myLight2-&gt;<span class="hljs-built_in">SetFocalPoint</span>(renderer-&gt;<span class="hljs-built_in">GetActiveCamera</span>()-&gt;<span class="hljs-built_in">GetFocalPoint</span>());<br>renderer-&gt;<span class="hljs-built_in">AddLight</span>(myLight2);<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202211302002786.png" style="zoom:80%;" /></p><p>上述定义了两个vtkLight对象，一个为绿色光，位置在(0,0,1)，焦点对着相机的焦点；另一个为蓝色光，位置在(0,0,-1)，焦点也是对着相机的焦点，最后两个光照调用vtkRenderer的方法AddLight()加入到渲染场景中，因为Renderer里可以有多个灯照，所以，VTK提供的接口是AddLight()而不是SetLight()。</p><hr /><h4 id="相机">相机🦌</h4><p>观众的眼睛就好比三维渲染场景中的相机，VTK则是用vtkCamera类来表示三维渲染场景中的相机。vtkCamera负责把三维场景投影到二维平面，如屏幕、图像等。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202211302008165.png" style="zoom:80%;" /></p><p>图中名词解释：</p><ul><li>投影方向：相机位置到相机焦点的向量方向即为投影方向。</li><li>投影方法：确定Actor是如何映射到像平面的。vtkCamera定义了两种投影方法，一种是正交投影(OrthographicProjection)，也叫平行投影(ParallelProjection)，即进入相机的光线与投影方向是平行的。另一种是透视投影(PerspectiveProjection)，即所有的光线相交于一点。</li><li>视角：透视投影时需要指定相机的视角(ViewAngle)，默认的视角大小为30º，可以用方法vtkCamera::SetViewAngle()设置。</li><li>前后裁剪平面：裁剪平面与投影方向相交，一般与投影方向也是垂直的。裁剪平面主要用于评估Actor与相机距离的远近，只有在前后裁剪平面之间的Actor才是可见的。裁剪平面的位置可以用方法vtkCamera::SetClippingRange()设置。</li></ul><p>从图中可以看出与相机投影相关的因素主要有：</p><ul><li>相机位置：即相机所在的位置，用方法vtkCamera::SetPosition()设置。</li><li>相机焦点：用方法vtkCamera::SetFocusPoint()设置，默认的焦点位置在世界坐标系的原点。</li><li>朝上方向：即哪个方向为相机朝上的方向。就好比我们直立看东西，方向为头朝上，看到的东西也是直立的，如果我们倒立看某个东西，这时方向为头朝下，看到的东西当然就是倒立的。相机位置、相机焦点和朝上方向三个因素确定了相机的实际方向，即确定相机的视图。</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212011431910.png" style="zoom:50%;" /></p><p>上图可以直观的看出设置每一个量的作用。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vtkSmartPointer&lt;vtkCamera&gt; myCamera = vtkSmartPointer&lt;vtkCamera&gt;::<span class="hljs-built_in">New</span>();<br><span class="hljs-comment">// 设置前后裁剪平面</span><br>myCamera-&gt;<span class="hljs-built_in">SetClippingRange</span>(<span class="hljs-number">0.2</span>, <span class="hljs-number">3.5</span>);<br><span class="hljs-comment">// 设置焦点</span><br>myCamera-&gt;<span class="hljs-built_in">SetFocalPoint</span>(<span class="hljs-number">0.02</span>, <span class="hljs-number">0.03</span>, <span class="hljs-number">-0.8</span>);<br><span class="hljs-comment">// 设置位置</span><br>myCamera-&gt;<span class="hljs-built_in">SetPosition</span>(<span class="hljs-number">0.3</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">-0.3</span>);<br><span class="hljs-comment">// 根据设置的相机位置、焦点等信息，重新计算视平面(View Plane)的法向量。一般该法向量与视平面是垂直的，</span><br><span class="hljs-comment">// 如果不是垂直的话，Actor等看起来会有一些特殊的效果，如错切。</span><br>myCamera-&gt;<span class="hljs-built_in">ComputeViewPlaneNormal</span>();<br><span class="hljs-comment">// 设置相机朝上方向</span><br>myCamera-&gt;<span class="hljs-built_in">SetViewUp</span>(<span class="hljs-number">-0.2</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.03</span>);<br>renderer-&gt;<span class="hljs-built_in">SetActiveCamera</span>(myCamera);<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202211302031298.png" style="zoom: 80%;" /></p><p>vtkCamera除了提供设置与相机投影因素相关的方法之外，还提供了大量的控制相机运动的方法，如：vtkCamera::Dolly()，vtkCamera::Roll()，vtkCamera::Azimuth()，vtkCamera::Yaw()，vtkCamera::Elevation()，vtkCamera::Pitch()，vtkCamera::Zoom()。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202211302033203.png" alt="" style="zoom:80%;" /></p><p>vtkCamera具体可参见<ahref="https://blog.csdn.net/wzheng92/article/details/79935059">链接</a></p><hr /><h4 id="颜色">颜色🧟</h4><p>VTK采用RGB和HSV两种颜色系统来描述颜色。</p><p>RGB颜色系统就是由三个颜色分量：红色(R)、绿色(G)和蓝色(B)的组合表示，在VTK里这三个分量的取值都是从0到1，(0,0, 0)表示黑色，(1, 1,1)表示白色。vtkProperty::SetColor(r,g,b)采用的就是RGB颜色系统设置颜色属性值。</p><p>HSV颜色系统同样也是由三个分量来决定颜色，分别是：色相(Hue)，是颜色的基本属性，就是我们平常所说的颜色名称，如红色、黄色等；饱和度(Saturation)，是指颜色的纯度，其值越高则越纯；值(Value，也就是强度Intensity或者亮度Bright)，值为0通常表示的是黑色，值为1表示的是最亮的颜色。这三个分量的取值范围也是0到1。类vtkLookupTable提供了HSV颜色系统设置的方法。</p><table><thead><tr class="header"><th style="text-align: center;">颜色</th><th style="text-align: center;">RGB</th><th style="text-align: center;">HSV</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">黑色</td><td style="text-align: center;">0，0，0</td><td style="text-align: center;">*，*，0</td></tr><tr class="even"><td style="text-align: center;">白色</td><td style="text-align: center;">1，1，1</td><td style="text-align: center;">*，0，1</td></tr><tr class="odd"><td style="text-align: center;">红色</td><td style="text-align: center;">1，0，0</td><td style="text-align: center;">0，1，1</td></tr><tr class="even"><td style="text-align: center;">绿色</td><td style="text-align: center;">0，1，0</td><td style="text-align: center;">1/3，1，1</td></tr><tr class="odd"><td style="text-align: center;">蓝色</td><td style="text-align: center;">0，0，1</td><td style="text-align: center;">2/3，1，1</td></tr><tr class="even"><td style="text-align: center;">黄色</td><td style="text-align: center;">1，1，0</td><td style="text-align: center;">1/6，1，1</td></tr><tr class="odd"><td style="text-align: center;">蓝绿色</td><td style="text-align: center;">0，1，1</td><td style="text-align: center;">1/2，1，1</td></tr><tr class="even"><td style="text-align: center;">品红色</td><td style="text-align: center;">1，0，1</td><td style="text-align: center;">5/6，1，1</td></tr><tr class="odd"><td style="text-align: center;">天蓝色</td><td style="text-align: center;">0.5，0.5，1</td><td style="text-align: center;">2/3，1/2，1</td></tr></tbody></table><p>与颜色设置相关的VTK类除了vtkProperty，vtkLookupTable之外，还有vtkColorTransferFunction。vtkLookupTable和vtkColorTransferFunction都派生自vtkScalarsToColors。</p><hr /><h4 id="坐标系统及空间变换">坐标系统及空间变换🌱</h4><p>计算机图形学里常用的坐标系统主要有四种，分别是：Model坐标系统、World坐标系统、View坐标系统和Display坐标系统，以及两种表示坐标点的方式：以屏幕像素值为单位和归一化坐标值(各坐标轴取值都为[-1,1])。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212010959698.png" style="zoom:67%;" /></p><p>Model坐标系统是定义模型时所采用的坐标系统，通常是局部的笛卡尔坐标系。例如，我们要定义一个表示球体的Actor，一般的做法是将该球体定义在一个柱坐标系统里。</p><p>World坐标系统是放置Actor的三维空间坐标系，Actor其中的一个功能就是负责将模型从Model坐标系统变换到World坐标系统。每一个模型可以定义有自己的Model坐标系统，但World坐标系只有一个，每一个Actor必须通过放缩、旋转、平移等操作将Model坐标系变换到World坐标系。World坐标系同时也是相机和光照所在的坐标系统。</p><p>View坐标系统表示的是相机所看见的坐标系统。X、Y、Z轴取值为[-1,1]，X、Y值表示像平面上的位置，Z值表示到相机的距离。相机负责将World坐标系变换到View坐标系。</p><p>Display坐标系统跟View坐标系统类似，但是各坐标轴的取值不是[-1,1]，而是使用屏幕像素值。屏幕上显示的不同窗口的大小会影响View坐标系的坐标值[-1,1]到Display坐标系的映射。可以把不同的渲染场景放在同一个窗口进行显示，例如，在一个窗口里，分为左右两个渲染场景，这左右的渲染场景(vtkRenderer)就是不同的视口(Viewport)。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vtkSmartPointer&lt;vtkCylinderSource&gt; cyilnder1 = vtkSmartPointer&lt;vtkCylinderSource&gt;::<span class="hljs-built_in">New</span>();<br>vtkSmartPointer&lt;vtkCylinderSource&gt; cyilnder2 = vtkSmartPointer&lt;vtkCylinderSource&gt;::<span class="hljs-built_in">New</span>();<br><br>cyilnder1-&gt;<span class="hljs-built_in">SetHeight</span>(<span class="hljs-number">3</span>);<br>cyilnder1-&gt;<span class="hljs-built_in">SetRadius</span>(<span class="hljs-number">1</span>);<br>cyilnder1-&gt;<span class="hljs-built_in">SetResolution</span>(<span class="hljs-number">3</span>);<br><br>cyilnder2-&gt;<span class="hljs-built_in">SetHeight</span>(<span class="hljs-number">3</span>);<br>cyilnder2-&gt;<span class="hljs-built_in">SetRadius</span>(<span class="hljs-number">1</span>);<br>cyilnder2-&gt;<span class="hljs-built_in">SetResolution</span>(<span class="hljs-number">8</span>);<br><br>vtkSmartPointer&lt;vtkPolyDataMapper&gt; cyilderMapper1 = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::<span class="hljs-built_in">New</span>();<br>cyilderMapper1-&gt;<span class="hljs-built_in">SetInputConnection</span>(cyilnder1-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br>vtkSmartPointer&lt;vtkPolyDataMapper&gt; cyilderMapper2 = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::<span class="hljs-built_in">New</span>();<br>cyilderMapper2-&gt;<span class="hljs-built_in">SetInputConnection</span>(cyilnder2-&gt;<span class="hljs-built_in">GetOutputPort</span>());<br><br>vtkSmartPointer&lt;vtkActor&gt; cyilderActor1 = vtkSmartPointer&lt;vtkActor&gt;::<span class="hljs-built_in">New</span>();<br>cyilderActor1-&gt;<span class="hljs-built_in">SetMapper</span>(cyilderMapper1);<br>vtkSmartPointer&lt;vtkActor&gt; cyilderActor2 = vtkSmartPointer&lt;vtkActor&gt;::<span class="hljs-built_in">New</span>();<br>cyilderActor2-&gt;<span class="hljs-built_in">SetMapper</span>(cyilderMapper2);<br><br>vtkSmartPointer&lt;vtkRenderer&gt; renderer1 = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>renderer1-&gt;<span class="hljs-built_in">AddActor</span>(cyilderActor1);<br>renderer1-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>vtkSmartPointer&lt;vtkRenderer&gt; renderer2 = vtkSmartPointer&lt;vtkRenderer&gt;::<span class="hljs-built_in">New</span>();<br>renderer2-&gt;<span class="hljs-built_in">AddActor</span>(cyilderActor2);<br>renderer2-&gt;<span class="hljs-built_in">SetBackground</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>renderer1-&gt;<span class="hljs-built_in">SetViewport</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span>);<br>renderer1-&gt;<span class="hljs-built_in">SetViewport</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindow&gt; renWin = vtkSmartPointer&lt;vtkRenderWindow&gt;::<span class="hljs-built_in">New</span>();<br>renWin-&gt;<span class="hljs-built_in">AddRenderer</span>(renderer2);<br>renWin-&gt;<span class="hljs-built_in">AddRenderer</span>(renderer1);<br>renWin-&gt;<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br><br>vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; iren = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::<span class="hljs-built_in">New</span>();<br>iren-&gt;<span class="hljs-built_in">SetRenderWindow</span>(renWin);<br><br>vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt; style = vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt;::<span class="hljs-built_in">New</span>();<br>iren-&gt;<span class="hljs-built_in">SetInteractorStyle</span>(style);<br><br>iren-&gt;<span class="hljs-built_in">Initialize</span>();<br>iren-&gt;<span class="hljs-built_in">Start</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212011100314.png" style="zoom:80%;" /></p><hr /><p>我们在三维空间里定义的三维模型，最后显示的时候都是投影到二维平面，比如在屏幕上显示，生成二维图像等等。三维到二维的投影包括透视投影(PerspectiveProjection)和正交投影(OrthogonalProjection，正交投影也叫平行投影)。</p><p>不管是透视投影还是正交投影，变换的基本元素都是三维坐标点，在计算机图形学里，三维坐标点通常用齐次坐标来表示。例如，三维空间里有一个坐标点(x,y,z)，用齐次坐标表示为(<spanclass="math inline">\(x_{h}\)</span>,<spanclass="math inline">\(y_h\)</span>,<spanclass="math inline">\(z_h\)</span>,<spanclass="math inline">\(w_h\)</span>)，其中，<span class="math inline">\(x= \frac{x_h}{w_h}\)</span>、<span class="math inline">\(y =\frac{y_h}{w_h}\)</span>、<span class="math inline">\(z =\frac{z_h}{w_h}\)</span></p><p>如果 <span class="math inline">\(w_h\)</span> =0，则表示无穷远的点。</p><p>利用齐次坐标，可以将空间变换用4×4的矩阵来表示。例如，平移、旋转、缩放等仿射变换都可以用矩阵相乘的形式表示</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212011113268.png" style="zoom:40%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212011113532.png" style="zoom:38%;" /></p><p>VTK里与空间变换相关的类有：vtkTransform2D，vtkTransform，vtkPerspectiveTransform，vtkGeneralTransform，vtkTransformFilter，vtkMatrix4x4等。</p><hr /><h4 id="总结">总结🪅</h4><p>首先我们从vtkCylinderSource学会了一组VTK类：vtkXXXSource。这一组类派生自vtkPolyDataAlgorithm，它们输出的数据类型都是vtkPolyData，都些类都是VTK预定义好的图形模型。</p><p>接着，我们把vtkXXXSource的输出作为vtkPolyDataMapper的输入，Mapper的作用是将输入的数据转换为几何图元(点、线、多边形)进行渲染。</p><p>然后，我们实例化一个Actor对象，因为我们知道，VTK渲染场景中数据的可视化表达是通过vtkProp的子类负责的。通过Actor的方法SetMapper()可以设置对应的Mapper。</p><p>紧接着，我们又实例化了渲染窗口、渲染器、交互器、交互类型等对象，并逐个地加以介绍。于是我们明白了渲染窗口就是我们看到的那个VTK窗口；渲染器Renderer可以通过渲染窗口的方法AddRenderer()加入的渲染窗口里；交互器则是用方法SetRenderWindow()给它指定交互的窗口；交互风格与交互器是用方法SetInteractorStyle()关联在一起；若干个Actor对象可以用方法AddActor()加入到渲染器里渲染。</p><p>然后我们又看了渲染场景里光照和相机等对象，明白了渲染场景里可以有多个光照，但只能有一个相机；以及了解了设置光照和相机的方法。</p><p>介绍vtkActor时，我们通过vtkProperty对象来改变Actor的颜色，于是我们顺便介绍了VTK所用到的颜色模型，分别是RGB颜色模型和HSV颜色模型。</p><p>最后我们又讲了似乎跟前面的内容并不搭边的“坐标系统及空间变换”，明白VTK里用到Model、World、View和Display等坐标系统，它们之间可以变换通过类vtkCoordinate来实现。然后介绍了VTK里使用齐次坐标做空间变换的概念，列出了平移、缩放和旋转等变换矩阵。其实这部分内容跟前面介绍的是息息相关的，比如，渲染场景里的Actor通过相机投影到像平面时，就用到了这些内容。vtkRenderer里的方法ViewToWorld()和WorldToView()等，里面也会用到空间变换。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/img/202212011116458.png" style="zoom: 80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VTK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件架构与中间件（四）</title>
    <link href="/post/352464c7.html"/>
    <url>/post/352464c7.html</url>
    
    <content type="html"><![CDATA[<p>对软件架构与中间件课程的主要内容进行总结</p><span id="more"></span><h1 id="软件架构与中间件四">软件架构与中间件（四）</h1><h2 id="第五章-表示层的软件架构技术">第五章 表示层的软件架构技术🧟‍♀️</h2><h3 id="表示层的设计基础">表示层的设计基础🧸</h3><p>表示层设计的基本目的就是要合理布局和设计版面，高效地传递视觉信息，充分吸引用户。</p><h4 id="表示层设计与视觉习惯">表示层设计与视觉习惯👾</h4><p>规律1：人眼的视线沿着水平方向运动比沿着垂直方向运动快而且不易疲劳</p><p>规律2：视线的变化习惯于从左到右，从上到下和顺时针方向运动</p><p>规律3：当视线沿着既不水平也不垂直的斜线方向移动时，在水平方向上下约45°的范围内，视线从左到右移动；在垂直方向左右约45°范围内，视线从上到下移动</p><p>视觉习惯：滚动图片最好从右向左，线状布局应水平方向宽些，导航栏最好放在左侧或上部，要重点突出的内容最好放在左上部。</p><p>版式规范：</p><ol type="1"><li>固定页宽，一般不限定长度，但不宜过长，一般应控制在1-3屏，最多不要超过5屏，多屏信息可以通过超链接的方法解决</li><li>对于文字，以下情况会产生疲劳：(1) 字号过小、行间距过密，不易辨认 (2)高亮度文字、背景极暗</li><li>挥之不去的跟踪动效，会令人生厌</li></ol><h4 id="表示层的主从关系">表示层的主从关系🤖</h4><p>页面中的构成元素不能同等对待，必须以点带面，让焦点先抓住浏览者，引发继续浏览的愿望，然后再扩展开来。</p><p>强化页面的主从关系就是将主要对象与次要对象区分开来，重点突出。采取的方式有：</p><ol type="1"><li>主从对象的大小对比</li><li>弱化主体对象周围的内容</li><li>主从对象的色彩对比</li><li>重复主题对象</li><li>加强主从对象在形态上的对比</li></ol><h4 id="视觉流程的设计">视觉流程的设计👹</h4><p>视觉流程：视线随页面各构成元素在空间上沿一定轨迹运动的过程。浏览者的视觉流程是有一定规律的。</p><ul><li><p>单向视觉流程</p><p>视线在页面中随构成要素形成的单一方向顺序运动。</p><p>规律：由大到小；有主到次； 由左到右；由上到下。</p><p>分类： 横向视觉流程；纵向视觉流程；斜向视觉流程</p></li><li><p>曲线视觉流程</p><p>曲线视觉流程是各构成要素沿着曲线而运动变化的视线流动过程，它比单向视觉流程更具节奏、韵律和曲线美。</p></li><li><p>导向视觉流程</p><p>导向视觉流程是通过诱导元素，主动引导浏览者的视线按照一定的方向顺序运动，将页面各构成元素依序串连起来，形成一个有机的整体</p><p>依据诱导元素的不同可分为： 线形导向、形象导向、指示导向</p></li><li><p>重心视觉流程</p><p>重心指页面的视觉心理重心并不是几何中心</p></li><li><p>反复视觉流程</p><p>视线沿着页面中相同或相似的视觉要素作规律性的、富于秩序和节奏的逐次运动</p></li><li><p>散点视觉流程</p><p>没有固定的视线流动路线，页面中各构成要素呈现自由分散的状态，体现自由性、随意性。但并非杂乱无章，有着一定的结构性和统一性</p></li></ul><h3 id="前端开发技术和相关架构">前端开发技术和相关架构🪅</h3><h4id="面向异步内容加载的前端架构技术">面向异步内容加载的前端架构技术</h4><p>页面加载存在很多问题：带宽限制，需要加载内容多。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612203947405.png" /></p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612204019118.png" /></p><p>AJAX（Asynchronous JavaScript andXML的缩写）是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，AJAX通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。</p><p>AJAX目的：提高用户体验，较少网络数据的传输量。</p><p>AJAX核心：浏览器提供的XMLHttpRequest（XHR）对象，它扮演的角色相当于秘书，使得浏览器可以发出HTTP请求与接收HTTP响应。XMLHttpRequest对象提供了对 HTTP 协议的完全的访问，包括做出POST 和 HEAD 请求以及普通的GET 请求的能力。XMLHttpRequest 可以同步或异步地返回 Web服务器的响应，并且能够以文本或者一个DOM 文档的形式返回内容。尽管名为XMLHttpRequest ，它并不限于和 XML文档一起使用：它可以接收任何形式的文本文档。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612204522603.png" /></p><h4 id="面向自适应的前端架构技术">面向自适应的前端架构技术</h4><p>多屏适配会出现很多问题。</p><p>Bootstrap 是一个用于快速开发 Web 应用程序和网站的前端框架。</p><p>Bootstrap 优点：</p><ul><li>移动设备优先。框架包含了贯穿于整个库的移动设备优先的样式。</li><li>浏览器支持。所有的主流浏览器都支持。</li><li>容易上手。只要你具备HTML、CSS、JS基础知识，就可以开始学习。</li><li>响应式设计。Bootstrap 的响应式 CSS能够自适应于台式机、平板电脑和手机。</li></ul><p>Bootstrap模板注意事项</p><ul><li>Bootstrap模板必须是基于HTML5文件的。因此DTD类型定义必须是HTML5的。</li><li>Bootstrap文件当字符集设置，也要遵循HTML5的规范。</li><li>设置IE浏览器兼容模式(X-UA-Compatible)。</li><li>设置模板，适用于所有平台。</li><li>引入bootstrap的CSS主文件(bootstrap.min.css)。</li><li>引入jQuery插件的主文件(jQuery)。</li><li>引入bootstrap的JS主文件(bootstrap.min.js)</li></ul><h3 id="前端组件化">前端组件化🎲</h3><p>组件：导航、按钮、表单、Tab、翻页、表格、进度条...</p><p>一个组件就是一个完整的产品，把每个组件当做一个独立产品来设计考虑空状态、极端情况、尺寸变化尽可能灵活适应各使用场景，统一组件与组件、组件与散件之间的组合方式，之前所有的内容，最终汇集成设计规范。</p><p>轻度组件化：同一个组件使用相同的html结构和class名，用同一段css代码定义样式，用同一个js函数定义交互。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612205504665.png" /></p><p>重度组件化：每个组件的html结构、css样式、js交互都独立封装管理，定义好框架和加载方式，内容在加载时从外部填充。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612205517560.png" /></p><p>用这种思路管理项目，也会改变开发的协作方式。大家不再是按页面分工，而是按组件来分工。页头和tab由一人负责，列表和页脚由另一个人负责，弱化了相互间的依赖关系。直到将组件拼装成页面，才需要处理组件之间相互作用的部分，但这时候工作量已经被大大消化了。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612205552976.png" /></p><p>组件化不是一件轻松的工作，在项目初期的准备工作会增加一定工作量，但随时间推移会发挥出巨大的优势。</p><h2 id="第六章-软件架构评审与测试">第六章 软件架构评审与测试📱</h2><h3 id="软件架构评审方法">软件架构评审方法🚛</h3><p>评审：以某种系统化的方法对事物进行评价，以发现其优点和缺点，并判断其是否满足期望的要求。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612210824503.png" /></p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612210543960.png" /></p><p>（SA：系统分析）</p><p>常用架构评审方式：</p><ul><li><p>基于调查问卷的评审方式</p><p>调查问卷： 一系列有关SA评审的相关问题。</p><p>评估过程：多个评估专家考察系统，然后回答问卷中的问题；对多个评估结果进行综合，得到最终的结果。优点：自由、灵活，可评估多种质量属性，也可在SA设计的多个阶段进行。缺点：由于评估的结果很大程度上来自评估人员的主观推断，因此不同的评估人员可能会产生不同甚至截然相反的结果；评估人员对领域的熟悉程度、是否具有丰富的相关经验也成为评估结果是否正确的重要因素。</p></li><li><p>基于场景的评审方式</p><p>分析SA对场景的支持程度，从而判断该SA对这一场景所代表的质量需求的满足程度。场景：系统应用的典型场合。</p><p>基于场景的方式由 SEI 首先提出：体系结构权衡分析方法( ATAM)、软件体系结构分析方法( SAAM )</p></li><li><p>基于度量的评审方式</p><p>在度量时，可采用自动化的工具，对质量属性进行计算，得到结果。</p><p><span class="math inline">\(Coupling(MS) = \sum_{i=1}^{n} I(S_i) -I(S)\)</span></p><p>三个基本活动：从软件体系结构文档中获取度量信息并计算得到结果；建立质量属性和度量结果之间的映射原则，即确定怎样从度量结果推出系统具有什么样的质量属性；根据映射原则分析推导出系统的某些质量属性。</p><p>优点：结果比较客观、精确。</p><p>缺点：很多质量属性无法给出具体的计算公式；能给出计算公式的质量属性，往往是针对源代码级别的质量属性(如代码行数、方法调用的次数、构件个数等)，而这些属性对SA的评价往往缺乏足够的意义；需要在SA设计基本完成以后才能进行；需要评估人员对待评估的体系结构十分了解。</p></li></ul><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612211514989.png" /></p><p>ATAM（体系结构权衡分析方法）：按照质量需求，评价体系结构设计</p><p>ATAM是一种基于场景的SA评估方法。</p><p>ATAM目标：发现风险：可能在未来产生质量问题的方案、发现非风险：可以提高质量的决策、发现关键点：方案中一个小小的变化，就可能让质量完全大变样、发现折中：影响一个以上质量的决策。</p><p>ATAM输入：场景，需要关注的质量属性及对其的提问、待评价的SA的设计方案</p><p>ATAM中间结果：效用树</p><p>ATAM输出：风险、非风险、关键点、折中点。</p><p>输入1：场景</p><p>场景是一种简短的陈述，用来描述系统的相关人员之间使用该软件系统的一个交互场合。</p><p>场景类型：</p><ul><li><p>用例场景</p><p>软件系统的常规应用场合</p><p>例子：远程用户通过Web请求数据报表，高峰时刻可以在5秒之内得到结果，如果缓存系统处理失败，那么将在1秒之内被切换到另一个处理器，图形从水平布局切换到垂直布局，重画要在1秒之内完成</p></li><li><p>变化性场景</p><p>软件系统可预料到的变化</p><p>使用少于1人周的工作量即可在系统中加入一种新的消息类型，使用少于1人年的工作量即可将系统迁移到其他OS，可以将数据表的尺寸增加一倍，但其平均存取时间却仍然维持1秒</p></li><li><p>探测性场景</p><p>极端的变化，对系统进行压力测试</p><p>即使50%的服务器停止工作也不会影响整个系统的可用性，将系统的可用性从98%提高到99.999%，每小时交易数据成10倍量的增加，但保持最差的响应时间在10秒之内</p></li></ul><p>输入2：对质量属性的提问</p><p>质询体系结构在特定的质量需求上如何作为，通过“头脑风暴”，尽可能汇总与质量属性相关的各类问题。</p><p>中间结果：效用树</p><p>效用树：提供了一种自顶向下的机制来将系统的业务驱动要素翻译为具体的质量属性及其场景</p><p>目的：对场景的优先级进行排序</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612212800914.png" /></p><p>输出1：风险与非风险</p><p>风险：SA设计中存在潜在问题的决策</p><p>例子：</p><ul><li>SA决策：在三层C/S样式中，第二层业务逻辑的模块划分规则没有明确的给出；</li><li>可能造成的后果和影响：这会导致功能的混乱，并可能导致第三层的可修改性较差；</li><li>判断的依据：如果不将业务逻辑模块划分规则清楚的表述出来，就可能会间接导致构件之间的耦合度增大。</li></ul><p>非风险：在一个可信的假设之下被认为是“好”的决策</p><p>例子：</p><ul><li>SA假设：消息的到达速率为1条/秒，消息处理时间&lt;30 ms，并存在一个较高优先级的消息处理进程；</li><li>可能造成的影响：“消息的最长响应时间最长1秒钟”是可行的；</li><li>判断的依据：消息的到达速率是限定的，高优先级处理进程的“抢占”效果是可知的。</li></ul><p>风险和非风险需要描述的要素：已做出或未做出的SA设计决策，该决策对质量属性的造成的后果和影响，造成该影响的论据。</p><p>输出2：关键点</p><p>关键点：SA中对实现特定的质量属性起到关键作用的构件或构件间连接关系。如：加密位的多少将对网络的机密性等级起到关键作用；通讯协议和文件格式的封装程度将决定着系统维护所需的工作量的大小；把定时方法从一个精确的框架移植到一个不精确的框架，会极大地影响其他模块的正常工作。</p><p>输出3：折中点</p><p>折中点：影响到多个质量属性，是多个质量属性的关键点，而且是矛盾的。如：改变加密级别会影响到安全性和性能；提高加密级别会改善安全性，但需要更多的处理时间(性能下降)；而消息的处理时间不能超过某一范围因此，“加密级别”就是一个折中点。</p><h3 id="软件架构测试方法">软件架构测试方法💨</h3><p>性能测试目的：在正常、峰值以及异常负载条件下，测试系统的各项性能指标，通过自动化的测试工具模拟进行，验证软件系统是否能够达到用户提出的性能指标，同时发现软件系统中存在的性能瓶颈，优化软件，最后起到优化系统的目的。</p><p>负载测试：不限制软件的运行资源，测试软件的数据吞吐量上限，以发现设计上的错误或验证系统的负载能力，将使测试对象承担不同的工作量，以评测和评估测试对象在不同工作量条件下的性能行为，以及持续正常运行的能力，在测试过程中，逐渐增加系统负担，直到出现系统不能接受的性能点-系统崩溃。</p><p>负载测试目的：发现系统的负载极限</p><p>压力测试：模拟实际应用的软硬件环境及用户使用过程的系统负荷，长时间或超大负荷地运行测试软件，来测试被测系统的性能、可靠性、稳定性等。在不同的强负载下测试系统的运行状况。</p><p>压力测试 VS 负载测试：</p><ul><li>实现方法基本相同</li><li>测试的目的不同：负载测试是通过改变系统负载方式、增加负载等来发现系统中所存在的性能问题。负载测试是一种测试方法，可以为性能测试、压力测试所采用。</li><li>压力测试通常是在高负载情况下来对系统的稳定性进行测试，更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等。</li></ul><p>容量测试：确定测试对象在给定时间内能够持续处理的最大负载或工作量</p><p>容量测试作用：让软件开发商或用户了解该软件系统的承载能力或提供服务的能力，知道了系统的实际容量，如是不能满足设计要求，就应该寻求新的技术解决方案，以提高系统的容量。有了对软件负载的准确预测，不仅能对软件系统在实际使用中的性能状况充满信心，同时也可以帮助用户经济地规划应用系统，优化系统的部署。</p><p>网路性能测试：测试网络带宽、延迟、负载和端口的变化对用户的响应时间的影响</p><p>网路性能测试实际应用：测试用户数目与网络带宽的关系</p><p>网路性能测试作用：监测网络环境、预测</p><p>性能测试步骤：</p><ul><li>制定目标和分析系统选择测试度量的方法</li><li>选择相关技术和工具</li><li>制定评估标准</li><li>设计测试用例</li><li>运行测试用例</li><li>分析测试结果</li></ul><p>性能测试指标：响应时间、内存、磁盘、处理器、网络</p><p>压力测试</p><p>压力：在同一时间内或某一时间内，向系统发送预期数量的交易请求。并发交易请求、递增交易请求、并发递增交易请求</p><p>压力测试：测试系统在不同压力情况下的效率状况，以及系统可以承受的压力情况</p><p>压力测试目的：发现影响系统性能的瓶颈，评价系统性能，对系统资源进行优化，提高响应时间与吞吐量</p><p>压力测试流程图：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612214438039.png" /></p><p>压力测试计划：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612214516154.png" /></p><p>压力测试用例：明确测试目的、准备测试环境、确定测试数据、确定测试运行程序（脚本等）、明确预期结果</p><p>模拟多用户：方法：通过多进程运行相同或不同的测试脚本来模拟多用户执行相同或不同的任务，通过发包程序发送数据包。测试数据参数化：找到需要参数化的域，合理的设置输入数据</p><p>设置并发点：原因：被测事务不能同时运行。实现原理：等待、释放、唤醒</p><p>执行测试用例：运行测试脚本，根据情况，调整并发的进程数，结果自动记录</p><p>监测系统资源：监测的对象：网络阻塞情况、主机CPU使用情况、内存使用情况、缓存使用情况、数据库系统的数据锁。</p><p>分析结果</p><ul><li>分析对象：测试使用的时间、被测事务的响应时间（并发）、进程数（成功数、失败数）、进程失败原因、事务响应时间随用户增加的变化图、资源限制<br /></li><li>分析内容：测试是否成功（失败原因）、响应时间是否满足要求、事务响应时间随用户变化图有无剧烈变化</li></ul><p>优化调整设置：CPU问题、内存与高速缓存问题、磁盘（I/O）资源问题、调整配置参数、优化应用系统网络设置</p><p>测试报告：结果数据、图形说明</p><p>压力测试工具：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612215346504.png" /></p><p>系统调优：硬件平台：服务器CPU、内存及硬盘等；网络平台：负载、延迟、传输故障等；软件平台：数据库、中间件等；应用级别：线程级别、会话级别、代码级别。</p>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件架构与中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件架构与中间件（三）</title>
    <link href="/post/82097da2.html"/>
    <url>/post/82097da2.html</url>
    
    <content type="html"><![CDATA[<p>对软件架构与中间件课程的主要内容进行总结</p><span id="more"></span><h1 id="软件架构与中间件三">软件架构与中间件（三）</h1><h2 id="第四章-数据层的软件架构技术">第四章 数据层的软件架构技术⛄</h2><h3 id="数据驱动的软件架构演化">数据驱动的软件架构演化❄️</h3><h4 id="数据与软件">数据与软件🗾</h4><p>一般而言，数据是指对客观事件进行记录并可以鉴别的符号，是对客观事物的性质、状态以及相互关系等进行记载的物理符号或这些物理符号的组合。它是可识别的、抽象的符号。表示形态上，数据可以是狭义上的数字，可以是具有一定意义的文字、字母、数字符号的组合、图形、图像、视频、音频等，也可以是客观事物的属性、数量、位置及其相互关系的抽象表示。在计算机科学中，数据是指所有能输入到计算机并被计算机程序处理的符号的介质的总称，是用于输入电子计算机进行处理，具有一定意义的数字、字母、符号和模拟量等的通称。</p><p>数据与信息：信息与数据既有联系，又有区别。数据是信息的表达、载体，信息是数据的内涵，是形与质的关系。数据本身没有意义，数据只有对实体行为产生影响时才成为信息。</p><p>数据与语义：数据的表现形式还不能完全表达其内容，需要经过解释，数据和关于数据的解释是不可分的。数据的解释是指对数据含义的说明，数据的含义称为数据的语义，数据与其语义是不可分的。</p><p>数据+语义+逻辑=业务</p><p>代码+业务=软件应用系统</p><h4 id="数据带来的架构变化">数据带来的架构变化🐡</h4><p>数据架构演化：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612222205936.png" /></p><p>单机MYSQL：数据量过大，单机存储不下、数据量过大，单机内存存不下数据索引、访问量过大，在读写混合的情况下，一个实例不能承受</p><p>Memcached + MySQL +垂直分离：Memcached(缓存)蕴意而生，管理缓存。缓存原则：频繁被访问的数据可以被放置于缓存当中，以供频繁访问。垂直分离指按业务划分将不同的数据放在不同的数据库里。</p><p>MySQL主从读写分离：主从复制：容灾备份，缓存备份，保证数据的完整性。读写分离：增删改是写，查为读。</p><p>分库分表 + 水平拆分 + MySQL集群</p><p>NoSQL（Not Only SQL）：高性能 - 对数据库高并发读写的需求、海量存储 -对海量数据的高效率存储和访问的需求、高伸缩性与高可用性 -对数据库的高可扩展性和高可用性的需求。</p><h3 id="数据读写与主从分离">数据读写与主从分离🌬️</h3><h4 id="读写分离">读写分离🦑</h4><p>基本原理：将数据库读写操作分散到不同的节点上，数据库服务器搭建主从集群，一主一从、一主多从都可以。数据库主机负责读写操作，从机只负责读操作。数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612234055701.png" /></p><p>主从复制延迟问题：如果业务服务器将数据写入到数据库主服务器后立刻进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。</p><p>应对复制延迟的方案：</p><ul><li>写操作后的读操作指定发给数据库主服务器</li><li>读从机失败后再读一次主机</li><li>关键业务读写操作全部指向主机，非关键业务采用读写分离</li></ul><p>分配机制：</p><ul><li><p>程序代码封装</p><p>对业务服务器进行代码封装</p></li><li><p>中间件封装</p><p>在业务服务器和主/从机直接增加中间件</p></li></ul><h4 id="主备与主从复制">主备与主从复制🐙</h4><p>主备复制基本实现逻辑：</p><ol type="1"><li>主机存储数据，通过复制通道将数据复制到备机。</li><li>正常情况下，客户端无论读写操作，都发送给主机，备机不对外提供任何读写服务。</li><li>主机故障情况下，客户端不会自动将请求发给备机，此时整个系统处于不可用状态，不能读写数据，但数据并没有全部丢失，因为备机上有数据。</li><li>如果主机能够恢复（人工或自动），客户端继续访问主机，主机继续将数据复制给备机。</li><li>如果主机不能恢复，则需要人工升级备机为主机，增加新备机，切换访问链路。<br /></li><li>主机不能恢复的情况下，成功写入主机但还没有复制到备机的数据会丢失，需要人工进行排查和恢复，也许有的数据就永远丢失了，业务上需要考虑如何应对此类风险。</li><li>如果主备间数据复制延迟，由于备机并不对外提供读写操作，因此对业务没有影响，但如果延迟较多，恰好此时主机又宕机了，则可能丢失较多数据，因此对于复制延迟也不能掉以轻心。一般的做法是做复制延迟的监控措施，当延迟数据量较大时及时预警，由人工干预处理。</li></ol><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612234938129.png" /></p><p>在此类方案中，备机只起到备份作用。</p><p>优点：对于客户端来说，不需要感知备机的存在，即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了，无需知道是原来的备机升级为主机了。对于主机和备机来说，双方只需要进行数据复制即可，无须进行状态判断和主备倒换等复杂操作。</p><p>缺点：备机仅是备份，不提供读写操作，硬件浪费。故障后需人工干预，无法自动恢复。</p><p>主从复制基本实现逻辑：</p><ol type="1"><li>主机存储数据，通过复制通道将数据复制到从机。</li><li>正常情况下，客户端写操作发送给主机，读操作可发送给主机也可以发送给从机(可以随机读，轮询读，只读主机)。</li><li>主机故障情况下，客户端无法进行写操作，但可以将读操作发送给从机，从机继续响应读操作，此时和写操作相关的业务不可用，但是读操作相关的不受影响。</li><li>如果主机能够恢复（人工或自动），客户端继续将写操作请求发送给主机，主机继续将数据复制给从机。</li><li>如果主机不能恢复，则需要人工升级从机为主机，然后让客户端访问新主机，同时，为了继续保持主从结构，人工增加新机器作为从机。<br /></li><li>主机不能恢复的情况下，成功写入了主机但是还没有复制到从机的数据会丢失，需要人工进行排查和恢复，也许有的数据就永远丢失了，业务上需要考虑如何应对此类风险。</li><li>如果主从间数据复制延迟，则会出现主从读取数据不一致问题。</li><li>如果主从间延迟较多，恰好此时主机又宕机了，则可能丢失较多数据，因此对于复制延迟也不能掉以轻心。一般的做法是做复制延迟的监控措施，当延迟数据量较大时及时预警，由人工干预处理。</li></ol><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612235625718.png" /></p><p>优缺点（相对主备复制而言）：主从复制在主机故障时，读操作相关的业务不受影响。主从复制架构的从机提供读操作，发挥了硬件的性能。主从复制要比主备复制复杂，主要体现在客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理。</p><h4 id="主备倒换与主从倒换">主备倒换与主从倒换🦞</h4><p>主备和主从复制的共性问题：主机故障后，无法进行写操作。如果主机无法恢复，需要人工指定新的主机。</p><p>改进关键点：主备间状态判断、倒换决策、数据冲突。</p><p>常见架构：</p><ul><li><p>互连式</p><p>主备机直接建立状态传递的渠道，为了充分利用主备自动倒换方案自动决定主机的优势，方案有：主备机共享一个对于客户端来说唯一的地址（如，虚拟IP）。客户端记录主备机各自的IP，备机具有拒绝服务的能力。</p><p>缺点：状态传递通道本身故障了，则备机会主动升级为主机；虽然可以通过多通道来降低通道故障的机率，但是通道越多，后续的状态决策越复杂，特别是容易收到多种矛盾的信息。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613001039854.png" /></p></li><li><p>中介式</p><p>在主备机之间引入第三方中介，主备机之间不直接连接，而都去连接中介，并且通过中介来传递状态信息。结构复杂了，但是从状态传递和决策上更加简单。</p><p>状态决策的步骤：</p><ol type="1"><li>无论主机还是备机，初始状态都是备机，并且只要与中介断开连接，就将自己降级为备机，因此可能出现双备机的情况。</li><li>主机与中介断连后，中介能够立刻告知备机，备机将主机升级为主机。</li><li>如果是网络中断导致主机与中介断连，主机自己会降级为备机，网络恢复后，旧的主机以新的备机身份向中介上报自己的状态。</li><li>如果是掉电重启或者进程重启，旧的主机初始状态为备机，与中介恢复连接后，发现已经有主机了，保持自己备机状态不变。</li><li>主备机与中介连接都正常的情况下，按照实际的状态决定是否进行倒换，如，响应超时。</li></ol><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613001344785.png" /></p></li><li><p>模拟式</p><p>主备机之间并不传递任何状态数据，而是备机模拟成为一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态。</p><p>模拟式相比互连式的优缺点：实现更加简单。模拟式读写操作获取状态信息只有响应信息（如，HTTP404，超时，响应时间超过3 s等），没有互连式那么多样，基于有限的状态来做状态决策，可能出现偏差。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613001642145.png" /></p></li></ul><h4 id="主主复制">主主复制🦉</h4><p>主主复制：两台机器都是主机，互相将数据复制给对方，客户端可以任意挑选其中一台进行读写操作。</p><ol type="1"><li>两台主机都存储数据，通过复制通道将数据复制到另一台主机。</li><li>正常情况下，客户端可以将读写操作发送给任意一台主机。</li><li>一台主机故障情况下，客户端只需要将读写操作发送给主机B即可，反之亦然。</li><li>如果故障主机能够恢复，则客户端继续访问两台主机，两台主机继续相互复制对方数据。</li><li>如果故障主机不能恢复，则需要人工操作，增加一台新的机器为主机。</li><li>原有故障主机不能恢复的情况下，成功写入原有故障主机但没有复制到正常主机的数据会丢失。</li><li>如果两台主机间复制延迟，则可能出现客户端刚写入的数据，在另一台主机上读取不到。</li></ol><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613001859335.png" /></p><p>优缺点：两台主机，无倒换概念。客户端无须区分主备机身份。必须保证数据能够双向复制，然而很多数据无法双向复制，如两个库新插入数据的ID均为100，或者两人对某产品（100件）进行购买，甲从A买了1件，乙从B买了2件，如果复制Bto A，则两个数据库都是98。实际应该是97。</p><h4 id="数据集群">数据集群🪆</h4><p>数据库集中集群：一主多备/从。数据都只能往主机写，而读操作可以参考主备，主从的架构进行灵活变化。复杂度高。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613002318599.png" /></p><p>数据分散集群：多个服务器组成一个集群，每台服务器都会负责存储一部分数据，同时，为了提升硬件利用率，每台服务器又会备份一部分数据。数据分散集群的复杂度在于如何将数据分配到不同的服务器上。数据分散集群中，必须要有一个角色来负责执行数据分配算法，可以是独立服务器，如HDFS架构，也可以是集群选举出的服务器，也称之为“主机”，但职责完全不同，如Elasticsearch。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613002526499.png" /></p><p>集中 VS 分散：</p><ul><li><p>写数据角色</p><p>数据集中集群架构中，客户端只能将数据写到主机。数据分散集群架构中，客户端可以向任意服务器中读写数据。</p></li><li><p>应用场景</p><p>数据集中集群适合数据量不大，集群机器数量不多的场景，如 ZooKeeper集群，一般个位数机器。数据分散集群，由于其良好的可伸缩性，适合业务数据量巨大、集群机器数量庞大的业务场景，如Hadoop 集群，可达上千台服务器。</p></li></ul><h3 id="数据分库分表">数据分库分表🌞</h3><h4 id="分库分表的基本概念">分库分表的基本概念🀄</h4><p>分库分表的本质是数据拆分，是对数据进行分而治之的通用概念。为了分散数据库的压力，采用分库分表将一个表结构分为多个表，或者将一个表的数据分片后放入多个表，这些表可以放在同一个库里，也可以放到不同的库里，甚至可以放在不同的数据库实例上。</p><p>垂直拆分：根据业务的维度，将原本的一个库（表）拆分为多个库（表），每个库（表）与原有的结构不同。</p><p>水平拆分：根据分片算法，将一个库（表）拆分为多个库（表），每个库（表）依旧保留原有的结构。</p><p>单库单表 → 单库多表 → 多库多表</p><p>分库分表的时机：如果在数据库中表的数量达到了一定量级，则需要进行分表，分解单表的大数据量对索引查询带来的压力，并方便对索引和表结构的变更。如果数据库的吞吐量达到了瓶颈，就需要增加数据库实例，利用多个数据库实例来分解大量的数据库请求带来的系统压力。如果希望在扩容时对应用层的配置改变最少，就需要在每个数据库实例中预留足够的数据库数量。</p><h4 id="分库分表的解决方案">分库分表的解决方案🃏</h4><h5 id="客户端分片">客户端分片⛺</h5><p>客户端分片就是使用分库分表的数据库的应用层直接操作分片逻辑，分片规则需要在同一个应用的多个节点间进行同步，每个应用层都嵌入一个操作切片的逻辑实现，一般通过依赖Jar 包来实现。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613003827491.png" /></p><p>具体实现方式分为三种：</p><ul><li><p>在应用层直接实现</p><p>直接在应用层读取分片规则，然后解析分片规则，据此实现切分的路由逻辑，从应用层直接决定每次操作应该使用哪个数据库实例、库、表等。</p><p>需要侵入业务，但实现简单，适合快速上线，切分逻辑由开发者自行定义，容易调试维护。但求开发者既要实现业务逻辑，还需要实现框架需求。该实现方式会让数据库保持的连接比较多，对整体应用服务器池的维护将造成压力。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613004119130.png" /></p></li><li><p>通过定制 JDBC 协议实现</p><p>可让开发者集中精力实现业务逻辑，无须关心分库分表的实现。</p><p>通过定制JDBC协议来实现，也就是针对业务逻辑层提供与JDBC一致的接口，分库分表在JDBC的内部实现。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613004228218.png" /></p></li><li><p>通过定制 ORM 框架实现</p><p>分片规则实现到ORM框架中或者通过ORM框架支持的扩展机制来完成分库分表的逻辑。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613004332626.png" /></p></li></ul><h5 id="代理分片">代理分片🌁</h5><p>代理分片就是在应用层和数据库层之间增加一个代理层，把分片的路由规则配置在代理层，代理层对外提供与JDBC兼容的接口给应用层。</p><p>应用层的开发人员不用关心分片规则，只需关心业务逻辑的实现，待业务逻辑实现之后，在代理层配置路由规则即可。</p><p>代理层的引入增加了一层网络传输，对性能会造成影响。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613004511675.png" /></p><h5 id="支持事务的分布式数据库">支持事务的分布式数据库🔥</h5><p>现在有很多产品如OceanBase、TiDB等对外提供可伸缩的体系架构，并提供一定的分布式事务支持，将可伸缩的特点和分布式事务的实现包装到分布式数据库内部，对使用者透明，使用者不需要直接控制这些特性。</p><p>TiDB对外提供JDBC的接口，让应用层像使用MySQL等传统数据库一样，无需关注伸缩、分片、事务管理等任务。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613004603611.png" /></p><h4 id="分库分表的架构设计">分库分表的架构设计📻</h4><p>垂直切分是指按照业务将表进行分类或分拆，将其分布到不同数据库上。不同业务模块的数据可以分散到不同数据库服务器。也可以冷热分离，根据数据的活跃度将数据进行拆分。冷数据：变化更新频率低，查询次数多的数据。热数据：变化更新频率高，活跃的数据。也可以人为将一个表中的内容划分为多个表，例如将查询较多，变化不多的字段拆分成一张表放在查询性能高的服务器，而将频繁更新的字段拆分并部署到更新性能高的服务器。</p><p>例子：在微博系统的设计中，一个微博对象包括文章标题、作者、分类、创建时间等属性字段，这些字段属于变化频率低的冷数据，而每篇微博的浏览数、回复数、点赞数等类似的统计信息属于变化频率高的热数据。因此，一篇博客的数据可以按照冷热差异，拆分成两张表。冷数据存放的数据库可以使用MyISAM引擎，能更好地进行数据查询；热数据存放的数据库可以使用InnoDB存储引擎，更新性能好。读多写少的冷数据库可以部署到缓存数据库上。</p><p>优点：拆分后业务清晰，拆分规则明确，系统之间进行整合或扩展很容易，按照成本、应用的等级或类型等将表放到不同的机器上，便于管理，便于实现动静分离、冷热分离的数据库表的设计模式，数据维护简单</p><p>缺点：部分业务表无法关联（Join），只能通过接口方式解决，提高了系统的复杂度，受每种业务的不同限制，存在单库性能瓶颈，不易进行数据扩展和提升性能，事务处理复杂。</p><p>水平切分不是将表进行分类，而是将其按照某个字段的某种规则分散到多个库中，在每个表中包含一部分数据，所有表加起来是全量数据。简言之，将数据按一定规律，按行切分，并分配到不同的库表里，表结构完全一样。</p><p>例：在博客系统中，当同时有100万个用户在浏览时，如果是单表，则单表会进行100万次请求；假如将其分为100个表，并且分布在10个数据库中，每个表进行1万次请求，则每个数据库会承受10万次请求。当然还可以分配到不同服务器的服务实例中，分的表越多，每个单表的压力越小。</p><p>优点：单库单表的数据保持在一定的量级，有助于性能的提高。切分的表的结构相同，应用层改造较少，只需要增加路由规则即可。提高了系统的稳定性和负载能力</p><p>缺点：切分后，数据是分散的，很难利用数据库的Join操作，跨库Join性能差。拆分规则难以抽象。分片事务的一致性难以解决。数据扩容的难度和维护量极大</p><p>垂直，水平切分共同点：存在分布式事务的问题；存在跨节点Join的问题；存在跨节点合并排序、分页的问题；存在多数据源管理的问题；垂直切分更偏向于业务拆分的过程，水平切分更偏向于技术性能指标。</p><p>水平切分的路由过程：分库分表后，数据将分布到不同的分片表中，通过分库分表规则查找到对应的表和库的过程叫做路由。设计表时需要确定对表按照什么样的规则进行分库分表。例如，当生成新用户时，程序得确定将此用户的信息添加到哪个表中。同样，在登录时我们需要通过用户的账号找到数据库中对应的记录。</p><p>水平切分的分片维度：</p><ul><li><p>按哈希切片</p><p>对数据的某个字段求哈希，再除以分片总数后取模，取模后相同的数据一个分片，这样将数据分成多个分片好处：数据切片比较均匀，对数据压力分散的效果较好缺点：数据分散后，对于查询需求需要进行聚合处理</p></li><li><p>按照时间切片 按照时间的范围将数据分布到不同的分片</p></li></ul><p>分片后的事务处理机制</p><p>CAP理论：一个分布式系统不能同时满足“一致性(C)、可用性(A)和分区容错性(P)”需求，最多只能同时满足两个。</p><ul><li>C:Consistency(一致性)：任何一个读操作总是能读取到之前完成的写操作结果，也就是在分布式环境中，多点的数据是一致的；</li><li>A:Availability(可用性)：每一个操作总是能够在确定的时间内返回，也就是系统随时都是可用的；</li><li>P: Tolerance of NetworkPartition(分区容忍性)：在出现网络分区的情况下，分离的系统也能正常运行。</li></ul><p>对于分布式存储系统而言，分区容错性(P)是基本需求，只有CP和AP两种模式的选择。</p><ul><li>CP模式：保证分布在网络上不同节点数据一致性，但对可用性支持不足。</li><li>AP模式：以实现“最终一致性(EventualConsistency)”来确保可用性和分区容忍性，但弱化了数据一致性要求。</li></ul><p>CAP关注的力度是数据，而不是整个系统。每个系统都会处理不同类型的数据，有的数据可以遵守CP，有的可以遵守AP</p><p>CAP是忽略网络延迟的（理论中的C并不可能完美的实现，因为网络延迟），正常运行情况下，不存在CP和AP的选择，可以同时满足CA，放弃并不等于什么都不做，需要为分区恢复后做准备</p><p>两阶段提交协议：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><ol type="1"><li><p>请求阶段(表决)：事务协调者通知每个参与者准备提交或取消事务，然后进入表决过程，参与者要么在本地执行事务，写本地的redo和undo日志，但不提交。请求阶段，参与者将告知协调者自己的决策:同意(事务参与者本地作业执行成功)或取消（本地作业执行故障）</p></li><li><p>提交阶段(执行)：在该阶段，写调整将基于第一个阶段的投票结果进行决策:提交或取消。当且仅当所有的参与者同意提交事务，协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务，参与者在接收到协调者发来的消息后将执行响应的操作。</p></li></ol><p>缺点：同步阻塞问题、单点故障、数据不一致</p><p>三阶段提交协议：针对“单点故障”问题，在第一、二阶段间加入“准备阶段”，当协调者故障后，参与者可以通过超时提交来避免一致阻塞。</p><ol type="1"><li>canCommit阶段</li></ol><p>3PC的canCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回yes响应，否则返回no响应</p><ol start="2" type="1"><li>preCommit阶段</li></ol><p>协调者根据参与者canCommit阶段的响应来决定是否可以继续事务的preCommit操作</p><ul><li>协调者从所有参与者得到的反馈都是yes:那么进行事务的预执行，协调者向所有参与者发送preCommit请求，并进入prepared阶段。参与者接收到preCommit请求后会执行事务操作，并将undo和redo信息记录到事务日志中。如果一个参与者成功地执行了事务操作，则返回ACK响应，同时开始等待最终指令</li><li>协调者从所有参与者得到的反馈有一个是No或是等待超时之后协调者都没收到响应:那么就要中断事务，协调者向所有的参与者发送abort请求。参与者在收到来自协调者的abort请求，或超时后仍未收到协调者请求，执行事务中断。</li></ul><ol start="3" type="1"><li>doCommit阶段协调者根据参与者preCommit阶段的响应来决定是否可以继续事务的doCommit操作</li></ol><ul><li>协调者从参与者得到了ACK的反馈:协调者接收到参与者发送的ACK响应，那么它将从预提交状态进入到提交状态，并向所有参与者发送doCommit请求。参与者接收到doCommit请求后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源，并向协调者发送haveCommitted的ACK响应。那么协调者收到这个ACK响应之后，完成任务。</li><li>协调者从参与者没有得到ACK的反馈,也可能是接收者发送的不是ACK响应，也可能是响应超时：执行事务中断。</li></ul><p>最大努力保证模式适用于对一致性要求并不十分严格，但是对性能要求较高的场景。具体实现方法：在更新多个资源时，将多个资源的提交尽量延后到最后一刻处理，如果业务流程出现问题，则所有资源更新都回滚，保持事务一致。</p><p>事务补偿机制：在数据库分库分表后，如果涉及的多个更新操作在某一个数据库范围内完成，则可以使用数据库内的本地事务保证一致性。对于跨库的多个操作，可通过补偿和重试，使其在一定时间窗口内完成操作。这样既保证了事务的最终一致性，又突破了事务遇到问题就回滚的传统思想。如果采用事务补偿机制，则在遇到问题时，需要记录遇到问题的环境、信息、步骤、状态等，后续通过重试机制使其达到最终一致性。</p><p>事务路由：无论使用哪种分布式事务处理方法，都需要对分库分表的多个数据源路由事务。如果更新操作在一个数据库实例内发生，便可以使用数据源的事务来处理。对于跨数据源的事务，可通过在应用层使用最大努力保证模式和事务补偿机制来达成事务的一致性。</p><ul><li><p>自动提交事务路由</p><p>自动提交事务路由通过依赖JDBC数据源的自动提交事务特性，对任何数据库进行更新操作后会自动提交事务，不需要开发人员手动操作事务，也不需要配置事务，但只能满足简单的业务逻辑需求。在通常情况下，JDBC在连接创建后默认设置自动提交为true，当然也可以在获取连接后手工修改这个属性。</p></li><li><p>可编程事务路由</p><p>通常采用Spring的声明式的事务来管理数据库事务，在分库分表时，事务处理是个问题，在一个需要开启事务的方法中，需要动态地确定开启哪个数据库实例的事务，也就是说在每个开启事务的方法调用前就必须确定开启哪个数据源的事务。</p></li><li><p>声明式事务路由</p><p>在实现的方法上直接声明事务的处理注解，注解包含使用哪个数据库分片的事务管理器的信息。</p></li></ul><p>分库分表引起的问题</p><ul><li><p>扩容与迁移</p><p>数据一致性问题、动静数据分离问题</p></li><li><p>查询问题</p><p>在分库分表以后，如果查询的标准是分片的主键，则可以通过分片规则再次路由并查询，但是对于其他主键的查询、范围查询、关联查询、查询结果排序等，并不是按照分库分表维度来查询的。</p></li><li><p>分布式事务问题</p><p>多库多表分布式所引发的一致性问题</p></li><li><p>同组数据跨库问题</p><p>要尽量把同一组数据放到同一台数据库服务器上，不但在某些场景下可以利用本地事务的强一致性，还可以使这组数据实现自治。</p></li></ul><h4 id="分库分表的中间件简介">分库分表的中间件简介🎹</h4><p>MyCat</p><p>MyCat是一个强大的数据库中间件，不仅仅可以用作读写分离、以及分表分库、容灾备份，而且可以用于多租户应用开发、云平台基础设施。MyCat后面连接的MyCat Server，就好象是MySQL的存储引擎，如InnoDB，MyISAM等，因此，MyCat本身并不存储数据，数据是在后端的MySQL上存储的，因此数据可靠性以及事务等都是MySQL保证的。</p><p>MyCat拦截了用户发送过来的SQL语句，首先对SQL语句做一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL 发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户。 当 MyCat收到一个SQL时，会先解析这个SQL，查找涉及到的表，然后看此表的定义，如果有分片规则，则获取到SQL里分片字段的值，并匹配分片函数，得到该SQL对应的分片列表，然后将SQL发往这些分片去执行，最后收集和处理所有分片返回的结果数据，并输出到客户端。</p><p>Sharding JDBC</p><p>Sharding-JDBC是当当应用框架ddframe中，从关系型数据库模块dd-rdb中分离出来的数据库水平分片框架，实现透明化数据库分库分表访问。Sharding-JDBC直接封装JDBCAPI，可以理解为增强版的JDBC驱动，旧代码迁移成本几乎为零。</p><h3 id="数据缓存">数据缓存⛈️</h3><h4 id="数据缓存的基本理论">数据缓存的基本理论🪗</h4><p>缓存的概念：用于存储数据的硬件或软件组件，以使得后续更快访问响应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。</p><p>缓存的作用：主要解决高并发，热点数据访问的性能问题。提供高性能的数据快速访问。</p><p>缓存的原理：将数据写入到读取速度更快的存储、将数据缓存到离应用最近的位置、将数据缓存到离用户最近的位置。</p><p>虽然从硬件介质上来看，无非就是内存和硬盘两种，但从技术上，可以分成内存、硬盘文件、数据库。</p><p>数据缓存的基本架构：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613144219176.png" /></p><ul><li><p>本地缓存</p><p>本地缓存指的是在应用中的缓存组件，其最大的优点是应用和cache是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适。</p><p>本地缓存的缺点：因为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。</p><p>应用场景：缓存字典等常用数据。</p><p>实现方法：应用编码；中间件，如Ehcache、 Guava Cache等</p></li><li><p>分布式缓存</p><p>分布式缓存指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存</p><p>应用场景：缓存经过复杂运算得出的数据、缓存存储系统中频繁访问的热点数据，减轻存储系统压力</p><p>常用的分布式缓存中间件：Memcached、Redis</p></li><li><p>反向代理缓存</p><p>反向代理位于应用服务器机房，处理所有对WEB服务器的请求。如果用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。通过降低向WEB服务器的请求数，从而降低了WEB服务器的负载。</p><p>应用场景：一般只缓存体积较小的静态文件资源，如css、js、图片</p><p>常用的开源实现：Varnish、Nginx、Squid</p></li><li><p>CDN（内容分发网络）缓存</p><p>通过在现有互联网中增加一层新的网络架构（CDNS），将网站内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容。</p><p>CDN目标：解决由于网络带宽小、用户访问量大、网点分布不均等原因所造成的用户访问网站响应速度慢的问题。</p><p>CDN：将一个服务器的内容平均分布到多个服务器上；智能识别服务器，让用户获取离用户最近的服务器，提高访问速度。</p></li></ul><p>命中率：命中率=返回正确结果数/请求缓存次数；命中率问题是缓存中的一个非常重要的问题，它是衡量缓存有效性的重要指标。命中率越高，表明缓存的使用率越高。</p><p>最大元素（或最大空间）：缓存中可以存放的最大元素的数量，一旦缓存中元素数量超过这个值（或者缓存数据所占空间超过其最大支持空间），那么将会触发缓存启动清空策略；根据不同的场景合理的设置最大元素值往往可以一定程度上提高缓存的命中率，从而更有效的使用缓存。</p><p>基本操作：</p><ul><li><p>命中与验证</p><p>HTTP再验证：原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本，进行“新鲜度检测”。</p><p>缓存可以在任意时刻，以任意的频率对副本进行再验证。但由于缓存中通常会包含数百万的文档，而且网络带宽是很珍贵的，所以大部分缓存只有在客户端发起请求，并且副本旧得足以需要检测的时候，才会对副本进行再验证。</p><p>为了有效地进行再验证，HTTP定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的。</p><p>HTTP 为我们提供了几个用来对已缓存对象进行再验证的工具，但最常用的是If-Modified-Since 首部。将这个首部添加到 GET请求中去，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。</p><p>服务器收到 GET If-Modified-Since 请求时的 3 种情况:</p><ol type="1"><li>再验证命中(revalidate hit)或缓慢命中(slowhit)：如果服务器对象未被修改，服务器会向客户端发送一个小的 HTTP 304 NotModified响应。只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端。</li><li>再验证未命中：如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP 200 OK 响应。</li><li>对象被删除：如果服务器对象已经被删除了，服务器就回送一个 404 NotFound 响应，缓存也会将其副本删除。</li></ol></li><li><p>清洗</p><p>缓存清空策略：在缓存的存储空间有限制，当缓存空间被用满时，既要保证稳定服务，又要有效提升命中率。常见的一般策略有：FIFO、LFU、LRU。设计适合自身数据特征的清空策略能有效提升命中率。</p></li><li><p>更新</p><p>Cache aside</p><ul><li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从cache中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><p>Read/Write Through Pattern</p><ul><li>Read Through是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），CacheAside是由调用方负责把数据加载入缓存，而ReadThrough则用缓存服务自己来加载，从而对应用方是透明的。</li><li>Write Through在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）。</li></ul><p>Write Behind Caching Pattern</p><ul><li>俗称writeback，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比，因为异步（比如消息队列），writeback还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</li><li>但是这个设计的最大致命问题在于数据的非强一致性，极可能造成数据的丢失。假如使用redis作为缓存数据库，最致命的问题在于redis并不能保证绝对不丢失数据，也就是redis的持久化能力（两种持久化都无法保证数据绝对丢失）不足，redis一旦挂了，可能造成数据丢失且无法恢复。</li></ul></li></ul><h4 id="本地缓存">本地缓存⛰️</h4><p>JVM可以使用的内存分外2种：堆内内存（on-heap）和堆外内存（off-heap）</p><p>堆Heap是内存中动态分配对象存在的地方。如果使用new一个对象，它就被分配在堆内存上。一般情况下，Java中分配的非空对象都是由JVM的垃圾收集器管理的，也称为堆内内存。虚拟机会定期对垃圾内存进行回收，在某些特定的时间点，它会进行一次彻底的回收。彻底回收时，垃圾收集器会对所有分配的堆内内存进行完整的扫描，这意味着一次垃圾收集对Java应用造成的影响，跟堆的大小是成正比的。过大的堆会影响Java应用的性能。</p><p>堆外内存意味着把内存对象分配在JVM的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）。这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。使用堆外内存能够降低JVM垃圾回收导致的暂停。</p><p>本地缓存实现方法：</p><ul><li><p>编程直接实现缓存</p><p>静态变量实现：通过静态变量一次获取到缓存内存中，减少频繁的I/O读取，静态变量实现类间可共享，进程内可共享，缓存的实时性稍差。为了解决本地缓存数据的实时性问题，目前大量使用的是结合ZooKeeper的自动发现机制，实时变更本地静态变量缓存。</p><p>优点是能直接在heap区内读写，最快也最方便；缺点同样是受heap区域影响，缓存的数据量非常有限，同时缓存时间受GC影响。主要满足单机场景下的小数据量缓存需求，同时对缓存数据的变更无需太敏感感知，如上一般配置管理、基础静态数据等场景。</p></li><li><p>中间件 Ehcache</p><p>Ehcache的核心定义主要包括：</p><ul><li>cache manager：缓存管理器，允许多实例</li><li>cache：缓存管理器内可以放置若干cache，存放数据的实质，所有cache都实现了Ehcache接口，这是一个真正使用的缓存实例；通过缓存管理器的模式，可以在单个应用中轻松隔离多个缓存实例，独立服务于不同业务场景需求，缓存数据物理隔离，同时需要时又可共享使用</li><li>element：单条缓存数据的组成单位。</li><li>system ofrecord（SOR）：可以取到真实数据的组件，可以是真正的业务逻辑、外部接口调用、存放真实数据的数据库等，缓存就是从SOR中读取或者写入到SOR中去的。</li></ul></li></ul><h4 id="分布式缓存">分布式缓存🗻</h4><p>分布式缓存的迁移：</p><ul><li><p>平滑迁移</p><p>最开始是这样的，使用了具有两个分片的缓存集群，通过关键字哈希的方式进行路由，因为两个分片已经不能满足缓存容量的需求，所以现在需要扩容到4个分片，达到原来两倍的缓存总大小，因此我们需要迁移。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/d72l1kh1mk.jpeg" /></p><p>第一步：双写，按照新规则和旧规则同时往新缓存和旧缓存中写数据</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613163917290.png" /></p><p>这个步骤有优化的空间，因为是在成倍扩容的场景下，所以我们不需要准备4个全新的分片。新规则中前两个分片的数据，其实是旧规则中两个分片数据的子集，并且规则一致，所以我们可以重用前两个分片，也就是说一共需要两个新的分片，用来处理关键字哈希取余后为2和3的情况；使用旧的缓存分片来处理关键字哈希取余后0和1的情况即可。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613164106338.png" /></p><p>第二步：迁移历史数据，把旧缓存集群中的历史数据读取出来，按照新的规则写到新的缓存集群中</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613164222395.png" /></p><p>第三步，切读，把应用层所有的读操作路由到新的缓存集群上</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613164314432.png" /></p><p>第四步，下线双写，把写入旧的集群的逻辑下线</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613164348681.png" /></p></li><li><p>一致性哈希</p><p>一致性哈希将整个哈希值空间组织成一个虚拟的圆环（哈希环），如假设某哈希函数H的值空间为$0 $ ~ <spanclass="math inline">\(2^{32}-1\)</span>（即哈希值是一个32位无符号整形），整个空间按顺时针方向组织。0和<spanclass="math inline">\(2^{32}-1\)</span>在零点钟方向重合</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613164731708.png" /></p><p>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的 IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613164811228.png" /></p><p>将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613164847983.png" /></p><p>分析一致性哈希算法的容错性和可扩展性：</p><p>现假设NodeC不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到NodeD。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。</p><p>如果在系统中增加一台服务器Node X，此时对象ObjectA、B、D不受影响，只有对象C需要重定位到新的Node X。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613164945689.png" /></p><p>一致性哈希算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜问题。此时必然造成大量数据集中到一个节点上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613165216915.png" /></p></li><li><p>停机迁移</p><ol type="1"><li>停机应用，先将应用停止服务</li><li>迁移历史数据，按照新的规则把历史数据迁移到新的缓存数据集群中</li><li>更改应用的数据源配置，指向新的缓存集群</li><li>重新启动应用</li></ol><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613164438158.png" /></p><p>该方式简单，高效，能够有效避免数据的不一致，但需要由业务方评估影响，一般在晚上访问量较小，或者非核心服务的场景下比较适用</p></li></ul><p>Redis</p><p>Redis是一个远程内存数据库（非关系型数据库），性能强劲，具有复制特性以及解决问题而生的独一无二的数据模型。它可以存储键值对与5种不同类型的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能</p><p>Redis内部使用一个 redisObject对象来标识所有的key和value数据，其中包括：</p><ul><li>type代表一个value对象具体是何种数据类型</li><li>encoding是不同数据类型在Redis内部的存储方式，比如 ——type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或是int，如果是int则代表Redis内部是按数值类型存储和表示这个字符串</li></ul><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613165409620.png" /></p><p>Redis数据淘汰策略：</p><ul><li>Volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰Volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>Volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>Allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>Allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>No-enviction（驱逐）：禁止驱逐数据</li></ul><p>数据淘汰内部实现：</p><ul><li>消极方法：在主键被访问时如果发现它已经失效，那么就删除它，触发时机：在实现GET，MGET，HGET，LRANGE等所有涉及到读取数据的命令时都会调用</li><li>积极方法：周期性地从设置了失效时间的主键中选择一部分失效的主键删除，触发时机：Redis的时间事件，即每隔一段时间就中断一下完成一些指定操作</li></ul><p>Redis持久化方法：</p><ul><li>RDB（RedisDataBase）：默认的持久化方案，数据库的快照（snapshot）以二进制的方式定时保存到磁盘中</li><li>AOF（Append OnlyFile）：以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到AOF文件，以此达到记录数据库状态的目的</li></ul><h4 id="缓存问题讨论">缓存问题讨论♨️</h4><h5 id="数据一致性">数据一致性⚗️</h5><p>因为缓存属于持久化数据的一个副本，所以不可避免的会出现数据不一致问题，如脏读或读不到数据的情况</p><p>数据不一致，一般是因为网络不稳定或节点故障导致问题出现的常见3个场景以及解决方案：</p><ul><li>先写缓存，再写数据库：【描述】缓存写成功，但写数据库失败或响应延迟，则下次读取（并发读）缓存时，就出现脏读；【解决】这个写缓存的方式，本身就是错误的，需要改为先写持久化介质，再写缓存的方式</li><li>先写数据库，再写缓存：【描述】写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据；【解决1】根据写入缓存的响应来进行判断，如果缓存写入失败，则回滚数据库操作。该方法增加了程序的复杂度；【解决2】缓存使用时，假如读缓存失败，先读数据库，再回写缓存</li><li>缓存异步刷新：【描述】指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新；【解决】根据日志中用户刷新数据的时间间隔，以及针对数据可能产生不一致的时间，进行同步操作</li></ul><h5 id="缓存穿透">缓存穿透🪔</h5><p>缓存穿透指的是使用不存在的key进行大量的高并发查询，这导致缓存无法命中，每次请求都要穿透到后端数据库系统进行查询，使得数据库压力过大，甚至导致数据库服务崩溃。</p><p>解决方案：通常将空值缓存起来，再次接收到同样的查询请求时，若命中缓存并值为空，就会直接返回，不会透传到数据库，避免缓存穿透。对恶意的查询攻击，可以对查询条件设置规则，不符合条件产生规则的直接拒绝</p><h5 id="缓存并发">缓存并发🦜</h5><p>缓存并发的问题通常发生在高并发的场景下，当一个缓存key过期时，因为访问这个缓存key的请求量较大，多个请求同时发现缓存过期，因此多个请求会同时访问数据库来查询最新数据，并且回写缓存，这样会造成应用和数据库的负载增加，性能降低，由于并发较高，甚至会导致数据库崩溃。</p><p>解决方案：</p><ul><li>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。该方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</li><li>本地锁：与分布式锁类似，通过本地锁的方式来限制只有一个线程去数据库中查询数据，而其他线程只需等待，等前面的线程查询到数据后再访问缓存。但是，这种方法只能限制一个服务节点只有一个线程取数据库中查询，如果一个服务有多个节点，则会有多个数据库查询操作，也就是说在节点数量较多的情况下并没有完全解决缓存并发的问题。<br /></li><li>软过期：软过期指对缓存中的数据设置失效时间，就是不使用缓存服务提供的过期时间，而是业务层在数据中存储过期时间信息，由业务程序判断是否过期并更新，在发现了数据即将过期时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程会先继续使用旧数据并等待，直至派遣线程获取最新数据后再更新缓存。也可以通过异步更新服务来更新设置软过期的缓存，这样应用层就不用关心缓存并发的问题</li></ul><h5 id="缓存雪崩">缓存雪崩🌅</h5><p>缓存雪崩指缓存服务器重启或者大量缓存集中在某一个时间段内失效，业务系统需要重新生成缓存，给后端数据库造成瞬时的负载升高的压力，甚至导致数据库崩溃。</p><p>解决方案：</p><ul><li>更新锁机制：对缓存更新操作进行加锁保护，保证只有一个线程能进行缓存更新</li><li>失效时间分片机制：对不同的数据使用不同的失效时间，甚至对相同的数据、不同的请求使用不同的失效时间。例如，当对缓存的user数据中的每个用户的数据设置不同的缓存过期时间，可以定义一个基础时间，如10秒，然后加上一个两秒以内的随机数，则过期时间为10～12秒，这样就可以避免雪崩。</li><li>后台更新机制：由后台线程来更新缓存，并不是业务线程来更新缓存<br /></li><li>缓存集群：可以做缓存的主从与缓存水平分片</li></ul><h5 id="缓存高可用">缓存高可用⚓</h5><p>缓存是否高可用，需要根据实际的场景而定，并不是所有业务都要求缓存高可用，需要结合具体业务，具体情况进行方案设计，例如临界点是否对后端的数据库造成影响。</p><p>主要解决方案：</p><ul><li>分布式：实现数据的海量缓存</li><li>复制：实现缓存数据节点的高可用</li></ul><h5 id="缓存热点">缓存热点⛩️</h5><p>一些特别热点的数据，高并发访问同一份缓存数据，导致缓存服务器压力过大。</p><p>解决：复制多份缓存副本，把请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力</p><h3 id="非关系型数据库">非关系型数据库🧯</h3><h4 id="nosql概述">NoSQL概述🦪</h4><p>NoSQL中使用最多的是Key-value存储型，其他的还包含文档型、列存储型、图型数据库、XML数据库等</p><p>NoSQL数据库共有原则：</p><ul><li>假设失效是必然发生的：NoSQL实现都建立在硬盘、机器和网络都会失效这些假设之上，我们不能彻底阻止这些失效，因此需要让系统能够在即使非常极端的条件下也能应付这些失效</li><li>对数据进行分区：最小化失效带来的影响，也将读写操作的负载分布到了不同的机器上</li><li>保存同一数据的多个副本：大部分NoSQL实现都基于数据副本的热备份来保证连续的高可用性。一些实现提供了API，可以控制副本的复制，也就是说，当存储一个对象时，可以在对象级指定希望保存的副本数</li><li>查询支持：在这个方面，不同的实现有本质的区别。不同的实现的一个共性在于哈希表中的Key-value匹配</li></ul><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613172939164.png" /></p><p>NoSQL优缺点：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613173415032.png" /></p><p>NoSQL分类：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613173733599.png" /></p><p>按CAP分类：</p><p>CP：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613173809971.png" /></p><p>AP：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613173826925.png" /></p><h4 id="nosql在系统架构中的应用">NoSQL在系统架构中的应用🍚</h4><ul><li><p>以NoSQL为辅</p><p>NoSQL作为镜像：不改变原有的以MySQL作为存储的架构，使用NoSQL作为辅助镜像存储，用NoSQL的优势辅助提升性能。在原有基于MySQL数据库的架构上增加了一层辅助的NoSQL存储。在写入MySQL数据库后，同时写入到NoSQL数据库，让MySQL和NoSQL拥有相同的镜像数据。在某些可以根据主键查询的地方，使用高效的NoSQL数据库查询。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613183034974.png" /></p><p>同步模式：通过MySQL把数据同步到NoSQL中，是一种对写入透明，但是具有更高技术难度的一种模式。适用于现有的比较复杂的老系统，通过修改代码不易实现，可能引起新的问题，同时也适用于需要把数据同步到多种类型的存储中。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613183452808.png" /></p><p>MySQL与NoSQL组合：MySQL中只存储需要查询的小字段，NoSQL存储所有数据。把需要查询的字段，一般都是数字，时间等类型的小字段存储于MySQL中，根据查询建立相应的索引。其他不需要的字段，包括大文本字段都存储在NoSQL中。在查询的时候，先从MySQL中查询出数据的主键，然后从NoSQL中直接取出对应的数据即可</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613183557041.png" /></p></li><li><p>以NoSQL为主</p><p>纯NoSQL：在一些数据结构、查询关系非常简单的系统中，可以只使用NoSQL即可以解决存储问题。在一些数据库结构经常变化，数据结构不定的系统中，就非常适合使用NoSQL来存储</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613183703378.png" /></p><p>以NoSQL为数据源：数据直接写入NoSQL，再通过NoSQL同步协议复制到其他存储。根据应用的逻辑来决定去相应的存储获取数据。应用程序只负责把数据直接写入到NoSQL数据库，然后通过NoSQL的复制协议，把NoSQL的每次写入，更新，删除操作都复制到MySQL数据库中。同时，也可以通过复制协议把数据同步复制到全文检索实现强大的检索功能。这种架构需要考虑数据复制直接存取NoSQL NoSQL的延迟问题，与主从中的复制延迟问题一样。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220613183829078.png" /></p></li><li><p>以NoSQL为缓存</p><p>由于NoSQL数据库天生具有高性能、易扩展的特点，所以常常结合关系数据库，存储一些高性能的、海量的数据。从另外一个角度看，根据NoSQL的高性能特点，它同样适合用于缓存数据。用NoSQL缓存数据可以分为内存模式和磁盘持久化模式。</p><ul><li><p>内存模式</p><p>Memcached提供了相当高的读写性能，在互联网发展过程中，一直是缓存服务器的首选，NoSQL数据库Redis又为我们提供了功能更加强大的内存存储功能。跟Memcached比，Redis的一个key可以存储多种数据结构Strings、Hashes、Lists、Sets、Sortedsets。Redis不但功能强大，而且它的性能完全超越了Memcached</p></li><li><p>磁盘持久化模式</p><p>虽然基于内存的缓存服务器具有高性能，低延迟的特点，但是内存成本高，内存数据易失却不容忽视。大部分互联网应用的特点都是数据访问有热点，也就是说，只有一部分数据是被频繁使用的。其实NoSQL数据库内部也是通过内存缓存来提高性能的，通过一些比较好的算法。使用NoSQL来做缓存，由于其不受内存大小的限制，可以把一些不常访问、不怎么更新的数据也缓存起来</p></li></ul></li></ul><h4 id="常用的nosql数据库">常用的NoSQL数据库🥙</h4><p>Hbase： Handoop Databse，基于Key-Value和列族数据库的NoSQL</p><p>Dynamo：具有高可用性和高扩展性的分布式数据存储系统（Amazon）</p><p>Apache Cassandra： Facebook的开源分布式Key-Value存储系统</p><p>Redis(Remote Dictionary Server): 一种Key-Value存储系统</p><p>MongoDB：分布式文档存储数据库</p>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件架构与中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件架构与中间件（二）</title>
    <link href="/post/cf17def0.html"/>
    <url>/post/cf17def0.html</url>
    
    <content type="html"><![CDATA[<p>对软件架构与中间件课程的主要内容进行总结</p><span id="more"></span><h1 id="软件架构与中间件二">软件架构与中间件（二）</h1><h2 id="第3章-计算层的软件架构技术">第3章 计算层的软件架构技术🕯️</h2><h3 id="软件计算层的挑战">软件计算层的挑战💢</h3><p>任务越来越复杂：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220529141905721.png" /></p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220529141928887.png" /></p><p>计算模式变革：</p><ul><li>单机计算模式→互联网计算模式</li><li>单机计算模式→串行<br /></li><li>单机计算模式→多核、众核计算</li></ul><p>性能度量</p><ul><li><p>CPU速度（MIPS）</p></li><li><p>网络带宽（Mbps）</p></li><li><p>吞吐量（TPS、QPS）</p><p>指系统在单位时间内处理请求的数量。</p><ul><li><p>TPS：客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。包括了：</p><ol type="1"><li>用户请求服务器</li><li>服务器自己的内部处理</li><li>服务器返回给用户</li></ol><p>这三个过程，每秒能够完成N个这三个过程，TPS也就是N</p></li><li><p>QPS：每秒能处理查询数目。是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><p>QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。</p></li></ul></li><li><p>RT响应时间（s）</p><p>指系统对请求作出响应的时间。</p></li><li><p>网络延时（s）</p></li><li><p>并发用户数</p><p>指系统可以同时承载的正常使用系统功能的用户的数量。</p></li><li><p>扩展性</p><p>适应不断增长的处理任务的能力。</p><ul><li>垂直扩展：提高硬件配置<br /></li><li>水平扩展：增加新的计算机分布式计算</li></ul></li><li><p>高可用性：系统在几乎任何时刻都可被正常访问，通常量化为一年中正常运行的时间比</p><ul><li>系统可用性：平均故障时间MTTF、平均修复时间MTTR、系统可用性=MTTF/(MTTF+MTTR)</li></ul></li></ul><h3 id="单机性能从何而来">单机性能从何而来👅</h3><ul><li><p>算法 &amp; 数据结构优化</p><p>发现瓶颈：压测工具、抽象模型；线程、内存参数调整；Java特性优化；减少并发冲突；减少序列化；减少字符到字节的转换；使用长连接</p></li><li><p>通信模式优化</p><p>单服务器高性能的关键之一就是服务器采取的网络通信模型，如下两个关键设计点：</p><ul><li>服务器如何管理连接。</li><li>服务器如何处理请求。</li></ul><p>解决方案：</p><ul><li><p>PPC</p><p>每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的 UNIX网络服务器所采用的模型。</p><p>优点：PPC 模式实现简单，比较适合服务器的连接数没那么多的情况</p><p>缺点：</p><ul><li>fork【创建进程】代价高</li><li>父子进程通信复杂</li><li>支持的并发连接数量有限</li></ul></li><li><p>prefork</p><p>当连接进来时才 fork 新进程来处理连接请求，由于 fork进程代价高，用户访问时可能感觉比较慢，prefork模式的出现就是为了解决这个问题。</p><p>prefork就是提前创建进程，系统在启动的时候就预先创建好进程，然后才开始接受用户的请求。</p><p>优点：当有新的连接进来的时候，就可以省去 fork进程的操作，让用户访问更快、体验更好</p><p>缺点：父子进程通信复杂、支持的并发连接数量有限</p></li><li><p>TPC</p><p>每次有新的连接就新建一个线程去专门处理这个连接的请求。</p><p>优点：解决了 fork 代价高和进程通信复杂的问题</p><p>缺点：</p><ol type="1"><li>创建线程虽然比创建进程代价低，但并不是没有代价，高并发时（例如每秒上万连接）还是有性能问题。</li><li>无须进程间通信，但是线程间的互斥和共享又引入了复杂度，可能一不小心就导致了死锁问题。</li><li>多线程会出现互相影响的情况，某个线程出现异常时，可能导致整个进程退出（例如内存越界）。</li><li>TPC 还是存在 CPU 线程调度和切换代价的问题。</li></ol><p>TPC 方案本质上和 PPC方案基本类似，在并发几百连接的场景下，反而更多地是采用 PPC 的方案，因为PPC 方案不会有死锁的风险，也不会多进程互相影响，稳定性更高。</p></li><li><p>preread</p><p>预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快、体验更好。</p><p>常见实现方式：</p><ul><li>主进程 accept，然后将连接交给某个线程处理。<br /></li><li>子线程都尝试去 accept，最终只有一个线程 accept 成功</li></ul></li><li><p>以上4种解决方案在高并发时还是存在问题，PPC和TPC实现简单，但是都无法支撑高并发的场景，于是有了下面应对高并发场景的单服务器高性能架构模式：</p></li><li><p>Reactor（Dispatcher）</p><p>Reactor 是非阻塞同步网络模型，因为真正的 read 和 send操作都需要用户进程同步操作。这里的“同步”指用户进程在执行read 和 send这类 I/O 操作的时候是同步的。</p><p>PPC每个连接都要创建进程并且连接结束后进程就销毁（浪费）→资源复用，即不再单独为每个连接创建进程，而是创建一个进程池，将连接分配给进程，一个进程可以处理多个连接的业务。</p><p>来了一个事件我就有相应的反应。</p><p>根据事件类型来调用相应的代码进行处理。</p><p>核心组成部分：</p><ul><li>Reactor，负责监听和分配事件。</li><li>处理资源池（进程池或线程池），负责处理事件。</li></ul><p>可变性：</p><ul><li>Reactor 的数量可以变化：可以是一个Reactor，也可以是多个Reactor。</li><li>资源池的数量可以变化：以进程为例，可以是单个进程，也可以是多个进程（线程类似）。</li></ul><p>实现方案：</p><ul><li><p>单 Reactor 单进程 / 线程</p><p>Reactor 对象通过 select 监控连接事件，收到事件后通过dispatch进行分发。</p><p>如果是连接建立的事件，由 Acceptor 处理，通过accept接受连接，并创建一个 Handler 来处理连接后续的各种事件。</p><p>如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler（第 2步中创建的 Handler）来进行响应。</p><p>Handler 会完成 read→业务处理→send 的完整业务流程。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220529152243030.png" /></p><p>优点：简单，全部都在同一个进程内完成</p><p>缺点：无法发挥多核 CPU 的性能</p><p>Redis使用这种模式（单Reactor单进程）！</p></li><li><p>单 Reactor 多线程</p><p>主线程中，Reactor 对象通过 select 监控连接事件，收到事件后通过dispatch 进行分发。</p><p>如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过accept接受连接，并创建一个 Handler 来处理连接后续的各种事件。</p><p>如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler（第 2步中创建的 Handler）来进行响应。</p><p>Handler 只负责响应事件，不进行业务处理；Handler 通过read读取到数据后，会发给Processor 进行业务处理。</p><p>Processor会在独立的子线程中完成真正的业务处理，然后将响应结果发给主进程的Handler处理；Handler 收到响应后通过 send将响应结果返回给 client。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220529152707288.png" /></p><p>优点：能够充分利用多核多 CPU 的处理能力</p><p>缺点：多线程数据共享和访问比较复杂、Reactor承担所有事件的监听和响应，只在主线程中运行，瞬间高并发时会成为性能瓶颈。</p></li><li><p>多 Reactor 多进程 / 线程</p><p>父进程中 mainReactor 对象通过 select 监控连接建立事件，收到事件后通过Acceptor 接收，将新的连接分配给某个子进程。 子进程的 subReactor 将mainReactor 分配的连接加入连接队列进行监听，并创建一个Handler用于处理连接的各种事件。 当有新的事件发生时，subReactor会调用连接对应的Handler（即第 2 步中创建的 Handler）来进行响应。 Handler完成 read→业务处理→send 的完整业务流程。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220529153337173.png" /></p><p>优点：实现简单（父进程和子进程的职责非常明确，父进程只负责接收新连接，子进程负责完成后续的业务处理。父进程和子进程的交互很简单，父进程只需要把新连接传给子进程，子进程无须返回数据。子进程之间是互相独立的，无须同步共享之类的处理）</p><p>Nginx 采用的是多 Reactor 多进程！</p><p>Memcache 和 Netty 采用的是多 Reactor 多线程！</p></li></ul></li><li><p>Proactor</p><p>如果把 I/O 操作改为异步就能够进一步提升性能，这就是异步网络模型Proactor。</p><p>来了事件我来处理，处理完了我通知你。</p><p>Proactor Initiator 负责创建 Proactor 和 Handler，并将Proactor 和Handler 都通过 Asynchronous Operation Processor 注册到内核。</p><p>Asynchronous Operation Processor 负责处理注册请求，并完成I/O操作。</p><p>Asynchronous Operation Processor 完成 I/O 操作后通知Proactor。</p><p>Proactor 根据不同事件类型回调不同的 Handler 进行业务处理。</p><p>Handler 完成业务处理，Handler 也可以注册新的 Handler 到内核进程。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220529154529393.png" /></p><p>理论上 Proactor 比 Reactor效率要高一些，但实际两者都有使用，因为要实现真正的异步I/O，操作系统需要做大量的工作。Windows一般用Proactor，而Linux一般用Reactor。</p></li></ul></li></ul><h3 id="分布式计算架构">分布式计算架构🐾</h3><h4 id="分布式编程模型">分布式编程模型🎥</h4><p>MapReduce：应用程序编写人员只需要将精力放在应用程序本身，而关于集群的可靠性、可扩展性等问题则交由平台来处理。</p><p>MapReduce是⼀种针对超⼤规模数据集的编程模型和系统。⽤MapReduce开发出的程序可在⼤量商⽤计算机集群上并⾏执⾏、处理计算机的失效以及调度计算机间的通信。</p><p>MapReduce的基本思想：</p><ul><li>用户写的两个程序：Map和Reduce<br /></li><li>一个在计算机集群上执行多个程序实例的框架</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530125518431.png" style="zoom:50%;" /></p><p>具有相同key的所有值都发送到相同的reducer。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530125818532.png" /></p><p><span class="math inline">\(map(k_1,v_1) → [(k_2,v_2)]\)</span></p><p><span class="math inline">\(reduce(k_2,[v_2]) →[(k_3,v_3)]\)</span></p><p>为并行reduce操作划分密钥空间</p><p><span class="math inline">\(partition(k_2, number\ of\ partitions) →partition\ for\ k_2\)</span></p><p>用于优化以减少网络流量</p><p><span class="math inline">\(combine (k2, [v2]) →[(k’,v’)]\)</span></p><p>Hadoop中MapReduce的实现：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530130951559.png" /></p><ol type="1"><li>⾸先提交⼀个 job，信息发给Job Tracker</li><li>Job Tracker 是框架的中⼼，定时与集群中机器通信，管理哪些程序跑在哪些机器上，管理所有 job 失败、重启等操作</li><li>Task Tracker 是 MapReduce集群中每台机器都有的部分，它主要监视⾃⼰所在机器的资源情况，同时监视当前机器的tasks 运⾏状况</li><li>Task Tracker 需要把这些信息通过 heartbeat 发送给 Job Tracker</li><li>Job Tracker 会搜集这些信息以给新提交的 job 分配运⾏在哪些机器上</li></ol><p>主要存在以下问题：</p><ol type="1"><li>JobTracker 是 MapReduce 的集中处理点，存在单点故障</li><li>JobTracker 完成了太多的任务，造成了过多的资源消耗</li><li>当 MapReduce job ⾮常多时，会造成很⼤的内存开销：业界总结 Hadoop的MapReduce只能⽀持 4000 节点主机的上限</li><li>在 TaskTracker 端，以 map/reduce task的数⽬作为资源的表⽰过于简单，没有考虑到 CPU/内存的占⽤情况，如果两个⼤内存消耗的 task被调度到了⼀块，很容易出现溢出</li><li>在 TaskTracker 端，把资源强制划分为 map task slot 和 reduce taskslot, 如果当系统中只有 map task 或者只有 reduce task的时候，会造成资源的浪费</li></ol><p>YARN：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530131729512.png" /></p><p>ResourceManager（RM）：YARN分层结构的本质是ResourceManager。这个实体控制整个集群并管理应用程序向基础计算资源的分配。ResourceManager将各个资源部分（计算、内存、带宽等）精心安排给基础NodeManager（YARN的每节点代理）。ResourceManager还与 ApplicationMaster一起分配资源，与NodeManager一起启动和监视它们的基础应用程序。在此上下文中，ApplicationMaster承担了以前的 TaskTracker 的一些角色，ResourceManager 承担了 JobTracker的角色。</p><p>NodeManager（NM）：NodeManager管理一个YARN集群中的每个节点。NodeManager提供针对集群中每个节点的服务，从监督对一个容器的终生管理到监视资源和跟踪节点健康。MRv1通过插槽管理Map和Reduce任务的执行，而NodeManager管理抽象容器（container），这些容器代表着可供一个特定应用程序使用的针对每个节点的资源。YARN继续使用HDFS层。它的主要NameNode用于元数据服务，而DataNode用于分散在一个集群中的复制存储服务。NodeManager是驻留在一个YARN集群中的每个节点上的代理。</p><p>ApplicationMaster（AM）：ApplicationMaster管理一个在YARN内运行的应用程序的每个实例。ApplicationMaster负责协调来自 ResourceManager 的资源，并通过 NodeManager监视容器的执行和资源使用（CPU、内存等的资源分配）。请注意，尽管目前的资源更加传统（CPU核心、内存），但未来会带来基于手头任务的新资源类型（比如图形处理单元或专用处理设备）。从YARN 角度讲，ApplicationMaster 是用户代码，因此存在潜在的安全问题。YARN假设ApplicationMaster存在错误或者甚至是恶意的，因此将它们当作无特权的代码对待。</p><p>Container：对任务运行环境进行抽象，封装CPU、内存等多维度的资源以及环境变量、启动命令等任务运行相关的信息。比如内存、CPU、磁盘、网络等，当AM向RM申请资源时，RM为AM返回的资源便是用Container表示的。YARN会为每个任务分配一个Container，且该任务只能使用该Container中描述的资源。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530132540912.png" /></p><p>优点：</p><ol type="1"><li>这个设计⼤⼤减⼩了JobTracker（也就是现在的ResourceManager）的资源消耗，并且让监测每⼀个Job⼦任务(tasks)状态的程序分布式化了，更安全、更优美。另外，在新版中，ApplicationMaster是⼀个可变更的部分，⽤户可以对不同的编程模型写⾃⼰的ApplicationMaster，让更多类型的编程模型能够跑在Hadoop集群中。</li><li>能够⽀持不同的编程模型</li><li>对于资源的表⽰以内存为单位(在⽬前版本的Yarn中，没有考虑CPU的占⽤)，⽐之前以剩余slot数⽬更合理</li><li>既然资源表⽰成内存量，那就没有了之前的map slot/reduceslot分开造成集群资源闲置的尴尬情况了</li></ol><p>MapReduce 经历过程：Input → Splitting → Mapping → Shuffling →Reducing → Output 。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605101114438.png" /></p><h4 id="消息中间件">消息中间件🐭</h4><p>在分布式系统中，进程在不同的机器上运行，通过消息传递交换信息，成功的分布式系统依赖于隐藏或简化消息传递的通信模型。程间通信是所有分布式系统的核心。</p><p>中间件分类：</p><ul><li>远程过程调用 RPC</li><li>面向对象中间件 OOM</li><li>面向消息的中间件 MOM</li><li>于事件的中间件</li><li>事务处理监视器（TPM）</li><li>对象请求代理（ORB）</li></ul><p>MOM是一种特殊形式的中间件，它能够促进异步消息从一个组件到另一个组件的传输。</p><p>使用消息进行通信，消息存储在消息队列中，消息服务器将客户端和服务器解耦。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605133357212.png" /></p><p>通信模式分类</p><ul><li><p>基于寻址类型的分类：直接寻址/间接寻址</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605135113016.png" /></p></li><li><p>基于阻塞类型的分类：同步/异步</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605135559976.png" /></p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605135612390.png" /></p></li><li><p>基于缓冲类型的分类：有缓存/无缓存</p><p>有缓存：持续，消息可以被缓冲。</p><p>无缓存：暂时，消息立即交付，服务器必须在通信开始时运行，直接连接到所需的服务器。</p></li><li><p>基于内容类型的分类：事件，命令，数据，流</p></li><li><p>基于确认类型的分类：不确认/确认/三次握手</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605150917526.png" /></p></li><li><p>基于接收机数目的分类：点对点（无播）/多播/任意播/位置辅助多播/广播</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605151352134.png" /></p></li><li><p>基于通信方向的分类：单工/半双工/全双工</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605151654247.png" /></p></li><li><p>基于发起人的分类</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605151931283.png" /></p></li></ul><p>MOM中队列（Queue）：</p><ul><li><p>作为发送方和接收方之间的中介，是消息的目的地、允许进程独立执行和失败、可以屏蔽进程故障和通信故障。</p></li><li><p>时间解耦</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605152317924.png" /></p></li><li><p>地点解耦</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605152345510.png" /></p></li></ul><p>消息优先级：</p><ul><li><p>最高优先级优先</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605152612680.png" /></p></li><li><p>加权公平调度</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605152623310.png" /></p></li></ul><p>MOM思想：</p><ul><li>基本思想：应用程序通过在特定队列中插入消息进行通信。</li><li>在最终传递到目标之前，通过一系列通信服务器转发的消息。</li><li>发送消息时，接收器可能已关闭。</li><li>当接收方接收到消息时，发送方无需执行。</li><li>发件人可以保证其邮件最终会插入收件人的队列，但不保证何时插入 。</li></ul><p>MOM中可以添加很多模块。</p><p>MOM中队列管理器（Queue Manager）：</p><ul><li><p>是一种专门的数据库</p></li><li><p>通过API向应用程序提供队列功能</p></li><li><p>提供管理手段</p><ul><li>创建/删除队列</li><li>允许启动和停止队列</li><li>更改现有队列的属性</li><li>允许监视性能、故障和恢复</li></ul></li><li><p>通常给队列管理器配置将消息转发给其他队列管理器的功能</p></li><li><p>通常称为消息代理（Message Broker）</p><ul><li><p>消息转换</p><p>重新格式化数据/信息、翻译、了解源和目标的结构/格式</p></li><li><p>智能路由</p><p>流量控制、消息字典</p></li><li><p>规则引擎</p></li><li><p>存储库</p></li><li><p>过滤</p></li><li><p>访问控制</p></li></ul></li></ul><p>MOM性质：</p><ul><li><p>异步交互</p><p>客户端和服务器只是松散耦合的、消息是已排队的、有利于应用程序集成</p></li><li><p>支持可靠的交付服务</p><p>将队列保留在持久性存储中</p></li><li><p>中间消息服务器处理消息</p><p>可以进行筛选、转换、记录等操作、消息服务器形成网络</p></li><li><p>数据库集成很方便</p></li></ul><p>MOM消息传递模式：</p><ul><li><p>一对一</p><p>一个发送方，一个接收方、点对点</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605154529988.png" /></p></li><li><p>一对多</p><p>一个发送方，多个接收方</p></li><li><p>多对一</p><p>多个发送方，一个接收方</p></li><li><p>多对多</p><p>多个发送方，多个接收方、发布和订阅</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605154542479.png" /></p><p>消息代理（队列管理器）的一个重要和常见用途是帮助形成发布/订阅模型，在这样的模型中，代理不仅负责转换消息，还负责根据正在交换的消息匹配应用程序、应用程序可以通过将Topic X 上的消息发送给代理来发布该消息、对主题 X上的消息感兴趣的应用程序可以订阅这些消息，然后从代理接收这些消息。</p></li></ul><p>MOM例子</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605154926153.png" /></p><h4 id="负载均衡机制">负载均衡机制🦧</h4><p>单服务器无论如何优化，总会有上限，当无法满足业务需求时，就需要设计高性能集群来提升系统整体的处理性能。</p><p>高性能集群需要增加一个任务分配器（负载均衡器）以及为任务选择一个合适的任务分配算法。</p><p>负载均衡器：</p><ul><li><p>DNS 负载均衡</p><p>一般用来实现地理级别的均衡。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605103200015.png" /></p><p>优点：简单、成本低；就近访问，提升访问速度。</p><p>缺点：更新不及时；扩展性差；分配策略较简单。</p></li><li><p>硬件负载均衡</p><p>通过单独的硬件设备来实现负载均衡功能，这类设备和路由器、交换机类似。目前业界典型的硬件负载均衡设备有两款：F5和 A10 。</p><p>优点：功能强大；性能强大；稳定性高；支持安全防护。</p><p>缺点：价格昂贵；扩展能力差。</p></li><li><p>软件负载均衡</p><p>通过负载均衡软件来实现负载均衡功能，常见有Nginx（7层负载均衡）、LVS（Linux 内核的 4 层负载均衡）。4 层和 7层的区别就在于协议和灵活性：Nginx 支持 HTTP、E-mail 协议；而 LVS 是 4层负载均衡，和协议无关，几乎所有应用都可以做，例如，聊天、数据库等。</p><p>软件和硬件负载均衡方法的最主要区别就在于性能，硬件负载均衡性能远远高于软件负载均衡性能。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605103716195.png" /></p><p>优点：简单；便宜；灵活。</p><p>缺点：性能一般；功能没有硬件负载均衡那么强大；一般不具备防火墙和防DDoS 攻击等安全功能。</p></li></ul><p>负载均衡典型架构：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220605103908259.png" /></p><p>地理级别负载均衡：当用户访问时，DNS会根据用户的地理位置来决定返回哪个机房的 IP ；集群级别负载均衡：F5收到请求后，进行集群级别的负载均衡；机器级别的负载均衡：Nginx收到用户请求后，将用户请求发送给集群里面的某台服务器。</p><p>负载均衡算法：</p><ul><li><p>任务数平分类</p><p>负载均衡系统将收到的任务平均分配给服务器进行处理，这里的“平均”可以是绝对数量的平均，也可以是比例或者权重上的平均。</p><ul><li>轮询：负载均衡系统收到请求后，按照顺序轮流分配到服务器上。不关注服务器本身的状态，如果服务器出了bug，它是不关心的，会继续发送请求给该服务器；如果集群中新旧机器性能不同，它分配的也一样的。<br /></li><li>加权轮询：负载均衡系统根据服务器权重进行任务分配，权重一般是根据硬件配置进行静态配置的。主要目的就是为了解决不同<strong>服务器处理能力有差异</strong>的问题，解决了轮询算法中无法根据<strong>服务器的配置差异</strong>进行任务分配的问题，但是无法根据<strong>服务器的状态差异</strong>进行任务分配。</li></ul></li><li><p>负载均衡类</p><p>负载均衡系统根据服务器的负载来进行分配，用连接数、I/O使用率、网卡吞吐量等来衡量系统的压力。</p><ul><li><p>负载最低优先：将任务分配给当前负载最低的服务器。</p><p>LVS，可以以“连接数”来判断服务器的状态，服务器连接数越大，表明服务器压力越大。</p><p>Nginx，可以以“HTTP请求数”来判断服务器状态（Nginx内置的负载均衡算法不支持这种方式，需要进行扩展）。</p><p>如果是 CPU 密集型，可以以“CPU 负载”来衡量系统压力。</p><p>如果是 I/O 密集型，可以以“I/O 负载”来衡量系统压力。</p><p>解决轮询算法中无法感知服务器状态的问题，但是复杂度增加很多，实际应用场景反而不如轮询。</p></li></ul></li><li><p>性能最优类</p><p>负载均衡系统根据服务器的响应时间来进行任务分配，优先将新任务分配给响应最快的服务器。</p><ul><li><p>性能最优类</p><p>站在客户端的角度来进行分配的，优先将任务分配给处理速度最快的服务器，通过这种方式达到最快响应客户端的目的。</p><p>负载最低优先类算法是站在服务器的角度来进行分配的。</p><p>性能最优优先类算法本质上也是感知了服务器的状态，只是通过响应时间这个外部标准来衡量服务器状态而已。复杂度很高，主要体现在：负载均衡系统需要收集和分析每个服务器每个任务的响应时间，在大量任务处理的场景下，这种收集和统计本身也会消耗较多的性能。工业上使用采样，并调优采样率</p></li></ul></li><li><p>Hash 类</p><p>负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash值的请求分配到同一台服务器上。常见的有源地址 Hash、目标地址Hash、session id hash、用户 id hash 等。</p><ul><li><p>Hash 类</p><p>根据任务中的某些关键信息进行 Hash 运算，将相同 Hash值的请求分配到同一台服务器上，这样做的目的主要是为了满足特定的业务需求。</p><ul><li><p>源地址Hash</p><p>将来源于同一个源 IP地址的任务分配给同一个服务器进行处理，适合于存在事务、会话的业务。</p><p>例如，当我们通过浏览器登录网上银行时，会生成一个会话信息，这个会话是临时的，关闭浏览器后就失效。网上银行后台无须持久化会话信息，只需要在某台服务器上临时保存这个会话就可以了，但需要保证用户在会话存在期间，每次都能访问到同一个服务器，这种业务场景就可以用源地址Hash来实现。</p></li><li><p>ID hash</p><p>将某个 ID 标识的业务分配到同一个服务器中进行处理，这里的 ID一般是临时性数据的 ID（如 session id）。</p><p>上述的网上银行登录的例子，用session id hash同样可以实现同一个会话期间，用户每次都是访问到同一台服务器的目的。</p></li></ul></li></ul></li></ul><h4 id="冗余高可用计算">冗余高可用计算🐖</h4><p>计算高可用的本质是通过冗余来规避部分故障的风险。复杂度主要体现在任务管理方面，即当任务在某台服务器上执行失败后，如何将任务重新分配到新的服务器进行执行。</p><p>Q：哪些服务器可以接手执行任务</p><p>A：</p><ul><li>每个服务器都可以执行任务（常见的访问网站的某个页面）</li><li>只有特定服务器（通常叫“主机”）可以执行任务（ZooKeeper 的 Leader才能处理写操作请求）</li></ul><p>Q：任务如何重新执行</p><p>A：对于已经分配的任务即使执行失败也不做任何处理，系统只需要保证新的任务能够分配到其他非故障服务器上执行即可。设计任务管理器来管理需要执行的计算任务，服务器执行完任务后，需要向任务管理器反馈任务执行结果，任务管理器根据任务执行结果来决定是否需要将任务重新分配到另外的服务器上执行。</p><p>“任务分配器”是一个逻辑的概念，并不一定要求系统存在一个独立的任务分配器块。</p><ol type="1"><li>Nginx 将页面请求发送给 Web 服务器，而 CSS / JS等静态文件直接读取本地缓存。这里的 Nginx角色是反向代理系统，但是承担了任务分配器的职责，而不需要 Nginx做反向代理，后面再来一个任务分配器。</li><li>对于一些后台批量运算的任务，可以设计一个独立的任务分配系统来管理这些批处理任务的执行和分配。</li><li>ZooKeeper 中的 Follower 节点，当接收到写请求时会将请求转发给 Leader节点处理，当接收到读请求时就自己处理，这里的 Follower就相当于一个逻辑上的任务分配器。</li></ol><p>主备</p><p>主机执行所有计算任务。例如，读写数据、执行操作等。当主机故障（例如，主机宕机）时，任务分配器不会自动将计算任务发送给备机，此时系统处于不可用状态。</p><p>如果主机能够恢复，任务分配器继续将任务发送给主机。</p><p>如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复）：</p><ol type="1"><li>人工操作，备机升为主机；</li><li>任务分配器将任务发送给新的主机；</li><li>人工增加新的机器作为备机。</li></ol><p>根据备机状态的不同，主备架构又可以细分为冷备架构和温备架构：</p><ul><li>冷备：备机上的程序包和配置文件都准备好，但备机上的业务系统没有启动（注意：备机的服务器是启动的），主机故障后，需要人工手工将备机的业务系统启动，并将任务分配器的任务请求切换发送给备机。</li><li>温备：备机上的业务系统已经启动，只是不对外提供服务，主机故障后，人工只需要将任务分配器的任务请求切换发送到备机即可。</li><li>冷备可以节省一定的能源，但温备能够大大减少手工操作时间，因此一般情况下推荐用温备的方式。</li></ul><p>优点：简单，主备机之间不需要进行交互，状态判断和切换操作由人工执行，系统实现很简单</p><p>缺点：需要“人工操作”</p><p>主备架构也比较适合内部管理系统、后台管理系统这类使用人数不多、使用频率不高的业务，不太适合在线的业务。</p><p>主从</p><p>主从架构中的从机也要执行任务的任务分配器需要将任务进行分类，确定哪些任务可以发送给主机执行，哪些任务可以发送给备机执行。正常情况下，主机执行部分计算任务（如图中的“计算任务A”），备机执行部分计算任务（如图中的“计算任务B”）。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220610142409967.png" /></p><p>故障应对：任务分配器不会自动将原本发送给主机的任务发送给从机，而是继续发送给主机，不管这些任务执行是否成功。如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续按照原有的设计策略分配任务，即计算任务A 发送给主机，计算任务 B 发送给从机。如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将原来的从机升级为主机，增加新的机器作为从机，任务分配器继续按照原有的设计策略分配任务。</p><p>优点：主从架构的从机也执行任务，发挥了从机的硬件性能。缺点：主从架构需要将任务分类，任务分配器会复杂一些。</p><p>集群方案</p><p>主备架构和主从架构架构简单：通过冗余一台服务器来提升可用性。但是人工操作效率低、容易出错、不能及时处理故障。所以引出高可用集群方案，可用性要求更加严格的场景中，自动完成切换操作。</p><p>根据集群中服务器节点角色的不同，分为两类：对称集群和非对称集群</p><p>对称集群（负载均衡集群）：集群中每个服务器角色一样，都可以执行所有任务</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220610143645319.png" /></p><p>负载均衡集群详细设计：正常情况下，任务分配器采取某种策略（随机、轮询等）将计算任务分配给集群中的不同服务器。</p><p>当集群中的某台服务器故障后，任务分配器不再将任务分配给它，而是将任务分配给其他服务器执行。</p><p>当故障服务器恢复，任务分配器重新将任务分配给它执行。</p><p>负载均衡集群的设计关键点在于两点：1. 任务分配器需要选取分配策略。2.任务分配器需要检测服务器状态。</p><p>任务分配策略比较简单：轮询和随机基本够用。</p><p>状态检测稍微复杂：既要检测服务器的状态，例如服务器是否宕机、网络是否正常等；同时还要检测任务的执行状态，例如任务是否卡死、是否执行时间过长等。常用的做法是任务分配器和服务器之间通过心跳来传递信息，包括服务器信息和任务信息，然后根据实际情况来确定状态判断条件。</p><p>非对称集群：集群中的服务器分为多个不同的角色，不同的角色执行不同的任务（eg.最常见的 Master-Slave 角色，部分任务是 Master 服务器才能执行，部分任务是Slave 服务器才能执行）</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220610144559281.png" /></p><p>非对称集群架构详细设计：集群会通过某种方式来区分不同服务器的角色，例如，通过ZAB 算法选举，或者简单地取当前存活服务器中节点 ID 最小的服务器作为Master 服务器；任务分配器将不同任务发送给不同服务器，例如，计算任务 A发送给 Master 服务器，B 发送给 Slave 服务器。</p><p>当指定类型的服务器故障时，需要重新分配角色：Master服务器故障后，需要指定一个 Slave 服务器为 Master 服务器；如果 Slave服务器故障，不需要重新分配角色，只需要将其剔除即可。</p><p>非对称集群相比负载均衡集群，设计复杂度主要体现在两个方面：1.任务分配策略更加复杂：需要将任务划分为不同类型并分配给不同角色的集群节点。2.角色分配策略实现比较复杂，例如，可能需要使用 ZAB、Raft这类复杂的算法来实现Leader 的选举。</p><p>异步多活：一些极端场景下，有可能所有服务器都出现故障。如果业务期望达到即使在灾难性故障的情况下，业务也不受影响，或者在几分钟内就能够很快恢复，那么就需要设计异地多活架构。</p><ul><li>异地：地理位置上不同的地方，类似于“不要把鸡蛋都放在同一篮子里”。</li><li>多活：不同地理位置上的系统都能够提供业务服务。（活：活动，活跃）</li></ul><p>判断异地多活：</p><ol type="1"><li>正常情况下，用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务。</li><li>某个地方业务异常的时候，用户访问其他地方正常的业务系统，能够得到正确的业务服务。</li></ol><p>分类：</p><ul><li>同城异区：机房火灾、机房停电、机房空调故障这类问题可以很好地解决；支付宝等金融相关的系统，只能采用同城异区这种架构</li><li>跨城异地：解决类似新奥尔良水灾这种问题，适用于对数据一致性要求不那么高的情形。</li><li>跨国异地：解决类似美加大停电，更多适用于只读类业务或为不同地区用户提供服务。</li></ul><h4 id="分布式计算架构案例">分布式计算架构案例🐯</h4><p>集群：解决<strong>可伸缩性问题</strong>的有效方法。它允许一组服务器共享繁重的任务，并在逻辑上作为单个服务器运行。并且通过在集群中提供冗余服务器来实现<strong>高可用性</strong>的解决方案，以防一台服务器无法提供服务。</p><p>负载均衡功能：</p><ul><li><p>请求分配</p><p>客户请求按一定策略分发给集群中的某个节点，流行的算法包括循环、随机和基于权重分配【静态分配】，一些复杂的负载平衡器实现了特殊的算法，在将请求分配给服务器之前，该算法将检测每个服务器的工作负载【动态分配】</p></li><li><p>会话粘连</p><p>在进行负载平衡时，最好将请求调度到与上次某个浏览器会话相同的服务器实例。否则，应用程序可能无法正常工作（将属于同一个session的请求分配给上次请求的服务器实例，否则，应用程序可能不能正确工作）；HTTP为无状态的协议，在WEB应用服务器端通过session保存状态数据（HTTP为无状态的协议，在WEB应用服务器端通session保存状态数据）。</p></li><li><p>健康检查 &amp; 失效转移</p><p>健康检查：HTTP为无状态的协议，在WEB应用服务器端通过session保存状态数据。</p><p>失效转移：集群中某节点失效，该节点上处理的请求能够被其他节点正确地接手处理。</p></li></ul><p>单点故障（SPOF）：能够导致整个系统停止运行的模块，可通过冗余消除单点故障。</p><p>优化 → 检查当前架构：</p><ul><li>找出扩展性能瓶颈</li><li>找出单一故障点</li><li>找出宕机影响区域</li></ul><p>解决方案：</p><ul><li>水平扩展</li><li>垂直扩展</li><li>水平切分</li><li>垂直切分</li></ul><p>步骤1：</p><p>假设部署在单个服务器上的系统需要扩展。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611143100289.png" /></p><p>步骤2：</p><p>垂直扩展：增加CPU和RAM。</p><p>优点：易于实施</p><p>缺点：有极限；硬件不能线性扩展；增加停机影响； 成本呈指数增长。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611144944045.png" /></p><p>步骤3：</p><p>垂直切分：在单独的节点上部署每个服务。</p><p>优点：提高每个应用程序的可用性；基于任务的专门化、优化和调优是可能的；易于实施；无需更改应用程序。</p><p>缺点：需要停机时间；可能不会提高总体可用性；有限的可扩展性。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611145857566.png" /></p><p>步骤4：</p><p>水平扩展（APP Server）：集群，通过负载平衡增加APPServer的节点数。</p><p>具体实现：硬件负载平衡器速度更快；软件负载平衡器更加可定制；对于HTTP服务器，负载平衡通常与HTTP加速器相结合；用于故障切换的会话管理策略(会话管理策略)</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611150151939.png" /></p><p>负载均衡器——会话管理策略：</p><ul><li><p>中央会话存储（session共享存储集群）</p><p>引入单点故障（SPOF），是一个附加变量，会话读写磁盘/IO使得性能略微下降</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611150940339.png" /></p></li><li><p>集群会话管理</p><p>易于设置，无SPOF，会话读取是即时的，会话写入生成网络I/O，随着节点数量的增加，网络 I/O呈指数增长，在极少数情况下，请求可能会获取过时的会话数据，用户请求到达后续节点的速度比内部节点消息快，节点内通信失败，AKA无共享群集。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611152343191.png" /></p></li></ul><p>推荐使用方法：</p><p>使用集群会话管理的情况：应用服务器数量较少，会话写入较少。其余情况一般使用中央会话存储。仅在必要时使用会话粘连。</p><p>负载均衡器——消除 SPOF</p><p>在主动-主动或主动-被动模式集群中设置 LB ，因为 LB 可能是 SPOF 。通过LB 集群解决 LB 自身单点故障问题。</p><p>主动-主动集群假设每一个LB都能够独立地承受另一个LB的负载。</p><p>如果希望零停机时间，那么只有当多个 LB（3到4个以上）以菊花链连接为Active-Active形成 LB 集群时，Active-Active才真正具有成本效益。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611204329394.png" /></p><p>步骤5</p><p>水平切分（硬件）</p><p>利用SAN存储数据库。</p><p>优点：允许 “放大” 数据库服务器，提高数据库服务器的性能。</p><p>缺点：增加成本。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611204636478.png" /></p><p>步骤6：</p><p>水平扩展（数据库）</p><p>建立数据库集群。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611204810568.png" /></p><ul><li><p>非共享集群</p><p>所有的数据库实例都相同，数据库服务器节点之间不共享任何内容，通过数据库复制实现，实际的DB文件可能存储在中央SAN上。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611205226450.png" /></p><p>复制注意事宜：</p><ul><li><p>一主多子模式（Master-Slave）</p><p>写入被发送到单个主节点，该主节点将数据复制到多个从节点，复制可能级联，简单设置，无需冲突管理。</p></li><li><p>多主多子模式（Multi-Master）</p><p>写入可以发送到多个主机中的任何一个，这些主机将写入复制到其他主机和从机。如果在多个位置同时修改相同的数据，则冲突管理所需的死锁可能存在</p></li><li><p>异步复制</p><p>不等待复制完成直接响应客户，需要修改程序，并对slave节点进行负载均衡。</p></li><li><p>同步复制</p><p>主服务器更新其自己的数据库，并在将响应返回给客户端之前确认所有从属服务器已更新其数据库。从机始终与主机具有相同的数据。需要修改应用程序才能将写操作发送到主机并平衡所有读取操作。</p></li><li><p>DBMS级复制</p></li><li><p>应用程序级复制</p><p>对 DBMS 透明，性能不佳且不可靠。</p></li></ul></li><li><p>实时应用集群（共享存储集群）</p><p>所有的数据库服务器在SAN中共享一个存储区域。所有DB服务器装载相同的块设备，</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611210216435.png" /></p></li></ul><p>推荐：数据库本身支持主从复制模式，</p><p>编写 DAO层以确保：写入发送到单个数据库、读取是负载平衡的、关键读取被发送到主机。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611210405731.png" /></p><p>步骤6优点：随着Web服务器的增长，可以添加数据库节点、DB服务器不再是SPOF</p><p>缺点：有极限（slave节点复制代价高）。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611210512838.png" /></p><p>步骤7：垂直切分/水平切分数据库</p><p>通过划分数据来增加DB集群的数量。按列切分（垂直切分）、按行切分（水平切分）。</p><p>垂直分表：每个数据库节点中的表都不一样。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611211208158.png" /></p><p>水平分表：分数据，每个数据库拥有相同的表。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611211253988.png" /></p><p>步骤7优点：应用和数据都可以扩展。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611211457270.png" /></p><p>步骤8：水平切分集合</p><p>将每个部署视为服务于用户集合的单个集合。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611212715376.png" /></p><p>创建集合：创建集合背后的目标是更易于管理，每个部署集面向不同用户群、每个部署集在体系结构上是一样的、每个部署集都有完整的应用及数据结构、每个部署集部署于单独的数据中心、用户可能按网络延迟被分配到较近的部署集上。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611212741588.png" /></p><p>优点：无限的可扩展性。</p><p>缺点：数据集成、数据转移、数据复制。</p><p>步骤9：缓存</p><p>在 APP Server中添加缓存。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611213114131.png" /></p><p>步骤10：反向代理/HTTP加速器</p><p>目的：将静态内容请求重定向到较轻的HTTP服务器、基于规则缓存内容（支持细粒度失效）、在用户端使用异步NIO、智能负载平衡。</p><p>实现方式：Nginx</p><p>反向代理：控制客户端对服务器机群的访问，并且通常提供负载均衡、安全、加密以及缓存等服务。</p><p>只要必须通过单个公共IP地址访问多个web服务器，就可以使用反向代理。应用程序防火墙功能可以防止常见的基于web的攻击。 SSL加密可以卸载到反向代理。反向代理可以将传入请求的负载分配给多个服务器。反向代理可以通过缓存静态内容和动态内容来减少其原始服务器上的负载。反向代理可以通过压缩内容来优化内容，以加快加载时间。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611214606155.png" /></p><p>代理服务器是一个服务器（计算机系统或应用程序），它充当从其他服务器寻求资源的客户端请求的中介。转发代理从内部网络接收请求并将其转发到Internet。开放代理是任何 Internet用户都可以访问的转发代理服务器。反向代理从 Internet接收请求并将其转发到内部网络中的服务器。</p><p>步骤11：其他方式</p><p>CDNs、异步IO、多层缓存</p><h3 id="并行计算架构">并行计算架构🦄</h3><h4 id="并行计算理论">并行计算理论🦗</h4><p>传统上都是串行计算编写的软件：一个问题被分解成一系列离散的指令，指令一个接一个地按顺序执行，在单个处理器上执行，任何时候只能执行一条指令。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611220544931.png" /></p><p>并行计算指同时使用多个计算资源来解决计算问题：将问题分解为可同时解决的离散部分，每个部分进一步细分为一系列说明，来自每个部分的指令在不同的处理器上同时执行，采用整体控制/协调机制。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611220557021.png" /></p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220611221653809.png" /></p><p>并行化范例</p><ul><li><p>主从模式</p><p>Master将问题分解为小任务，分发给工人并收集部分结果以生成最终结果。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612105522967.png" /></p></li><li><p>工作窃取（work stealing）</p><p>某个线程从其他队列里窃取任务来执行。一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并未每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。比如线程1负责处理1队列里的任务，2线程负责2队列的。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们可能会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务线程永远从双端队列的尾部拿任务执行。</p></li><li><p>流水线</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612105855651.png" /></p><p>对大量数据集进行操作</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612110053992.png" /></p></li><li><p>分治</p><p>一个问题被分为两个或多个子问题，每个子问题都独立解决，并将其结果合并。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612110143525.png" /></p></li></ul><p>阿姆达尔定律：忽略所有系统或通信开销的情况下，N处理器并行的加速比：<spanclass="math inline">\(Speedup= \frac{1}{r_s + \frac{r_p}{N}}\)</span>，<span class="math inline">\(r_p\)</span> 表示并行时间。</p><h4 id="并行程序-pcam-设计方法">并行程序 PCAM 设计方法🦋</h4><ul><li><p>串行算法的直接并行化</p><p>发掘和利用现有串行算法中的并行性，直接将串行算法改造为并行算法。</p></li><li><p>从问题描述开始设计并行算法</p><p>从问题本身描述出发，不考虑相应的串行算法，设计一个全新的并行算法。</p></li><li><p>借用已有算法求解新问题</p><p>找出求解问题和某个已解决问题之间的联系；改造或利用已知算法应用到求解问题上。</p></li></ul><p>设计并行算法四个阶段</p><ul><li>划分(Partitioning)：分解成小的任务，开拓并发性</li><li>通讯(Communication)：确定诸任务间的数据交换，监测划分的合理性</li><li>组合(Agglomeration)：依据任务的局部性，组合成更大的任务</li><li>映射(Mapping)：将每个任务分配到处理器上，提高算法的性能</li></ul><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612124910865.png" /></p><p>划分方法：充分开拓算法的并发性和可扩展性；先进行数据分解(称域分解)，再进行计算功能的分解(称功能分解)；使数据集和计算集互不相交；划分阶段忽略处理器数目和目标机器的体系结构；</p><ul><li><p>域分解</p><p>划分的对象是数据，可以是算法的输入数据、中间处理数据和输出数据；将数据分解成大致相等的小数据片；划分时考虑数据上的相应操作；如果一个任务需要别的任务中的数据，则会产生任务间的通讯。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612130543010.png" /></p></li><li><p>功能分解</p><p>划分的对象是计算：将计算划分为不同的任务，其出发点不同于域分解；划分后，研究不同任务所需的数据，如果这些数据不相交的，则划分是成功的，如果数据有相当的重叠，意味着要重新进行域分解和功能分解；功能分解是一种更深层次的分解。</p></li></ul><p>通讯是PCAM设计过程的重要阶段；划分产生的诸任务，一般不能完全独立执行，需要在任务间进行数据交换；从而产生了通讯；功能分解确定了诸任务之间的数据流；诸任务是并发执行的，通讯则限制了这种并发性。</p><ul><li><p>局部/全局通讯</p><p>局部：通讯限制在一个邻域内</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612131551517.png" /></p><p>全局：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612131711244.png" /></p></li><li><p>结构化/非结构化通讯</p><p>结构化：每个任务的通讯模式是相同的</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612165001984.png" /></p><p>⾮结构化：通讯构成的⽹络可以是任意图结构</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612165026152.png" /></p></li><li><p>静态/动态通讯</p><p>静态通讯：同伙的身份不会随时间变化</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612165126184.png" /></p><p>动态通讯同伙的⾝份可能是运⾏过程中对数据进⾏运算得到，具有⾼度变动性</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612165136196.png" /></p></li><li><p>同步/异步通讯</p><p>同步通讯：⽣产者与消费者在数据传输操作过程中互相协作）</p><p>异步通讯：消费者在获取数据时⽆需⽣产者的协作</p></li></ul><p>组合是由抽象到具体的过程，是将组合的任务能在一类并行机上有效的执行；合并小尺寸任务，减少任务数；如果任务数恰好等于处理器数，则也完成了映射过程；通过增加任务的粒度和重复计算，可以减少通讯成本；保持映射和扩展的灵活性，降低软件工程成本。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612165335922.png" /></p><ul><li><p>细粒度</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612165504585.png" /></p></li><li><p>粗粒度</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612165551281.png" /></p></li></ul><p>表面-容积效应：通讯量与任务子集的表面成正比，计算量与任务子集的体积成正比。</p><p>增加重复计算有可能减少通讯量；重复计算减少通讯量，但增加了计算量，应保持恰当的平衡；重复计算的目标应减少算法的总运算时间。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612170006287.png" /></p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220612170019962.png" /></p><p>每个任务要映射到具体的处理器，定位到运行机器上；任务数大于处理器数时，存在负载平衡和任务调度问题；映射的目标：减少算法的执行时间并发的任务→ 不同的处理器，任务之间存在高通讯的 →同一处理器；映射实际是一种权衡，属于NP完全问题。</p><p>任务调度问题：任务放在集中的或分散的任务池中，使用任务调度算法将池中的任务分配给特定的处理器。两种常用调度模式：Master-Slave，非集中式。</p>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件架构与中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件架构与中间件（一）</title>
    <link href="/post/ff013228.html"/>
    <url>/post/ff013228.html</url>
    
    <content type="html"><![CDATA[<p>对软件架构与中间件课程的主要内容进行总结</p><span id="more"></span><h1 id="软件架构与中间件一">软件架构与中间件（一）</h1><h2 id="第1章-软件架构与中间件的内涵及要点">第1章软件架构与中间件的内涵及要点🧧</h2><h3 id="软件架构概述">软件架构概述🌚</h3><p>架构的共性：</p><ul><li>构件：一组基本的构成要素<br /></li><li>连接件：这些要素之间的连接关系<br /></li><li>物理分布：这些要素连接之后形成的拓扑结构<br /></li><li>约束：作用于这些要素或连接关系上的限制条件<br /></li><li>性能：质量</li></ul><p>软件架构（SA）：</p><p>提供了⼀个结构、⾏为和属性的高级抽象；从⼀个较⾼的层次来考虑组成系统的构件、构件之间的连接，以及由构件与构件交互形成的拓扑结构；这些要素应该满⾜⼀定的限制，遵循⼀定的设计规则，能够在⼀定的环境下进⾏演化；反映系统开发中具有重要影响的设计决策，便于各种⼈员的交流，反映多种关注，据此开发的系统能完成系统既定的功能和性能需求。</p><p><strong>架构=构件+连接件+拓扑结构+约束+质量</strong></p><p><strong>程序 = 构件 + 连接件 </strong></p><p>对于⼤规模的复杂软件系统来说，对系统全局结构的设计⽐起对算法的选择和数据结构的设计明显重要得多。</p><p>软件架构目标：</p><ul><li>主要目标：建⽴⼀个⼀致的系统及其视图集，并表达为最终⽤户和软件设计者需要的结构形式，⽀持⽤户和设计者之间的交流与理解。<br /></li><li>外向目标：建立满足最终用户要求的系统需求<br /></li><li>内向目标：建立满足系统设计者需要以及易于系统实现、维护和扩展的系统构件构成。</li></ul><p>软件架构作用：</p><ul><li>交流的手段</li><li>可传递、可复用的模型</li><li>关键决策的体现（折衷）</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220324140326517.png" style="zoom:67%;" /></p><p>软件质量因素及对策</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220324140715537.png" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220324140732705.png" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220324140809125.png" style="zoom:67%;" /></p><p><strong>系统=服务集群+中间件</strong></p><h3 id="软件中间件概述">软件中间件概述🌵</h3><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220324141033393.png" style="zoom:67%;" /></p><ul><li>中间件（<spanclass="math inline">\(Middleware\)</span>）是<strong>一组程序</strong>，应用于分布式系统各应用之中，为系统屏蔽底层通讯和提供公共服务，并保障系统的高可靠性、高可用性、高灵活性。</li><li>分布式应用借助中间件在不同技术之间共享资源。</li><li>中间件位于客户机/服务器的操作系统之上，管理计算机资源和网络通讯。</li><li>中间件是<strong>连接两个独立应用程序或独立系统的软件</strong>，即使它们具有不同的接口。</li><li>通过中间件，应用程序可以工作于多平台或OS 环境 。</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220324141705118.png" style="zoom:67%;" /></p><p>软件中间件作用：</p><ul><li>屏蔽异构性：异构性表现在计算机的软硬件差异，包括硬件、操作系统、数据库等。</li><li>实现互操作：因为异构性，产生的结果是软件依赖于计算环境，使得各种不同软件之间在不同平台之间不能移植，或者移植困难。而且，因为网络协议和通信机制不同，这些系统不能有效相互集成。<br /></li><li>共性凝练和复用：软件应用领域越来越多，相同领域的应用系统之间许多基础功能和结构是有相似性的。通过中间件提供简单、一致、集成的开发和运行环境，简化分布式系统的设计、编程和管理。</li></ul><p>软件中间件分类：</p><ul><li>应用服务类中间件</li><li>应用集成类中间件</li><li>业务架构类中间件</li></ul><h3 id="软件架构与中间件设计过程">软件架构与中间件设计过程🎳</h3><p>4+1视图模型：</p><ul><li>⽤例视图：描述系统的典型场景与功能，主要图形包括<spanclass="math inline">\(use\ case\ diagram\)</span> 等。</li><li>逻辑视图：描述系统的抽象概念与功能(类、对象、接口、模式等)，主要图形包括<span class="math inline">\(class\ diagrams, Communication\diagrams\ and\ sequence\ diagrams\)</span>等；</li><li>开发视图：描述系统中的子系统、模块、文件、资源及其之间的关系，主要图形包括<span class="math inline">\(component\ diagrams, package\diagrams\)</span>等；</li><li>进程视图：描述系统的进程及其之间的通信协作关系，主要图形包括 <spanclass="math inline">\(activity\ diagram, sequence\diagram\)</span>等；</li><li>物理视图：描述系统如何被安装、部署与配置在分布式的物理环境下，主要图形包括<span class="math inline">\(deployment\diagram\)</span>等</li></ul><p>每个视图从不同的⻆度刻画了系统的结构属性，将它们综合在⼀起就形成了系统的整体架构。逻辑视图和开发视图描述系统的静态结构，而进程视图和物理视图描述系统的动态结构。</p><h2 id="第2章-软件架构的传统风格">第2章 软件架构的传统风格🐸</h2><h3 id="软件架构风格概述">软件架构风格概述😶‍🌫️</h3><p>软件架构风格定义：</p><ul><li>描述⽤以组织⼀类软件系统的惯⽤模式，反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统</li><li>定义一些构件和连接件类型，施加一组约束描述组合方式</li></ul><p>软件架构风格组成：</p><ul><li>⼀组构件类型<br /></li><li>⼀组连接件类型/交互机制</li><li>这些构件的拓扑分布<br /></li><li>⼀组对拓扑和⾏为的约束</li><li>对⻛格带来成本和收益的描述</li></ul><p>经典架构风格分类</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220327163435781.png" style="zoom:67%;" /></p><ul><li>数据流风格：管道/过滤器</li><li>调用/返回风格：主程序/⼦程序；⾯向对象； 分层结构</li><li>独立构件风格：事件系统</li><li>虚拟机风格：解释器</li><li>其他架构风格：<span class="math inline">\(MVC\)</span></li></ul><p><spanclass="math inline">\(KWIC索引系统\)</span>（"纯"基本架构风格例子）</p><p>接收按⾏排列的数据、每⾏有若⼲有序排列的词、每个词由若⼲有序排列的字符组成、每⾏都可以循环移位。重复地把第⼀个词删除，然后接到⾏末、<spanclass="math inline">\(KWIC\)</span>把所有⾏的各种移位结果按照字⺟表顺序输出。</p><h3 id="主程序-子过程风格">主程序-子过程风格🏜️</h3><p>结构化程序：从功能观点设计系统；结构化设计与逐步细化是这种⽅法的典型实例；逐步分解（基于"定义-使用"关系、用过程调用作为交互机制、主程序的正确性依赖于它所调⽤的⼦程序的正确性）</p><ul><li>构件：主程序，子程序</li><li>连接器：调用-返回机制</li><li>拓扑结构：层次化结构</li><li>本质：将⼤系统分解为若⼲模块(模块化)，主程序调⽤这些模块实现完整的系统功能</li></ul><p>模块分解原则：</p><ul><li>模块独立性<ul><li>高聚合、低耦合<br /></li></ul></li><li>模块规模中性<ul><li>过大：分解不充分，难理解</li><li>过小：开销大，接口复杂<br /></li></ul></li><li>模块复用性<ul><li>高扇入+低扇出<br /></li></ul></li><li>作用域与控制域适当性<ul><li>作用域要包含在控制域之中</li></ul></li></ul><p>优点：已被证明是成功的设计⽅法，可以被⽤于较⼤程序</p><p>缺点：程序超过10万⾏，表现不好；程序太⼤，开发太慢，测试越来越困难</p><p>解决<span class="math inline">\(KWIC\)</span>问题：</p><ul><li>分为四个基本功能：输入、移位、排序、输出；主程序按次序调用这四个模块；通过共享的数据存储、使用无约束的读-写协议在模块之间进行数据交换</li><li>优点：模块间数据共享；不同计算功能被隔离在不同模块中</li><li>缺点：对数据存储格式的变化会影响几乎所有的模块；对处理流程的改变与系统功能的增强也很难适应，依赖于控制模块内部的调⽤次序；这种分解难以支持有效的复用</li></ul><h3 id="面向对象风格">面向对象风格☃️</h3><p>系统被看作对象的集合；每个对象都有⼀个它⾃⼰的操作集合。数据及作⽤在数据上的操作被封装成抽象数据类型——对象</p><ul><li>构件：类和对象<ul><li>类的内部结构<ul><li>属性：描述对象静态特性的数据项<br /></li><li>操作：描述对象动态特性的一个动作<br /></li></ul></li></ul></li><li>连接件：对象之间通过函数与过程调用实现交互</li></ul><p>面向对象特性：</p><ul><li>封装：限制对某些信息的访问</li><li>交互：通过过程调⽤或类似的协议</li><li>多态：在运⾏时选择具体的操作</li><li>继承：对共享的功能保持唯⼀的接⼝</li><li>动态绑定：运⾏时决定实际调⽤的操作</li><li>复⽤和维护</li></ul><p>面向对象特点</p><ul><li>优点：复⽤和维护：利⽤封装和聚合提⾼⽣产⼒、反映现实世界、容易分解成一个系统</li><li>缺点：管理⼤量的对象：怎样确⽴⼤量对象的结构、必须知道对象的身份标识、继承引起复杂度，关键系统中慎⽤</li></ul><p>解决<span class="math inline">\(KWIC\)</span>问题：</p><ul><li>采用<spanclass="math inline">\(OO\)</span>的思想，数据和作用在数据上的读写操作被封装为object，主程序调用这些object，形成控制流程</li><li>数据不再被构件直接共享，⽽是被封装在了object中</li><li>每个对象提供了⼀个接⼝，允许其他对象通过该接⼝调⽤对该对象内封装的数据的操作</li><li>优点：某⼀构件的算法与数据结构的修改不会影响其他构件、构件之间依赖性降低，提⾼了复⽤度</li><li>缺点：不适合功能的扩展、为了增加新功能，要么修改已有的模块，要么就加⼊新的模块，性能会受到影响</li></ul><h3 id="数据流风格">数据流风格🏗️</h3><h4 id="数据流风格概述">数据流风格概述🌸</h4><p>处理操作：数据到达即被激活，无数据时不工作</p><ul><li>数据的可⽤性决定着处理<计算单元>是否执⾏<br /></li><li>系统结构：数据在各处理之间的有序移动<br /></li><li>在纯数据流系统中，处理操作之间除了数据交换，没有任何其他的交互</li></ul><p>数据流风格基本构件：数据处理(构件接⼝：输⼊端⼝和输出端⼝；从输入端口读取数据，从输出端口写入数据；计算模型：从输⼊端⼝读数，经过计算/处理，然后写到输出端⼝)</p><p>数据流风格连接件：数据流(单向，通常是异步，有缓冲；接口角色：reader和writer；计算模型：把数据从一个处理的输出端口传送到另一个处理的输入端口)</p><p>一般来说数据的流向是无序的，我们主要关注近似线性的数据流或在有限度内的循环数据流。</p><h4 id="管道-过滤器风格">管道-过滤器风格🥒</h4><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220327195329793.png" style="zoom:67%;" /></p><p>适用场景：数据源源不断的产⽣，系统需要对这些数据进⾏若⼲处理(分析、计算、转换等)。</p><p>解决方案：</p><ul><li>把系统分解为⼏个顺序的处理步骤，这些步骤之间通过数据流连接，⼀个步骤的输出是另⼀个步骤的输⼊；</li><li>每个处理步骤由⼀个过滤器构件(Filter)实现；</li><li>处理步骤之间的数据传输由管道(Pipe)负责。</li></ul><p>每个处理步骤(过滤器)都有一组输入和输出，过滤器从管道中读取输入的数据流，经过内部处理，然后产生输出数据流并写入管道中。</p><p>构件：过滤器，处理数据流（一个过滤器封装了一个处理步骤、数据源点和数据终点可以看作是特殊的过滤器）</p><ul><li><p>目标：将源数据递增的变换成目标数据</p></li><li><p>从"数据流"到"数据流"的变换</p></li><li><p>过滤器对数据流的五种变换类型：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220327201643730.png" style="zoom:67%;" /></p></li><li><p>过滤器处理数据流的方式：递增的读取和消费数据（数据到来时便被处理，不是收集完了然后处理，即在输入被完全消费之前，输出便产生了）</p></li><li><p>过滤器其他特征：无上下文信息、不保留状态、对上下游的其他过滤器无任何了解。</p></li><li><p>过滤器状态：停⽌状态：表示过滤器处于待启动状态，当外部启动过滤器后，过滤器处于处理状态；处理状态：表示过滤器正处理输入数据队列中的数据；等待状态：表示过滤器的输入数据队列为空，此时过滤器等待，当有新的数据输入时，过滤器处于处理状态。</p></li></ul><p>连接件：连接一个源和一个目的过滤器（转发数据流）</p><ul><li>管道作用：在过滤器之间传送数据</li><li>单向流；可能具有缓冲区；数据缓冲区可以是文件，数组，字典，树等集合类型；管道形成数据传输图；管道的先后顺序不影响输出的结果。</li><li>不同管道中流动的数据流可能具有不同的数据格式。</li></ul><p>连接器定义了数据流的图，形成拓扑结构</p><p>管道-过滤器风格</p><ul><li>优点：使得系统中的构件具有良好的隐蔽性和⾼内聚、低耦合的特点；支持软件复用，系统维护和增强系统性能更简单；允许对吞吐量、死锁等属性进行分析；支持并行执行</li><li>缺点：通常导致进程成为批处理的结构；不适合处理交互的应⽤</li></ul><p>解决<span class="math inline">\(KWIC\)</span>问题：</p><ul><li>四个过滤器：输⼊、移位、排序、输出；每个过滤器处理数据，然后将结果送⾄下⼀个过滤器；控制机制是分布式的：只要有数据传⼊，过滤器即开始⼯作；过滤器之间的数据共享被严格限制在管道传输</li></ul><h3 id="事件驱动风格">事件驱动风格🐘</h3><ul><li>显式调用：各个构件之间的互动是由显式调用函数或过程完成的；调用的过程与次序是固定的，预先设定的。</li><li>隐式调用：一个组件可以广播一些事件；系统中的其他构件可以注册自己感兴趣的事件，并将自己的某个过程与相应的事件进行关联；当一个事件被发布，系统自动调用在该事件中注册的所有过程。</li></ul><p>事件风格特点：事件的触发者并不知道哪些构件会被这些事件影响，相互保持独⽴</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220327205402944.png" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220327205505793.png" style="zoom:67%;" /></p><p>构件：对象或过程，并提供以下两种接口：</p><ul><li>过程或函数，充当事件源或事件处理器的角色。</li><li>事件</li></ul><p>连接器：事件-过程绑定</p><ul><li>事件处理器（事件的接收和处理⽅）的过程向特定的事件进⾏注册</li><li>事件源构件发布事件</li><li>当某些事件被发布时，向其注册的过程被隐式调⽤</li><li>调⽤的次序是不确定的</li><li>在某些清空下，连接件可以是事件-事件绑定（一个事件也可能触发其他事件，形成事件链）</li></ul><p>例：调试器（debugger）</p><ul><li>⼀旦遇到断点，调试器发布事件，从⽽触发”编辑器”与”变量监测器”；编辑器将源代码滚动到断点处，变量监测器则更新当前变量值并显示出来。</li></ul><p>事件调度策略（当事件发生时，已向此事件注册过的所有过程被激发并执行，这时需要确定事件如何被分发到已注册的模块）：</p><ul><li><p>无独立（非集中式）调度模块的事件管理器</p><p>被称为"被观察者/观察者"，每一个模块都允许其他模块向自己所能发送的某些事件表明兴趣，当某⼀模块发出某⼀事件时，它⾃动将这些事件发布给那些曾经向⾃⼰注册过此事件的模块。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329203950882.png" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329204325365.png" style="zoom:67%;" /></p><p><span class="math inline">\(ConcreteSubject\)</span>连接<spanclass="math inline">\(ConcreteObserver\)</span>，一旦有事件，<spanclass="math inline">\(ConcreteSubject\)</span>会通知所有的观察者，每一个观察者都有一个<code>update</code>方法，一旦被通知，观察者调用<code>update</code>方法。</p></li><li><p>带有独立调度模块的事件管理器</p><p>事件调度模块功能：接收到来的事件并分发它们到其它模块。</p><p>调度器决定如何分发事件：</p><ul><li><p>全广播式</p><p>调度模块将事件广播到所有的模块，但只有感兴趣的模块才去取事件并触发自身的行为</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329205801151.png" style="zoom:67%;" /></p></li><li><p>选择广播式（发布/订阅策略）</p><p>调度模块将事件送到那些已经注册了的模块中</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329205946620.png" style="zoom:67%;" /></p><ul><li><p>点对点模式：基于消息队列</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329210204856.png" style="zoom:67%;" /></p><p>系统安装并配置⼀个队列管理器，并定义⼀个消息队列，某个应⽤向消息队列注册过程，以监听并处理被放置在队列⾥的事件，其他的应⽤连接到该队列并向其中发布事件，队列管理器存储这些消息，直到接收端的应⽤连接到队列，取回这些消息并加以处理，消息只能够被唯⼀的消费者所消费，消费之后即从队列中删除。</p></li></ul></li></ul></li><li><p>发布/订阅模式</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329210238694.png" style="zoom:67%;" /></p><p>事件发布者向“主题”发布事件，订阅者向“主题”订阅事件，一个事件可以被多个订阅者消费，事件在发送给订阅者之后，并不会马上从topic中删除，topic会在事件过期之后自动将其删除。</p></li></ul><p>解决<span class="math inline">\(KWIC\)</span>问题：</p><ul><li>四个共享模块</li><li>共享数据，但共享数据并不直接暴露其格式，而是进行封装（借鉴面向对象方案）</li><li>模块的调用发生在数据发生改变时，不是主程序控制</li></ul><p>事件驱动风格优点：</p><ul><li>支持实现交互式系统（用户输入/网络通讯）</li><li>异步执⾏，不必同步等待执行结果；<ul><li>为软件复⽤提供了强大的支持。要将一个构件加入现存系统中时，只需将它注册到系统的事件中；</li></ul></li><li>为系统动态演化带来了方便。<ul><li>构件独立存在，当用一个构件代替另一个构件时，不会影响到其它构件的接口；</li></ul></li><li>对事件的并发处理将提高系统性能；</li><li>健壮性：一个构件出错将不会影响其他构件。</li></ul><p>事件驱动风格缺点：</p><ul><li>分布式的控制方式使得系统的同步、验证和调试变得异常困难<br /></li><li>数据交换问题：数据可通过事件直接在系统间传递(无调度模块时)，但在具有独立调度模块的事件系统中，数据则需要经过调度模块的传递。在这些情况下，全局性能和资源管理成为了系统的瓶颈。</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329212209272.png"  style="zoom:67%;" /></p><h3 id="解释器风格">解释器风格🥶</h3><p>例：<span class="math inline">\(java\)</span>虚拟机（<spanclass="math inline">\(Write\ Once,\ Run\ Anywhere\)</span>）</p><p>解释器</p><ul><li>解释器是⼀个⽤来执⾏其他程序的程序，针对不同的硬件平台实现了⼀个虚拟机，⾼抽象层次的程序翻译为低抽象层次所能理解的指令，以消除在程序语⾔与硬件之间存在的语义差异。</li><li>解释器通常用来在程序语⾔定义的计算和有效硬件操作确定的计算之间建⽴对应和联系。</li></ul><p>解释器风格</p><ul><li>构件<ul><li>解释器引擎</li><li>存储区<ul><li>被解释的源代码</li><li>解释器引擎当前的控制状态的表示</li><li>程序当前执行状态的表示</li></ul></li></ul></li><li>连接器<ul><li>对存储区的数据访问</li></ul></li></ul><p>解释器&amp;编译器</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329213103835.png" style="zoom:67%;" /></p><ul><li>解释器的执⾏速度要慢于编译器产⽣的⽬标代码的执⾏速度，但是可能低于编译器“编译+链接+执⾏”的总时间<br /></li><li>解析器执⾏速度之所以慢，是因为每次解释执⾏的时候，都需要分析程序的结构，⽽编译代码则直接执⾏⽽⽆需重复编译<br /></li><li>解释器对内存的分配是在解释时才进⾏的；⽽编译器则是在编译时进⾏，因此运⾏时直接将程序代码装⼊内存并执⾏即可</li></ul><p>解释器中解释器策略</p><ul><li><p>传统解释器（纯粹的解释执行）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329213622694.png" style="zoom:67%;" /></p></li><li><p>基于字节码的解释器（编译<spanclass="math inline">\(\rightarrow\)</span> 解释执行）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329213735554.png" style="zoom:67%;" /></p></li><li><p>(Just-in-Time)<span class="math inline">\(\ JIT\\)</span>编译器（编译||解释执行）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220329213825615.png" style="zoom:67%;" /></p><p>只有当某个函数要被执⾏时，才被编译；⽽且， <spanclass="math inline">\(JIT\)</span>并不是编译全部的代码，⽽是只编译那些被频繁执⾏的代码段。</p></li></ul><h3 id="分层结构">分层结构🧴</h3><p>在层次系统中，系统被组织成若干个层次，每个层次由一系列构件组成。</p><ul><li>下层构件向上层构件提供服务</li><li>上层构件看作是下层构件的客户</li></ul><p>分层原则：</p><ul><li>分离关注，尽量减少功能重叠</li><li>抽象，删枝节留主干</li><li>隐藏，只暴露需要访问的接口</li></ul><p>基本构件：各层次内部包含的构件</p><p>连接件：层间的交互协议</p><p>拓扑结构：分层</p><p>拓扑约束：对相邻层间交互的约束</p><ul><li>集中式部署</li><li>分布式部署</li></ul><p>某⼀层中的构件⼀般只与同⼀级别中的对等实体或较低级别中的构件交互，这种单向交互有助于减少不同级别中的构件之间的依赖性。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220330172633233.png" style="zoom:67%;" /></p><p>三层C/S结构</p><p>在客户端与数据库服务器之间增加了⼀个中间层，中间层可能为：事务处理监控服务器、消息服务器、应⽤服务器等，中间层负责消息排队、业务逻辑执⾏、数据中转等功能。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220330173532756.png" style="zoom:67%;" /></p><ul><li><p>表示层</p><p>用户接口部分，担负着用户与应用之间的对话功能；检查用户的输入，显示应用的输出；通常使用GUI；在变更时，只需要改写显示控制和数据检查程序，而不影响其他层；不包含或包含一部分业务逻辑。</p></li><li><p>功能层</p><p>应用系统的主体，包括大部分业务处理逻辑(通常以业务构件的形式存在，如<spanclass="math inline">\(JavaBean/EJB/COM\)</span>等)；从表示层获取用户的输入数据并加以处理；处理过程中需要从数据层获取数据或向数据层更新数据；处理结果返回给表示层。</p></li><li><p>数据层</p><p>DBMS；接受功能层的数据查询请求，执行请求，并将查询结果返回给功能层；从功能层接受数据存取请求，并将数据写入数据库；请求的执行结果也要返回给功能层。</p></li></ul><p>浏览器/服务器B/S结构</p><p>浏览器/服务器(B/S)是三层C/S风格的一种实现方式</p><p>表现层：</p><ul><li>浏览器</li></ul><p>逻辑层：</p><ul><li>Web服务器</li><li>应⽤服务器</li></ul><p>数据层</p><ul><li>数据库服务器</li></ul><p>B/S结构</p><ul><li>优点<ul><li>系统维护成本低</li><li>较好安全性</li><li>“瘦客户端”</li><li>良好的容错能力和负载平衡能力</li></ul></li><li>缺点<ul><li>客户端浏览器以同步的请求/响应模式交换数据，每请求一次服务器就要刷新一次页面；</li><li>受HTTP协议“基于⽂本的数据交换”的限制，在数据查询等响应速度上，要远远低于C/S架构；</li><li>数据提交一般以页面为单位，数据的动态交互性不强，不利于在线事务处理(<spanclass="math inline">\(OLTP\)</span>)应用；</li><li>受限于HTML的表达能力，难以⽀持复杂GUI (如报表等)。</li></ul></li></ul><h3 id="模型-视图-控制器mvc">模型-视图-控制器（<spanclass="math inline">\(MVC\)</span>）🌊</h3><p>构件：模型、视图、控制器。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220330194825981.png"  style="zoom:67%;" /></p><ul><li>模型（<span class="math inline">\(Model\)</span>）<ul><li>负责数据存取、业务逻辑实现、数据验证。</li><li>在事件驱动系统中，当信息发生变化时，模型会通知观察者（通常是视图），以便他们做出反应。</li></ul></li><li>视图（<span class="math inline">\(View\)</span>）<ul><li>获取用户输入，向控制器（<spanclass="math inline">\(Controller\)</span>）发送处理请求，接收来自（<spanclass="math inline">\(Controller\)</span>）的反馈并将模型（<spanclass="math inline">\(Model\)</span>）的处理结果显示给用户。</li><li>一个模型（<spanclass="math inline">\(Model\)</span>）可能有多个</li></ul></li><li>控制器（<span class="math inline">\(Controller\)</span>）<ul><li>接收来自客户的请求、调用模型（<spanclass="math inline">\(Model\)</span>）执行业务逻辑，调用视图（<spanclass="math inline">\(View\)</span>）显示执行结果</li></ul></li></ul><p>连接件：显式调用、隐式调用或其他机制（例如HTTP协议）</p><p><span class="math inline">\(MVC\)</span></p><ul><li>优点<ul><li>分离（<span class="math inline">\(View\)</span>与<spanclass="math inline">\(Model\)</span>、<spanclass="math inline">\(Controller\)</span>与<spanclass="math inline">\(View\)</span>）</li><li>代码易维护</li><li>同一信息有不同显示方式</li><li>业务逻辑更易调试</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件架构与中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战笔记（二）</title>
    <link href="/post/d1ecf364.html"/>
    <url>/post/d1ecf364.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对<ahref="https://time.geekbang.org/column/intro/100023901">Java并发编程实战</a>的内容进行总结</p><span id="more"></span><h1 id="java并发编程实战笔记二">Java并发编程实战笔记（二）</h1><h3 id="死锁">死锁😤</h3><p>在上节中，我们最终使用下面的代码解决了并发冲突的问题</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>  <span class="hljs-comment">// 转账</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(Account.class) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance &gt; amt) &#123;<br>        <span class="hljs-built_in">this</span>.balance -= amt;<br>        target.balance += amt;<br>      &#125;<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是这种方法直接串行化了，每次都直接将 <code>Account</code>类加锁。因为要上锁需求的是 <code>this</code> 和 <code>target</code>，其实只要给它们上锁即可：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220531171357136.png" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>  <span class="hljs-comment">// 转账</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span>&#123;<br>    <span class="hljs-comment">// 锁定转出账户</span><br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;              <br>      <span class="hljs-comment">// 锁定转入账户</span><br>      <span class="hljs-keyword">synchronized</span>(target) &#123;           <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance &gt; amt) &#123;<br>          <span class="hljs-built_in">this</span>.balance -= amt;<br>          target.balance += amt;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的代码是<strong>细粒度锁</strong>思想的体现，但是上面的代码可能会产生死锁。</p><p>死锁的形式化理解：如果有客户找柜员张三做个转账业务：账户 A 转账户 B100 元，此时另一个客户找柜员李四也做个转账业务：账户 B 转账户 A 100元，于是张三和李四同时都去文件架上拿账本，这时候有可能凑巧张三拿到了账本A，李四拿到了账本 B。张三拿到账本 A 后就等着账本 B（账本 B已经被李四拿走），而李四拿到账本 B 后就等着账本 A（账本 A已经被张三拿走），他们要等多久呢？他们会永远等待下去。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220531172113371.png" /></p><p>死锁：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。</p><p>在上面的例子中，假设线程 T1 执行账户 A 转账户 B 的操作，账户A.transfer(账户 B)；同时线程 T2 执行账户 B 转账户 A 的操作，账户B.transfer(账户 A)。当 T1 和 T2 同时执行完<code>synchronized(this)</code> 时，T1 获得了账户 A 的锁（对于 T1，this是账户 A），而 T2 获得了账户 B 的锁（对于 T2，this 是账户 B）。之后 T1和 T2 在执行 <code>synchronized(target)</code> 时，T1 试图获取账户 B的锁时，发现账户 B 已经被锁定（被 T2 锁定），所以 T1 开始等待；T2则试图获取账户 A 的锁时，发现账户 A 已经被锁定（被 T1 锁定），所以 T2也开始等待。于是 T1 和 T2会无期限地等待下去，也就是我们所说的死锁了。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220531172446337.png" /></p><p>死锁解决方法：规避死锁。</p><p>死锁产生条件：</p><ol type="1"><li>互斥，共享资源 X 和 Y 只能被一个线程占用；</li><li>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y的时候，不释放共享资源 X；</li><li>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</li><li>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1占有的资源，就是循环等待。</li></ol><p>我们只要破坏其中一个，就可以成功避免死锁的发生。【其中第一个条件无法破坏】</p><ul><li><p>破坏条件2 【占用且等待】</p><p>“一次性申请所有资源”。</p><p>增加一个账本管理员，然后只允许账本管理员从文件架上拿账本，也就是说柜员不能直接在文件架上拿账本，必须通过账本管理员才能拿到想要的账本。例如，张三同时申请账本A 和 B，账本管理员如果发现文件架上只有账本A，这个时候账本管理员是不会把账本 A 拿下来给张三的，只有账本 A 和 B都在的时候才会给张三。这样就保证了“一次性申请所有资源”。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220601093708121.png" /></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;Object&gt; als = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>  <span class="hljs-comment">// 一次性申请所有资源</span><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Object from, Object to)</span>&#123;<br>    <span class="hljs-keyword">if</span>(als.contains(from) &amp;&amp; als.contains(to))&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      als.add(from);<br>      als.add(to);  <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>    <br>  <span class="hljs-comment">// 归还资源</span><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Object from, Object to)</span>&#123;<br>    als.remove(from);<br>    als.remove(to);<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>  <span class="hljs-comment">// actr 应该为单例</span><br>  <span class="hljs-keyword">private</span> Allocator actr;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>  <span class="hljs-comment">// 转账</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span>&#123;<br>    <span class="hljs-comment">// 一次性申请转出账户和转入账户，直到成功</span><br>    <span class="hljs-keyword">while</span>(!actr.apply(<span class="hljs-built_in">this</span>, target));<br>    <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-comment">// 锁定转出账户</span><br>      <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;              <br>        <span class="hljs-comment">// 锁定转入账户</span><br>        <span class="hljs-keyword">synchronized</span>(target)&#123;           <br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance &gt; amt)&#123;<br>            <span class="hljs-built_in">this</span>.balance -= amt;<br>            target.balance += amt;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      actr.free(<span class="hljs-built_in">this</span>, target)<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>Allocator有两个重要功能，分别是：同时申请资源 apply() 和同时释放资源free()。账户 Account 类里面持有一个 Allocator的单例（必须是单例，只能由一个人来分配资源）。当账户 Account在执行转账操作的时候，首先向 Allocator同时申请转出账户和转入账户这两个资源，成功后再锁定这两个资源；当转账操作执行完，释放锁之后，我们需通知Allocator 同时释放转出账户和转入账户这两个资源。</p></li><li><p>破坏条件3 【不可抢占】</p><p>通过Lock进行实现。</p></li><li><p>破坏条件4 【循环等待】</p><p>破坏这个条件，需要对资源进行排序，然后按序申请资源。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>  <span class="hljs-comment">// 转账</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span>&#123;<br>    <span class="hljs-type">Account</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>        <br>    <span class="hljs-type">Account</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> target;    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.id &gt; target.id) &#123;<br>      left = target;          <br>      right = <span class="hljs-built_in">this</span>;           <br>    &#125;                         <br>    <span class="hljs-comment">// 锁定序号小的账户</span><br>    <span class="hljs-keyword">synchronized</span>(left)&#123;<br>      <span class="hljs-comment">// 锁定序号大的账户</span><br>      <span class="hljs-keyword">synchronized</span>(right)&#123; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance &gt; amt)&#123;<br>          <span class="hljs-built_in">this</span>.balance -= amt;<br>          target.balance += amt;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>【假设每个账户有不同属性id，可以作为排序字段】</p></li></ul><h3 id="等待-通知机制">等待-通知机制🐄</h3><p>如果使用死循环等待的方式可能会消耗大量资源，如上文中破坏条件2【占用且等待】代码 <code>while(!actr.apply(this, target));</code>就是采用这种方式获取全部资源，而最好的方案应该是：如果线程要求的条件（转出账本和转入账本同在文件架上）不满足，则线程阻塞自己，进入<strong>等待</strong>状态；当线程要求的条件（转出账本和转入账本同在文件架上）满足后，<strong>通知</strong>等待的线程重新执行。其中，使用线程阻塞的方式就能避免循环等待消耗CPU 的问题。</p><p>一个完整的等待 -通知机制：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁。</p><p>wait操作：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220601100532404.png" /></p><p>等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列。</p><p>当调用 wait()方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，这个等待队列也是互斥锁的等待队列。线程在进入等待队列的同时，会释放持有的互斥锁，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。</p><p>notify操作：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220601100812886.png" /></p><p>当条件满足时调用notify()，会通知等待队列（互斥锁的等待队列）中的线程，告诉它条件<strong>曾经满足过</strong>。<strong>notify()只能保证在通知时间点，条件是满足的</strong>。而被通知线程的<strong>执行时间点和通知的时间点</strong>基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）。</p><p>被通知的线程要想重新执行，仍然需要获取到互斥锁（因为曾经获取的锁在调用wait() 时已经释放了）。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;Object&gt; als = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>  <span class="hljs-comment">// 一次性申请所有资源</span><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Object from, Object to)</span>&#123;<br>    <span class="hljs-keyword">while</span>(als.contains(from) &amp;&amp; als.contains(to))&#123;<br>      wait();<br>    &#125;<br>    als.add(from);<br>    als.add(to);<br>  &#125;<br><br>  <span class="hljs-comment">// 归还资源</span><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Object from, Object to)</span>&#123;<br>    als.remove(from);<br>    als.remove(to);<br>    notifyAll();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>尽量使用 <code>notifyAll</code> 而不是 <code>notify</code> ，使用<code>notify</code>很有风险，它的风险在于可能导致某些线程永远不会被通知到。</p><p>假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程1 归还了资源 AB，如果使用 <code>notify</code>来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3就再也没有机会被唤醒了。</p><h3 id="安全性活跃性以及性能问题">安全性、活跃性以及性能问题📱</h3><h4 id="安全性问题">安全性问题🔫</h4><p>理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题。</p><p>存在安全性问题的场景：<strong>存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据</strong>。</p><p>数据竞争：当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发Bug。</p><p>竞态条件：程序的执行结果依赖线程执行的顺序。如果程序存在竞态条件问题，那就意味着程序执行的结果是不确定的，而执行结果不确定这可是个大Bug。</p><p>转账操作里面有个判断条件 ——转出金额不能大于账户余额，但在并发环境里面，如果不加控制，当多个线程同时对一个账号执行转出操作时，就有可能出现超额转出问题。假设账户A 有余额 200，线程 1 和线程 2 都要从账户 A 转出150，在下面的代码里，有可能线程 1 和线程 2 同时执行到第 6 行，这样线程 1和线程 2 都会发现转出金额 150 小于账户余额200，于是就会发生超额转出的情况。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>  <span class="hljs-comment">// 转账</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span>&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance &gt; amt) &#123;<br>          <span class="hljs-built_in">this</span>.balance -= amt;<br>          target.balance += amt;<br>      &#125;<br>   &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>类似下面：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (状态变量 满足 执行条件) &#123;<br>  执行操作<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当某个线程发现状态变量满足执行条件后，开始执行操作；可是就在这个线程执行操作的时候，其他线程同时修改了状态变量，导致状态变量不满足执行条件了。</p><p>面对数据竞争和竞态条件问题，都可以用<strong>互斥</strong>这个技术方案，而实现<strong>互斥</strong>的方案有很多，从逻辑上来看，我们可以统一归为：<strong>锁</strong>。</p><h4 id="活跃性问题">活跃性问题🪔</h4><p>活跃性问题，指的是某个操作无法执行下去。主要有三种：死锁、活锁、饥饿。</p><ul><li><p>死锁</p><p>线程永久地“阻塞”了。</p></li><li><p>活锁</p><p>有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况。比如：路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了。如果这种情况发生在编程世界了，就有可能会一直没完没了地“谦让”下去，成为没有发生阻塞但依然执行不下去的“活锁”。</p><p>解决方案：</p><p>谦让时，尝试等待一个随机的时间就可以了。例如上面的那个例子，路人甲走左手边发现前面有人，并不是立刻换到右手边，而是等待一个随机的时间后，再换到右手边；同样，路人乙也不是立刻切换路线，也是等待一个随机的时间再切换。由于路人甲和路人乙等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。</p><p><code>Raft 中使用这种思想解决活锁问题。</code></p></li><li><p>饥饿</p><p>线程因无法访问所需资源而无法执行下去的情况。“不患寡，而患不均”，如果线程优先级“不均”，在CPU繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。</p><p>解决方案：</p><ul><li>保证资源充足</li><li>公平地分配资源</li><li>避免持有锁的线程长时间执行</li></ul><p><code>一般使用方法二。</code>公平锁：一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。</p></li></ul><h4 id="性能问题">性能问题💨</h4><p>“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了。</p><p><span class="math inline">\(S=\frac{1}{(1-p)+\frac{p}{n}}\)</span>，其中 S 表示处理器并行运算之后效率提升的能力，n 可以理解为 CPU的核数，p 可以理解为并行百分比，比如串行率为 5 % ，假设 n →+∞，无论采用什么技术，最高也就只能提高 20 倍的性能。</p><p>避免锁带来的性能问题解决方案：</p><ul><li>使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储(Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java并发包里面的原子类也是一种无锁的数据结构；Disruptor则是一个无锁的内存队列</li><li>减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是Java并发包里的ConcurrentHashMap，它使用了分段锁的技术；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。</li></ul><h3 id="管程">管程💌</h3><p>管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。</p><h4 id="mesa-模型">MESA 模型💘</h4><p>在并发编程领域，有两大核心问题：一个是<strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；另一个是<strong>同步</strong>，即线程之间如何通信、协作。</p><p>解决互斥：将共享变量及其对共享变量的操作统一封装起来。在下图中，管程X 将共享变量 queue 这个队列和相关的操作入队 enq()、出队 deq()都封装起来了；线程 A 和线程 B 如果想访问共享变量queue，只能通过调用管程提供的 enq()、deq() 方法来实现；enq()、deq()保证互斥性，只允许一个线程进入管程。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220602194307093.png" /></p><p>解决同步：共享变量和对共享变量的操作是被封装起来的，图中最外层的框就代表封装的意思。框的上面只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程同时试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。这个过程类似就医流程的分诊，只允许一个患者就诊，其他患者都在门口等待。</p><p>每个条件变量都对应有一个等待队列，条件变量和等待队列的作用是解决线程同步问题</p><ul><li>假设有个线程 T1执行出队操作，不过需要注意的是执行出队操作，有个前提条件，就是队列不能是空的，而队列不空这个前提条件就是管程里的条件变量。如果线程 T1进入管程后恰好发现队列是空的，那怎么办呢？等待啊，去哪里等呢？就去条件变量对应的等待队列里面等。（<strong>wait、await</strong>）</li><li>此时线程 T1就去“队列不空”这个条件变量的等待队列中等待。这个过程类似于大夫发现你要去验个血，于是给你开了个验血的单子，你呢就去验血的队伍里排队。线程T1进入条件变量的等待队列后，是允许其他线程进入管程的。这和你去验血的时候，医生可以给其他患者诊治，道理都是一样的。</li><li>再假设之后另外一个线程 T2执行入队操作，入队操作执行成功之后，“队列不空”这个条件对于线程 T1来说已经满足了，此时线程 T2 要通知T1，告诉它需要的条件已经满足了。当线程 T1得到通知后，会从等待队列里面出来，但是出来之后不是马上执行，而是重新进入到入口等待队列里面。（<strong>notify、notifyAll、signal、signalAll</strong>）</li><li>这个过程类似你验血完，回来找大夫，需要重新分诊。</li></ul><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220602203057885.png" /></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockedQueue</span>&lt;T&gt;&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>  <span class="hljs-comment">// 条件变量：队列不满  </span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br>  <span class="hljs-comment">// 条件变量：队列不空  </span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br> <br>  <span class="hljs-comment">// 入队</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">enq</span><span class="hljs-params">(T x)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (队列已满)&#123;<br>        <span class="hljs-comment">// 等待队列不满 </span><br>        notFull.await();<br>      &#125;  <br>      <span class="hljs-comment">// 省略入队操作...</span><br>      <span class="hljs-comment">// 入队后, 通知可出队</span><br>      notEmpty.signal();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 出队</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">deq</span><span class="hljs-params">()</span>&#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (队列已空)&#123;<br>        <span class="hljs-comment">// 等待队列不空</span><br>        notEmpty.await();<br>      &#125;<br>      <span class="hljs-comment">// 省略出队操作...</span><br>      <span class="hljs-comment">// 出队后，通知可入队</span><br>      notFull.signal();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;  <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>wait编程范式（<strong>这个是 MESA 管程特有的</strong>）：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(条件不满足) &#123;<br>  wait();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>管程要求同一时刻只允许一个线程执行，当线程 T2 的操作使线程 T1等待的条件满足时，在MESA 管程里面，T2 通知完 T1 后，T2还是会接着执行，T1并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是notify 不用放到代码的最后，T2也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。</p><p>使用notify的情况：</p><ol type="1"><li>所有等待线程拥有相同的等待条件；</li><li>所有等待线程被唤醒后，执行相同的操作；</li><li>只需要唤醒一个线程。</li></ol><p><strong>否则尽量使用 notifyAll</strong>，所以上面的代码中可以使用<strong>signal。</strong></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程实战笔记（一）</title>
    <link href="/post/e1fa1fbc.html"/>
    <url>/post/e1fa1fbc.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对<ahref="https://time.geekbang.org/column/intro/100023901">Java并发编程实战</a>的内容进行总结</p><span id="more"></span><h1 id="java并发编程实战笔记一">Java并发编程实战笔记（一）</h1><h3 id="并发抽象">并发抽象🐳</h3><p>并发编程领域可以抽象成三个核心问题：分工、同步和互斥：</p><ol type="1"><li><p>分工</p><p>类似于现实中一个组织完成一个项目，项目经理要拆分任务，安排合适的成员去完成。在并发编程领域，你就是项目经理，线程就是项目组成员。任务分解和分工对于项目成败非常关键，不过在并发领域里，分工更重要，它直接决定了并发程序的性能。</p></li><li><p>同步</p><p>在并发编程领域里的同步，主要指的就是线程间的协作，本质上和现实生活中的协作没区别。</p><p>一个线程执行完了一个任务，如何通知执行后续任务的线程开工。</p><p>工作中遇到的线程协作问题，基本上都可以描述为这样的一个问题：<strong>当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行。</strong></p><p>在 Java并发编程领域，解决协作问题的核心技术是<strong>管程</strong>。管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决互斥问题。<strong>管程是解决并发问题的万能钥匙</strong>。</p></li><li><p>互斥</p><p>保证线程安全。</p><p><strong>所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。</strong></p><p>实现互斥的核心技术是锁。</p></li></ol><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530140112045.png" /></p><h3id="可见性原子性和有序性问题及解决">可见性、原子性和有序性问题及解决🐯</h3><h4 id="三种问题">三种问题😹</h4><p>CPU、内存、I/O设备之间速度差异过大，为了合理利用 CPU的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p><ol type="1"><li>CPU 增加了缓存，以均衡与内存的速度差异；</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O设备的速度差异；</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。</li></ol><p>而这些也导致出一些并发方面的问题：</p><ul><li><p>缓存导致的可见性问题</p><p>单核时代：CPU 缓存与内存的数据一定是一致的。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530141531166.png" /></p><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p><p>多核时代：存在CPU 缓存与内存的数据一致性问题。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530141612068.png" /></p></li><li><p>线程切换带来的原子性问题</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530142402815.png" /></p><p>线程切换如上图所示，早期的操作系统基于进程来调度CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p><p>Java并发程序都是基于多线程的，自然也会涉及到任务切换，任务切换的时机大多数是在时间片结束的时候，在高级语言里一条语句往往需要多条CPU 指令完成，而操作系统做任务切换，发生在任何一条<strong>CPU指令</strong>执行完成的时候，而不是一条高级语言语句执行完成的时候，而这就会造成原子性问题。</p><p>以<code>count += 1;</code>为例，它可以拆分为三条CPU指令：</p><ul><li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li><li>指令 2：之后，在寄存器中执行 +1 操作；</li><li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU缓存而不是内存）。</li></ul><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530143214275.png" /></p><p>如上图所示，在线程A执行指令1后便发生了线程切换，等线程B执行3条指令后，再执行线程A剩下的2条CPU指令，这样最终得到的结果是1而不是2。</p><p><strong>把一个或者多个操作在 CPU执行的过程中不被中断的特性称为原子性</strong>。</p></li><li><p>编译优化带来的有序性问题</p><p>编译器为了优化性能，有时候会改变程序中语句的先后顺序。</p><p>双重检查创建单例对象：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <span class="hljs-keyword">static</span> Singleton instance;<br>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)<br>          instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现<code>instance == null</code> ，于是同时对 Singleton.class 加锁，此时JVM 保证只有一个线程能够加锁成功（假设是线程A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查<code>instance == null</code> 时会发现，已经创建过 Singleton实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>但是上述代码也存在问题，new操作的执行路径：</p><ol type="1"><li>分配一块内存 M；</li><li>将 M 的地址赋值给 instance 变量；</li><li>最后在内存 M 上初始化 Singleton 对象。</li></ol><p>假设线程 A 先执行 getInstance() 方法，当执行完指令 2时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行getInstance() 方法，那么线程 B 在执行第一个判断时会发现<code>instance != null</code> ，所以直接返回 instance，而此时的 instance是没有初始化过的，如果我们这个时候访问 instance的成员变量就可能触发空指针异常。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530150328600.png" /></p></li></ul><h4 id="可见性和有序性解决">可见性和有序性解决🤖</h4><p><strong>按需禁用缓存以及编译优化</strong>，如果完全禁用可能会造成程序性能的大幅下降。</p><ul><li><p>volatile 使用</p><p>volatile 关键字在C 语言里也有，它最原始的意义就是禁用 CPU 缓存。</p><p>声明一个 volatile 变量<code>volatile int x = 0</code>，它表达的是：告诉编译器，对这个变量的读写，不能使用CPU 缓存，必须从内存中读取或者写入。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileExample</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>    x = <span class="hljs-number">42</span>;<br>    v = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (v == <span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-comment">// 这里 x 会是多少呢？</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 jdk 1.5前<code>volatile</code>只保证声明为volatile关键字的变量，但是不会管其他变量，而且不保证代码顺序。所以上面的代码在jdk1.5前会出现<code>x=0</code> 的情况于是通过 Happens-Before规则进行语义增强。</p></li><li><p>Happens-Before 规则</p><p>前面一个操作的结果对后续操作是可见的。Happens-Before约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守Happens-Before 规则。</p><ul><li><p>程序的顺序性规则</p><p>在一个线程中，按照程序顺序，前面的操作 Happens-Before于后续的任意操作。程序前面对某个变量的修改一定是对后续操作可见的。</p><p>这条规则可以保证 <code>x=42;</code> 在 <code>v=true;</code>之前执行。</p></li><li><p>volatile 变量规则</p><p>对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile变量的读操作。</p></li><li><p>传递性</p><p>如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-BeforeC。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220530213721663.png" /></p><p><code>x=42;</code> Happens-Before 写变量 <code>v=true;</code>，这是规则 1 的内容；</p><p>写变量<code>v=true;</code> Happens-Before 读变量<code>v=true;</code>，这是规则 2 的内容 。</p><p>根据传递性，我们可以得知 <code>x=42;</code> Happens-Before 读变量<code>v=true;</code> ，如果线程 B 读到了<code>v=true;</code> ，那么线程A 设置的<code>x=42;</code>对线程 B 是可见的。也就是说，线程 B 能看到<code>x == 42;</code></p></li><li><p>管程中锁的规则</p><p>对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p><p>管程是一种通用的同步原语，在 Java中指的就是synchronized，synchronized 是 Java 里对管程的实现。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 此处自动加锁</span><br>  <span class="hljs-comment">// x 是共享变量, 初始值 =10</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.x &lt; <span class="hljs-number">12</span>) &#123;<br>    <span class="hljs-built_in">this</span>.x = <span class="hljs-number">12</span>; <br>  &#125;  <br>&#125; <span class="hljs-comment">// 此处自动解锁</span><br></code></pre></div></td></tr></table></figure><p>管程中的锁在 Java里是隐式实现的，例如上面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。</p><p>假设 x 的初始值是 10，线程 A 执行完代码块后 x 的值会变成12（执行完自动释放锁），线程 B 进入代码块时，能够看到线程 A 对 x的写操作，也就是线程 B 能够看到 <code>x==12;</code>。</p></li><li><p>线程 start() 规则</p><p>主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B前的操作。即如果线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程B），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>  <span class="hljs-comment">// 主线程调用 B.start() 之前</span><br>  <span class="hljs-comment">// 所有对共享变量的修改，此处皆可见</span><br>  <span class="hljs-comment">// 此例中，var==77</span><br>&#125;);<br><span class="hljs-comment">// 此处对共享变量 var 修改</span><br><span class="hljs-keyword">var</span> = <span class="hljs-number">77</span>;<br><span class="hljs-comment">// 主线程启动子线程</span><br>B.start();<br></code></pre></div></td></tr></table></figure></li><li><p>线程 join() 规则</p><p>主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join()方法实现），当子线程 B 完成后（主线程 A 中 join()方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对<strong>共享变量</strong>的操作。即如果在线程A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作Happens-Before 于该 join() 操作的返回。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>  <span class="hljs-comment">// 此处对共享变量 var 修改</span><br>  <span class="hljs-keyword">var</span> = <span class="hljs-number">66</span>;<br>&#125;);<br><span class="hljs-comment">// 例如此处对共享变量修改，</span><br><span class="hljs-comment">// 则这个修改结果对线程 B 可见</span><br><span class="hljs-comment">// 主线程启动子线程</span><br>B.start();<br>B.join()<br><span class="hljs-comment">// 子线程所有对共享变量的修改</span><br><span class="hljs-comment">// 在主线程调用 B.join() 之后皆可见</span><br><span class="hljs-comment">// 此例中，var==66</span><br></code></pre></div></td></tr></table></figure></li><li><p>线程中断规则</p><p>对线程 interrupt()方法的调用 Happens-Before于被中断线程的代码检测到中断事件的发生。</p></li><li><p>对象终结规则</p><p>一个对象的初始化完成 Happens-Before于它的finalize()方法的开始。</p></li></ul><p>在 Java 语言里面，Happens-Before 的语义本质上是一种可见性，AHappens-Before B 意味着 A 事件对 B 事件来说是可见的，<strong>无论 A事件和 B 事件是否发生在同一个线程里</strong>。例如 A 事件发生在线程 1上，B 事件发生在线程 2 上，Happens-Before 规则保证线程 2 上也能看到 A事件的发生。</p></li><li><p>final 使用</p><p>final修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿的优化。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br><span class="hljs-comment">// 错误的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalFieldExample</span><span class="hljs-params">()</span> &#123; <br>  x = <span class="hljs-number">3</span>;<br>  y = <span class="hljs-number">4</span>;<br>  <span class="hljs-comment">// 此处就是讲 this 逸出，</span><br>  global.obj = <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>要确保构造函数不出现 "逸出" 事件，线程通过 <code>global.obj</code>读取 x 是有可能读到 0 的。因此我们一定要避免“逸出”。</p></li></ul><h4 id="原子性问题解决">原子性问题解决🎨</h4><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220531135228447.png" /></p><p>临界区：一段需要互斥执行的代码。</p><p>首先，我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源R；其次，我们要保护资源 R 就得为它创建一把锁 LR；最后，针对这把锁LR，我们还需在进出临界区时添上加锁操作和解锁操作。另外，在锁 LR和受保护资源之间，用一条线做了关联，这个关联关系非常重要。很多并发 Bug的出现都是因为把它忽略了，然后就出现了类似锁自家门来保护他家资产的事情，这样的Bug 非常不好诊断，因为潜意识里我们认为已经正确加锁了。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>  <span class="hljs-comment">// 修饰非静态方法</span><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>  &#125;<br>  <span class="hljs-comment">// 修饰静态方法</span><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>  &#125;<br>  <span class="hljs-comment">// 修饰代码块</span><br>  <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()；<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">baz</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(obj) &#123;<br>      <span class="hljs-comment">// 临界区</span><br>    &#125;<br>  &#125;<br>&#125;  <br></code></pre></div></td></tr></table></figure><p>当修饰静态方法的时候，锁定的是当前类的 Class对象，在上面的例子中就是Class X。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>  <span class="hljs-comment">// 修饰静态方法</span><br>  <span class="hljs-keyword">synchronized</span>(X.class) <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当修饰非静态方法的时候，锁定的是当前实例对象 this。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>  <span class="hljs-comment">// 修饰非静态方法</span><br>  <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于以下代码，第一种不会有并发问题，而第二种会有：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeCalc</span> &#123;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>  <span class="hljs-type">long</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addOne</span><span class="hljs-params">()</span> &#123;<br>    value += <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeCalc</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addOne</span><span class="hljs-params">()</span> &#123;<br>    value += <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220531142348573.png" /></p><p>在 Java 中，受保护资源和锁之间的关联关系是 N: 1的关系，对于第一种情况，是一把锁保护两个资源，这时是不会产生并发冲突的，但是第二种情况，是两把锁分别保护两个资源，这时是会产生并发冲突的。</p><h4 id="一把锁保护多个资源">一把锁保护多个资源🪁</h4><p>细粒度锁：用不同的锁对受保护资源进行精细化管理，能够提升性能。</p><p>实现两客户转账：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>  <span class="hljs-comment">// 转账</span><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">( Account target, <span class="hljs-type">int</span> amt)</span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance &gt; amt) &#123;<br>      <span class="hljs-built_in">this</span>.balance -= amt;<br>      target.balance += amt;<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述是不可以的，因为只是给this加了锁，但是target并未加锁。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220531144223723.png" /></p><p>比如下面场景， A、B、C 三个账户，余额都是 200元，我们用两个线程分别执行两个转账操作：账户 A 转给账户 B 100 元，账户 B转给账户 C 100 元，最后我们期望的结果应该是账户 A 的余额是 100 元，账户B 的余额是 200 元， 账户 C 的余额是 300 元。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220531144334159.png" /></p><p>但是结果是 B 的余额为100或300。</p><p>解决方案：锁能覆盖所有受保护的资源即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> balance;<br>  <span class="hljs-comment">// 转账</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amt)</span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(Account.class) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.balance &gt; amt) &#123;<br>        <span class="hljs-built_in">this</span>.balance -= amt;<br>        target.balance += amt;<br>      &#125;<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>Account.class 是所有 Account 对象共享的，而且这个对象是 Java虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220531144932060.png" /></p><p>如果资源之间没有关系，很好处理，每个资源一把锁就可以了。如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。除此之外，还要梳理出有哪些访问路径，所有的访问路径都要设置合适的锁。</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础算法模板</title>
    <link href="/post/4b9526ee.html"/>
    <url>/post/4b9526ee.html</url>
    
    <content type="html"><![CDATA[<p>对一些常见算法的模板进行总结</p><span id="more"></span><h1 id="基础算法模板">基础算法模板</h1><h2 id="快排">快排</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>,x=q[l+r&gt;&gt;<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br><br>    <span class="hljs-built_in">quick_sort</span>(q,l,j);<span class="hljs-built_in">quick_sort</span>(q,j+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="归并排序">归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q,l,mid); <span class="hljs-built_in">merge_sort</span>(q,mid+<span class="hljs-number">1</span>,r);<br><br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) tmp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++]=q[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++]=q[j++];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,j=<span class="hljs-number">0</span>;i &lt;= r;i++,j++) q[i]=tmp[j];<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="整数二分">整数二分</h2><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/5CDE6B2F01A72254A27D853AE08CBD8F.png" /></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="浮点数二分">浮点数二分</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="高精度加法">高精度加法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="高精度减法">高精度减法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="高精度乘法">高精度乘法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="高精度除法">高精度除法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="一维前缀和">一维前缀和</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><h2 id="二维前缀和">二维前缀和</h2><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/duo-wei-qian-zhui-he.png" style="zoom:50%;" /></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><h2 id="一维差分">一维差分</h2><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/yi-jie-cha-fen.png" style="zoom:50%;" /></p><p>给区间[l, r]中的每个数加上c： <span class="math inline">\(B[l] += c,B[r + 1] -= c\)</span></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">假定a数组最开始都是0，那么b数组初始时就是a数组的差分数组了，对于每一个a[i]，相当于插入了一个数，可以直接调用insert函数即可。</span><br><span class="hljs-comment">当然也可以从差分数组的定义出发，for(int i=1;i&lt;=n;i) b[i]=a[i]-a[i-1];用这一行替换上一行，效果一样，只是上边的把a数组当成全为0，读入的a[i]再插入，这一个把读入后的当做a数组。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<br><br><span class="hljs-comment">//在这之前，b[i] 就是差分数组了，其中每一项 b[i] = a[i] - a[i-1]</span><br><span class="hljs-comment">//在执行这句话之后，相当于是求此时的 a[i] ！！！</span><br><span class="hljs-comment">//因为最后输出的是 a[i]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) b[i] += b[i<span class="hljs-number">-1</span>];<br></code></pre></div></td></tr></table></figure><h2 id="差分矩阵">差分矩阵</h2><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/er-wei-cha-fen.png" style="zoom:50%"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></div></td></tr></table></figure><h2 id="双指针算法">双指针算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br><span class="hljs-comment">/*常见问题分类：</span><br><span class="hljs-comment">(1) 对于一个序列，用两个指针维护一段区间</span><br><span class="hljs-comment">(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作*/</span><br></code></pre></div></td></tr></table></figure><h2 id="位运算">位运算</h2><p>求n的第k位数字: n &gt;&gt; k &amp; 1</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">lowbit操作解释：<br><br>设  x = 1010...1000<br>则 -x = ~x+1<br>~x = 0101...0111<br>~x+1 = 0101...1000<br>x&amp;-x = 0000...1000<br>此时返回的就是最低位 1<br>返回n的最后一位1：lowbit(n) = n &amp; -n<br></code></pre></div></td></tr></table></figure><h2 id="离散化">离散化</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br><br><span class="hljs-comment">//自己实现unique函数</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-function">iterator <span class="hljs-title">unique</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; a.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-comment">// 或者 第一个节点 或者 满足 a[i] != a[i-1] </span><br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || a[i] != a[i<span class="hljs-number">-1</span>]) a[j++] = a[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">begin</span>() + j;<br>&#125;<br><span class="hljs-comment">//调用的时候</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls),alls.<span class="hljs-built_in">end</span>());<br></code></pre></div></td></tr></table></figure><h2 id="区间合并">区间合并</h2><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/qu-jian-he-bing.png" style="zoom:50%"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-comment">// 一定记得要先对左端点进行排序！！！！！</span><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(),segs.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// 因为数据范围是 -1e9 ~ 1e9</span><br>    <span class="hljs-comment">// 2e9 相当于是无穷大</span><br>    <span class="hljs-type">int</span> st=<span class="hljs-number">-2e9</span>,ed=<span class="hljs-number">-2e9</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> seg : segs)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ed &lt; seg.first) &#123;<br>            <span class="hljs-keyword">if</span>(st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st,ed&#125;);<br>            st = seg.first;<br>            ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed,seg.second);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st,ed&#125;);<br><br>    segs = res;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL必知必会笔记（三）</title>
    <link href="/post/5c6fe708.html"/>
    <url>/post/5c6fe708.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对<ahref="https://time.geekbang.org/column/intro/100029501">SQL必知必会</a>的内容进行总结</p><span id="more"></span><h1 id="sql必知必会笔记三">SQL必知必会笔记（三）</h1><h3 id="代价统计">代价统计🎓</h3><p>查询优化器的目的就是生成最佳的执行计划，而生成最佳执行计划的策略通常有以下两种方式。</p><ul><li>基于规则的优化器 RBO</li><li>基于代价的优化器 CBO</li><li>RBO 的方式更像是一个出租车老司机，凭借自己的经验来选择从 A 到 B的路径。而 CBO 更像是手机导航，通过数据驱动，来选择最佳的执行路径。</li></ul><h3 id="查询优化">查询优化🐉</h3><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/%E4%B8%8B%E8%BD%BD.png" /></p><ul><li><p>慢查询可以帮我们定位执行慢的 SQL 语句。我们可以通过设置long_query_time 参数定义“慢”的阈值，如果 SQL 执行时间超过了long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。</p></li><li><p>EXPLAIN 查看对应 SQL 语句的执行计划，或者使用 show profile 查看SQL 中每一个步骤的时间成本。这样我们就可以了解 SQL查询慢是因为执行时间长，还是等待时间长。</p></li><li><p>EXPLAIN中type的含义：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528145128812.png" /></p><ul><li>all 是最坏的情况，因为采用了全表扫描的方式。</li><li>index 和 all 差不多，只不过 index对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大。</li><li>range 表示采用了索引范围扫描。尽量让 SQL 查询可以使用到 range这一级别及以上的 type 访问方式。</li><li>index_merge说明查询同时使用了两个或以上的索引，最后取了交集或者并集。</li><li>ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀。</li><li>eq_ref类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。</li><li>const类型表示我们使用了主键或者唯一索引（所有的部分）与常量值进行比较。<ul><li>const 类型和 eq_ref都使用了主键或唯一索引，不过这两个类型有所区别，const是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中。</li></ul></li><li>system 类型一般用于 MyISAM 或 Memory 表，属于 const类型的特例，当表只有一行时连接类型为 system。</li><li>效率从低到高依次为 all &lt; index &lt; range &lt; index_merge &lt;ref &lt; eq_ref &lt;const/system。我们在查看执行计划的时候，通常希望执行计划至少可以使用到range 级别以上的连接方式，如果只使用到了 all 或者 index连接方式，我们可以从 SQL 语句和索引设计的角度上进行改进。</li><li>如果两表关联查询，可以这样理解：<ol type="1"><li>ref - 双层循环，直到找出所有匹配。</li><li>eq_ref -双层循环，借助索引的唯一性，找到匹配就马上退出内层循环。</li><li>const: 单层循环。</li></ol></li></ul></li><li><p>查看当前会话所有开销：<code>show profiles</code>、查看上一个查询的开销<code>show profile;</code> 、查看指定的 Query ID 的开销<code>show profile for query ID_num</code> 、命令将被弃用，可以从information_schema 中的 profiling 数据表进行查看。</p></li></ul><h3 id="主从同步">主从同步🐷</h3><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220529162228714.png" /></p><p>在实际工作中，我们常常将Redis作为缓存与MySQL配合来使用，当有数据访问请求的时候，首先会从缓存中进行查找，如果存在就直接取出，如果不存在再访问数据库，这样就提升了读取的效率，也减少了对后端数据库的访问压力。可以说使用Redis这种缓存架构是高并发架构中非常重要的一环。</p><p>我们也可以对MySQL做主从架构并且进行读写分离，让主服务器(Master）处理写请求，从服务器(Slave)处理读请求，这样同样可以提升数据库的并发处理能力。</p><p>主从同步</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先需要考虑的应该是如何优化SQL 和索引，这种方式简单有效，其次才是采用缓存的策略，比如使用Redis，通过 Redis高性能的优势将热点数据保存在内存数据库中，提升读取的效率，最后才是对数据库采用主从架构，进行读写分离。</p><p>作用：</p><ul><li><p>提高数据库的吞吐量</p></li><li><p>读写分离</p><p>我们可以通过主从复制的方式来同步数据，然后通过读写分离提高数据库并发处理能力。</p><p>简单来说就是同一份数据被放到了多个数据库中，其中一个数据库是Master主库，其余的多个数据库是Slave从库。当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库中进行读取，也就是采用读写分离的方式。互联网的应用往往是—些“读多写少”的需求，采用读写分离的方式，可以实现更高的并发访问。原本所有的读写压力都由一台服务器承担，现在有多个“兄弟”帮忙处理读请求，这样就减少了对后端大哥(Master)的压力。同时，我们还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器上，让读取更加顺畅。读取顺畅的另一个原因，就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。</p></li><li><p>数据备份</p><p>我们通过主从复制将主库上的数据复制到了从库上，相当于是一种热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务。</p></li><li><p>高可用性</p><p>数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现故障或宕机的情况下，可以切换到从服务器上，保证服务的正常运行。</p></li></ul><p>主从同步原理</p><ul><li><p>主从同步的原理主要基于Binlog日志进行数据同步。在主从复制过程中，会基于三个线程操作，一个主库线程，两个从库线程。【主从复制就是主从同步】</p></li><li><p>二进制日志转储线程（Binlog dump thread）是一个主库线程。</p><p>当从库线程连接的时候，主库可以将二进制日志发送给从库，当主库读取事件的时候，会在Binlog 上加锁，读取完成之后，再将锁释放掉。</p><p>从库 I/O 线程会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O线程就可以读取到主库的二进制日志转储线程发送的 Binlog更新部分，并且拷贝到本地形成中继日志（Relay log）。</p><p>从库 SQL线程会读取从库中的中继日志，并且执行日志中的事件，从而将从库中的数据与主库保持同步。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220529202152025.png" /></p><p>主从同步的内容就是二进制日志（Binlog），它虽然叫二进制日志，实际上存储的是一个又一个事件（Event），这些事件分别对应着数据库的更新操作，比如INSERT、UPDATE、DELETE 等。</p><p>进行主从同步的内容是二进制日志，它是一个文件，在进行网络传输的过程中就一定会存在延迟（比如500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的数据不一致性问题。比如我们对一条记录进行更新，这个操作是在主库上完成的，而在很短的时间内（比如100ms）又对同一个记录进行了读取，这时候从库还没有完成数据的更新，那么我们通过从库读到的数据就是一条旧的记录。</p></li></ul><p>解决主从同步数据一致性问题</p><ul><li><p>异步复制</p><p>客户端提交 COMMIT之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/1664bdb81d017359a126030ee08e0a85.png" /></p></li><li><p>半同步复制</p><p>在客户端提交 COMMIT之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了Binlog，并且写入到中继日志中，再返回给客户端。这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/08566325d0933775d13196330596a1a1.jpg" /></p></li><li><p>组复制（MGR）</p><p>基于 Paxos 协议的状态机复制。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/39cc2dd2a96e27dbdef3dc87aa8d15ab.png" /></p><p>首先我们将多个节点共同组成一个复制组，在执行读写（RW）事务的时候，需要通过一致性协议层（Consensus层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应Node节点）的同意，大多数指的是同意的节点数量需要大于（N/2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对只读（RO）事务则不需要经过组内同意，直接COMMIT 即可。</p></li></ul><h3 id="redis简介">Redis简介👻</h3><p>Redis速度快的原因</p><ul><li>C语言编写，底层代码执行效率高，依赖性低，而且系统的兼容性好，稳定性高。</li><li>基于内存，可以避免磁盘 I/O。</li><li>数据结构结构简单，Redis 采用 Key-Value 方式进行存储，也就是使用 Hash结构进行操作，数据的操作复杂度为 O(1)。</li><li>单进程单线程模型，避免了上下文切换和不必要的线程之间引起的资源竞争。</li><li>多路 I/O 复用技术。这里的多路指的是多个 socket网络连接，复用指的是复用同一个线程。采用多路 I/O复用技术的好处是可以在同一个线程中处理多个 I/O 请求，尽量减少网络 I/O的消耗，提升使用效率。</li></ul><table><colgroup><col style="width: 8%" /><col style="width: 24%" /><col style="width: 66%" /></colgroup><thead><tr class="header"><th style="text-align: center;">数据类型</th><th style="text-align: center;">可以存储的值</th><th style="text-align: center;">操作</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">string</td><td style="text-align: center;">字符串、整数或者浮点数</td><tdstyle="text-align: center;">对整个字符串或者字符串的其中一部分执行操作，对整数和浮点数执行自增或者自减操作</td></tr><tr class="even"><td style="text-align: center;">list</td><td style="text-align: center;">列表</td><td style="text-align: center;">从两端压入或者弹出元素对单个或者多个元素进行修剪，只保留一个范围内的元素</td></tr><tr class="odd"><td style="text-align: center;">set</td><td style="text-align: center;">无序集合</td><tdstyle="text-align: center;">添加、获取、移除单个元素，检查一个元素是否存在于集合中，计算交集、并集、差集， 从集合里面随机获取元素</td></tr><tr class="even"><td style="text-align: center;">hash</td><td style="text-align: center;">包含键值对的无序散列表</td><tdstyle="text-align: center;">添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在</td></tr><tr class="odd"><td style="text-align: center;">zset</td><td style="text-align: center;">有序集合</td><td style="text-align: center;">添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名</td></tr></tbody></table><ul><li><p>字符串（string）：key-value</p><p><code>set key xxx</code></p><p><code>get key</code></p></li><li><p>列表（list）：双向链表</p><p><code>lpush listname xxx yyy zzz</code></p><p><code>rpush listname xxx yyy zzz</code></p><p><code>lrange listname start end</code></p></li><li><p>无序集合（set）</p><p><code>sadd setname xxx yyy zzz</code></p><p><code>srem setname xxx yyy</code> 【删除xxx和yyy】</p><p><code>smembers setname</code> 【获取所有元素】</p><p><code>sismember setname xxx</code> 【判断xxx是否在set中】</p></li><li><p>哈希（hash）：key-field-value</p><p><code>hset user username zhangfei</code></p><p><code>hget user username</code></p></li><li><p>有序集合（zset）：zset是在集合的基础上增加了一个分数属性，这个属性在添加修改元素的时候可以被指定。每次指定后，zset都会按照分数来进行自动排序，也就是说我们在给集合key 添加 member 的时候，可以指定 score。</p><p><code>zadd zsetname score1 xxx score2 yyy</code></p><p><code>zscore zsetname xxx</code></p><p><code>zrem zsetname xxx</code></p><p><code>zrange zsetname start end [WITHSCORES]</code> 【从小到大】</p><p><code>zrevrange zsetname start end [WITHSCORES]</code>【从大到小】</p></li></ul><p>基于直接连接的弊端，Redis提供了连接池的机制，这个机制可以让我们事先创建好多个连接，将其放到连接池中，当我们需要进行Redis操作的时候就直接从连接池中获取，完成之后也不会直接释放掉连接，而是将它返回到连接池中。连接池机制可以避免频繁创建和释放连接，提升整体的性能。</p><p>在连接池的实例中会有两个list，保存的是连接池中可以使用的连接集合（<code>_available_connections</code>）和正在使用的连接集合（<code>_in_use_connections</code>）。</p><p>Redis事务相关</p><ul><li><p>Redis不支持事务的回滚机制（Rollback），这也就意味着当事务发生了错误（只要不是语法错误），整个事务依然会继续执行下去，直到事务队列中所有命令都执行完毕。因为支持回滚会对Redis 的简单性和性能产生重大影响。</p></li><li><p>Redis 是内存数据库，与基于文件的 RDBMS不同，通常只进行内存计算和操作，无法保证持久性。</p></li><li><p>持久化方法：</p><ol type="1"><li><p>RDB</p><p>把当前进程的数据生成快照保存到磁盘上，触发 RDB持久化的方式分为手动触发和自动触发。因为持久化操作与命令操作不是同步进行的，所以无法保证事务的持久性。</p></li><li><p>AOF</p><p>采用日志的形式记录每个写操作，弥补了 RDB在数据一致性上的不足，但是采用 AOF模式，就意味着每条执行命令都需要写入文件中，会大大降低 Redis的访问性能。启用 AOF 模式需要手动开启，有 3 种不同的配置方式，默认为everysec，也就是每秒钟同步一次。其次还有 always 和 no模式，分别代表只要有数据发生修改就会写入 AOF文件，以及由操作系统决定什么时候记录到 AOF 文件中。</p></li></ol></li><li><p>命令</p><ol type="1"><li>MULTI：开启一个事务；</li><li>EXEC：事务执行，将一次性执行事务内的所有命令；</li><li>DISCARD：取消事务；</li><li>WATCH：监视一个或多个键，如果事务执行前某个键发生了改动，那么事务也会被打断；</li><li>UNWATCH：取消 WATCH 命令对所有键的监视。</li></ol></li><li><p>Redis 实现事务是基于 COMMAND 队列，如果 Redis没有开启事务，那么任何的 COMMAND 都会立即执行并返回结果。如果 Redis开启了事务，COMMAND 命令会放到队列中，并且返回排队的状态QUEUED，只有调用 EXEC，才会执行 COMMAND 队列中的命令。</p></li><li><p>MULTI 后不能再执行 WATCH 命令</p></li><li><p>如果在执行命令过程中有语法错误，Redis也会报错，整个事务也不会被执行，Redis会忽略运行时发生的错误，不会影响到后面的执行。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#开启事务</span></span><br>127.0.0.1:6379&gt; multi <br>OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#添加命令入队</span></span><br>127.0.0.1:6379&gt; set k1 v1 <br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; set k3 v3 <br>QUEUED<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#提示编译型异常</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#代码语法出现错误</span></span><br>127.0.0.1:6379&gt; getset k3<br>(error) ERR wrong number of arguments for &#x27;getset&#x27; command<br>127.0.0.1:6379&gt; set k4 v4 <br>QUEUED<br>127.0.0.1:6379&gt; set k5 v5<br>QUEUED<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#提交事务</span></span><br>127.0.0.1:6379&gt; exec<br>(error) EXECABORT Transaction discarded because of previous errors.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#尝试获取值</span></span><br>127.0.0.1:6379&gt; get k1 <br>(nil)<br>127.0.0.1:6379&gt; get k2 <br>(nil)<br>127.0.0.1:6379&gt; <br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#开启事务</span></span><br>127.0.0.1:6379&gt; multi <br>OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#添加命令入队</span></span><br>127.0.0.1:6379&gt; set v1 sss<br>QUEUED<br>127.0.0.1:6379&gt; incr v1 <br>QUEUED<br>127.0.0.1:6379&gt; set k2 v2 <br>QUEUED<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#执行事务</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#逻辑异常的命令不被执行,其他命令正常执行</span></span><br>127.0.0.1:6379&gt; exec<br>1) OK<br>2) (error) ERR value is not an integer or out of range<br>3) OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#尝试获取值</span></span><br>127.0.0.1:6379&gt; get k1<br>(nil)<br>127.0.0.1:6379&gt; get k2<br>&quot;v2&quot;<br>127.0.0.1:6379&gt; <br></code></pre></div></td></tr></table></figure></li><li><p>在 Redis中不存在悲观锁，事务处理要考虑到并发请求的情况，我们需要通过 WATCH+MULTI的方式来实现乐观锁，如果监视的 KEY没有发生变化则可以顺利执行事务，否则说明事务的安全性已经受到了破坏，服务器就会放弃执行这个事务，直接向客户端返回空回复（nil），事务执行失败后，我们可以重新进行尝试。</p></li></ul><p>Redis使用Lua</p><ul><li>Lua 是一个小巧的脚本语言，采用标准 C 语言编写，一个完整的 Lua解析器大小只有 200K。它可以嵌入到各种应用程序中，提供灵活的扩展和定制功能。</li><li><code>EVAL script numkeys key [key ...] arg [arg ...]</code><ol type="1"><li>script，代表的是 Lua 的脚本内容。</li><li>numkeys，代表后续参数 key 的个数。</li><li>key 就是我们要操作的键，可以是多个键。我们在 Lua脚本中可以直接使用这些key，直接通过<code>KEYS[1]</code>、<code>KEYS[2]</code>来获取，默认下标是从1 开始。</li><li>arg，表示传入到 Lua 脚本中的参数，就像调用函数传入的参数一样。在 Lua脚本中我们可以通过<code>ARGV[1]</code>、<code>ARGV[2]</code>来进行获取，同样默认下标从1 开始。</li></ol></li><li>在命令中调用 Lua脚本：<code>redis-cli --eval lua_file key1 key2 , arg1 arg2 arg3</code></li></ul><p>Redis VS MongoDB</p><ul><li>Redis 是 Key-Value数据库，数据存放在内存中，查询和写入都是在内存中进行操作。MongoDB面向文档数据库，功能强大，是非关系型数据库中最像 RDBMS的，处理增删改查也可以增加条件。</li><li>Redis 将数据放在内存中，通过 RDB 或者 AOF 方式进行持久化。而 MongoDB实际上是将数据存放在磁盘上的，只是通过 mmap调用，将数据映射到内存中，可以将 mmap 理解为加速的方式。</li><li>将 MongoDB 归为数据库，而将 Redis 归为缓存。</li><li>Redis就像一架飞机，查询以及写入性能极佳，但是存储的数据规模有限。MongoDB就像高铁，在处理货物（数据）的功能上强于 Redis，同时能承载的数据量远高于Redis，但是查询及写入的效率不及 Redis。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git笔记</title>
    <link href="/post/d9283bc6.html"/>
    <url>/post/d9283bc6.html</url>
    
    <content type="html"><![CDATA[<p>不再过多赘述一些git的基础，主要记录一些常用的内容。</p><span id="more"></span><h1 id="git笔记">git笔记</h1><h3 id="重命名">重命名🚲</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git mv 旧名称 新名称<br></code></pre></div></td></tr></table></figure><h3 id="log">log🦔</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">让每次commit的<span class="hljs-built_in">log</span>变为一行</span><br>git log --oneline<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示离当前最近的3次commit的<span class="hljs-built_in">log</span></span><br>git log -n3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示所有<span class="hljs-built_in">log</span></span><br>git log --all<br><span class="hljs-meta prompt_"># </span><span class="language-bash">以图示的形式显示<span class="hljs-built_in">log</span></span><br>git log --graph<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注：上述四种可以组合起来使用</span><br></code></pre></div></td></tr></table></figure><h3 id="git分析">.git分析🏜️</h3><p>我们每一次创建使用git时，都要先使用<code>git init</code>生成一个<code>.git</code> 文件</p><p>主要分析以下文件：HEAD、config、refs、objects</p><ul><li>HEAD</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> HEAD</span><br>ref: refs/heads/master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">HEAD标识当前HEAD指针指向的位置</span><br></code></pre></div></td></tr></table></figure><ul><li><p>config</p><p><code>config</code> 文件中保存一些配置信息</p></li><li><p>refs</p><p>refs中有两个文件：heads和tags</p><ul><li><p>heads存放当前所有的分支（开发空间）</p></li><li><p>tags存放当前所有的里程碑（开发节点）</p></li></ul></li><li><p>objects</p><p>比如下面场景，可以发现objects里存放着对象的哈希值：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>2d/  4b/  7a/  7e/  info/  pack/<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> 2d</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>af48b0ad1bb55884b00ab716f96985bd0aa25c<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git cat-file -t 2daf48b0ad1bb55884b00ab716f96985bd0aa25c</span><br>commit<br></code></pre></div></td></tr></table></figure><ul><li>git查看对象类型和内容：</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git cat-file -t(看类型) 哈希值 <br>git cat-file -p(看内容) 哈希值<br></code></pre></div></td></tr></table></figure><h3 id="git文件组织模式">git文件组织模式🤹🏻</h3><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220526002402886.png" style="zoom:50%;" /></p><p>一个commit只对应一棵树，文件夹是一棵树，blob是文件，blob只看内容不看文件名，只要文件内容相同就是一个blob。</p><h3 id="commit操作">commit操作⚜️</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改commit的message</span><br>git rebase -i 哈希值 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改对应的pick为r</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并commit指令</span><br>git rebase -i 哈希值 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改对应的pick为s</span><br></code></pre></div></td></tr></table></figure><h3 id="差异比较">差异比较🪂</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">比较HEAD和暂存区差异:</span><br>git diff --cached<br><span class="hljs-meta prompt_"># </span><span class="language-bash">比较工作区和暂存区差异:</span><br>git diff<br>git diff -- 文件名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果HEAD和暂存区都变了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">变更暂存区内容，使其和HEAD一致:</span><br>git reset HEAD <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>git reset HEAD -- 文件名1 文件名2 ...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果工作区和暂存区都变了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">变更工作区内容，使其和暂存区一致:</span> <br>git checkout -- 文件名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">变更暂存区内容，使其和工作区一致:</span><br>git reset HEAD <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>git reset HEAD -- 文件名1 文件名2 ...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">消除最近几次commit</span><br>git reset --hard 哈希值<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看指定文件间差异</span><br>git diff branch1 branch2 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>git diff branch1 branch2 -- 文件名<br></code></pre></div></td></tr></table></figure><h3 id="保存当前状态">保存当前状态🤴🏻</h3><figure class="highlight avrasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-meta"># 保存当前状态，并且恢复到上一次commit的时候</span><br>git stash<br><span class="hljs-meta"># 查看当前stash</span><br>git stash list<br><span class="hljs-meta"># 恢复，但不弹出(git stash list不会删除)</span><br>git stash apply<br><span class="hljs-meta"># 恢复，但弹出(git stash list会删除)</span><br>git stash <span class="hljs-keyword">pop</span><br></code></pre></div></td></tr></table></figure><h3 id="gitignore用法">.gitignore用法🦹🏻</h3><p>在.gitignore中写入相应格式，则git不会将其进行管理，举个例子：Java的.gitignore文件</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Compiled class file</span><br>*.class<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Log file</span><br>*.log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">BlueJ files</span><br>*.ctxt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Mobile Tools <span class="hljs-keyword">for</span> Java (J2ME)</span><br>.mtj.tmp/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Package Files <span class="hljs-comment">#</span></span><br>*.jar<br>*.war<br>*.nar<br>*.ear<br>*.zip<br>*.tar.gz<br>*.rar<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br>hs_err_pid*<br>replay_pid*<br></code></pre></div></td></tr></table></figure><h3 id="开发流程">开发流程👑</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在github建立仓库</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">与远端建立连接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里的origin可以随意起名</span><br>git remote add origin xxx/xxx.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地进行代码编写</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从本地进行push</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 如果push所有分支</span><br>git push origin --all<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 如果push一个分支（以master分支为例）</span><br>git push origin master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要是报错</span><br> ! [rejected]        master -&gt; master (fetch first)<br>error: failed to push some refs to &#x27;github.com:xxx/xxx.git&#x27;<br>hint: Updates were rejected because the remote contains work that you do<br>hint: not have locally. This is usually caused by another repository pushing<br>hint: to the same ref. You may want to first integrate the remote changes<br>hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.<br>hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">说明远端本身就有内容（可能是创建仓库时候创建了README、gitignore、license之类的）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时需要先pull或者先fetch+merge</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. pull</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. fetch+merge</span><br>git fetch origin<br>git merge --allow-unrelated-histories origin/master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时再进行push即可</span><br>git push origin --all(master)<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要是多人协作开发，一人一个分支</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">远端已经建立了多个分支，比如我要做的分支名为 mybranch</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">clone</span>远端仓库</span><br>git clone xxx/xxx.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前所有分支(显示本地和远端)</span><br>git branch -av<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建并切换到一个自己的分支</span><br>git checkout -b xxx/xxx(自己本地分支名) origin/mybranch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地进行代码编写</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提交代码即可</span><br>git add -u<br>git commit -m&quot;xxx&quot;<br>git push<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">不同人修改不同文件</span><br>git pull<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地进行代码编写</span><br>git push<br><span class="hljs-meta prompt_"># </span><span class="language-bash">报错</span><br>git fetch origin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">和当前远端的mybranch进行合并</span><br>git merge origin/mybrach<br>git push<br><span class="hljs-meta prompt_"># </span><span class="language-bash">成功push</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不同人修改相同文件不同区域</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同上</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git merge 可以自动进行合并</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不同人修改相同文件相同区域</span><br>git pull<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地进行代码编写</span><br>git push<br><span class="hljs-meta prompt_"># </span><span class="language-bash">报错</span><br>git pull<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开有问题的文件，git用&gt;&gt;&gt;&gt;HEAD之类的符号标识出了冲突的地方，进行修改即可</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">提交代码即可</span><br>git add -u<br>git commit -m&quot;xxx&quot;<br>git push<br></code></pre></div></td></tr></table></figure><p>如果和远端发生了冲突（本地编写代码后git push 报错），可以先进行gitpull ，如果git可以帮助你来修复，打开相应文件，git会标识出冲突的地方；如果git不能帮助你修复，则可以gitstatus，可以看到当前状态，你可以和其他人协商，然后一个一个文件进行 gitadd 或 git rm即可。</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL必知必会笔记（二）</title>
    <link href="/post/1171445a.html"/>
    <url>/post/1171445a.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对<ahref="https://time.geekbang.org/column/intro/100029501">SQL必知必会</a>的内容进行总结</p><span id="more"></span><h1 id="sql必知必会笔记二">SQL必知必会笔记（二）</h1><h3 id="索引">索引🎳</h3><ul><li><p>索引的价值是帮我们从海量数据中找到想要的数据，如果数据量少，那么是否使用索引对结果的影响并不大。另外，当数据重复度大，比如高于10% 的时候，也不需要对这个字段使用索引。</p></li><li><p>从功能逻辑上说，索引主要有 4种，分别是普通索引、唯一索引、主键索引和全文索引。</p><p>普通索引是基础的索引，没有任何约束，主要用于提高查询效率。</p><p>唯一索引就是在普通索引的基础上增加了数据唯一性的约束，在一张数据表里可以有多个唯一索引。</p><p>主键索引在唯一索引的基础上增加了不为空的约束，也就是 NOTNULL+UNIQUE，一张表里最多只有一个主键索引。</p><p>全文索引用的不多，MySQL自带的全文索引只支持英文。我们通常可以采用专门的全文搜索引擎，比如ES(ElasticSearch)和 Solr。</p></li><li><p>按照物理实现方式，索引可以分为 2种：聚集索引和非聚集索引。我们也把非聚集索引称为二级索引或者辅助索引。</p><p>聚集索引可以按照主键来排序存储数据，这样在查找行的时候非常有效。聚集索引指表中数据行按索引的排序方式进行存储，对查找行很有效。只有当表包含聚集索引时，表内的数据行才会按找索引列的值在磁盘上进行物理排序和存储。每一个表只能有一个聚集索引，因为数据行本身只能按一个顺序存储。</p><p>在数据库系统会有单独的存储空间存放非聚集索引，这些索引项是按照顺序存储的，但索引项指向的内容是随机存储的。也就是说系统会进行两次查找，第一次先找到索引，第二次找到索引对应的位置取出数据行。非聚集索引不会把索引指向的内容像聚集索引一样直接放到索引的后面，而是维护单独的索引表（只维护索引，不维护索引指向的数据），为数据检索提供方便。</p><ol type="1"><li>聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储顺序。</li><li>一个表只能有一个聚集索引，因为只能有一种排序存储的方式，但可以有多个非聚集索引，也就是多个索引目录提供数据检索。</li><li>使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。</li></ol></li><li><p>按照字段个数进行划分，索引可以分成单一索引和联合索引。</p><p>索引列为一列时为单一索引；多个列组合在一起创建的索引叫做联合索引。</p><p>联合索引存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。即如果设置索引为(x,y,z)，而我的查询条件是y（不与(x,y,z) 最左匹配），此时联合查询就会失效。</p><p>查询“z=7 AND y=8 AND x=9”的时候，如果三个字段 x、y、z在条件查询的时候是乱序的，但采用的是等值查询（=）或者是 IN 查询，那么MySQL 的优化器可以自动帮我们调整为可以使用联合索引的形式。</p><p>当我们查询“x=9 AND y&gt;8 AND z=7”的时候，如果建立了 (x,y,z)顺序的索引，这时候 z 是用不上索引的。这是因为 MySQL在匹配联合索引最左前缀的时候，如果遇到了范围查询，比如（&lt;）（&gt;）和between 等，就会停止匹配。索引列最多作用于一个范围列，对于后面的 Z来说，就没法使用到索引了。</p></li><li><p>Hash索引 VS B+索引：</p><ol type="1"><li>Hash 索引不能进行范围查询，而 B+ 树可以。这是因为 Hash索引指向的数据是无序的，而 B+ 树的叶子节点是个有序的链表。</li><li>Hash索引不支持联合索引的最左侧原则（即联合索引的部分索引无法使用），而 B+树可以。对于联合索引来说，Hash 索引在计算 Hash值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</li><li>Hash 索引不支持 ORDER BY 排序，因为 Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而 B+树索引数据是有序的，可以起到对该字段 ORDER BY排序优化的作用。同理，我们也无法用 Hash 索引进行模糊查询，而 B+ 树使用LIKE 进行模糊查询的时候，LIKE 后面前模糊查询（比如 %开头）的话就可以起到优化作用。</li></ol><p>对于等值查询来说，通常 Hash索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。</p><p>B+ 树索引的使用面会更广，不过也有一些场景采用 Hash索引效率更高，比如在键值型（Key-Value）数据库中，Redis 存储的核心就是Hash 表。MySQL 中的 Memory 存储引擎支持 Hash存储，如果我们需要用到查询的临时表时，就可以选择 Memory存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，采用Hash 索引是个不错的选择。 MySQL 的 InnoDB 存储引擎还有个“自适应 Hash索引”的功能，就是当某个索引值使用非常频繁的时候，它会在 B+树索引的基础上再创建一个 Hash 索引，这样让 B+ 树也具备了 Hash索引的优点。</p></li><li><p>适合创建索引的情况：</p><ul><li>字段的数值有唯一性的限制，比如用户名</li><li>频繁作为 WHERE 查询条件的字段，尤其在数据表大的情况下</li><li>需要经常 GROUP BY 和 ORDER BY 的列，如果同时有，建立联合索引。</li><li>UPDATE、DELETE 的 WHERE条件列，一般也需要创建索引（更新列与WHERE条件列不是一列）</li><li>DISTINCT 字段需要创建索引</li><li>做多表 JOIN 连接操作时，创建索引需要注意以下的原则<ul><li>连接表的数量尽量不要超过 3 张</li><li>对 WHERE 条件创建索引</li><li>对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致</li></ul></li></ul></li><li><p>不能创建索引的情况：</p><ul><li>WHERE 条件（包括 GROUP BY、ORDERBY）里用不到的字段不需要创建索引</li><li>如果表记录太少，比如少于 1000 个，那么是不需要创建索引的</li><li>字段中如果有大量重复数据，也不用创建索引</li><li>频繁更新的字段不一定要创建索引</li></ul></li><li><p>索引失效：</p><ul><li>索引进行了表达式计算，则会失效</li><li>对索引使用函数，也会造成失效</li><li>在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR后的条件列没有进行索引，那么索引会失效。</li><li>当我们使用 LIKE 进行模糊查询的时候，后面不能是 %</li><li>索引列与 NULL 或者 NOT NULL 进行判断的时候也会失效</li><li>在使用联合索引的时候要注意最左原则</li></ul></li><li><p>索引片是 SQL查询语句在执行中需要扫描的一个索引片段，根据包含的匹配列的数量不同，将索引分成窄索引（比如包含索引列数为1 或 2）和宽索引（包含的索引列数大于2）。需要说明的是，每个非聚集索引保存的数据都会存储主键值，然后通过主键值，来回表查找相应的数据，因此每个索引都相当于包括了主键。【所以如果是非聚集索引窄索引和宽索引在计算时需要+1】</p></li><li><p>回表指的就是数据库根据索引找到了数据行之后，还需要通过主键再次到数据表中读取数据的情况。</p></li><li><p>宽索引可以避免回表的情况发生，通过宽索引将 SELECT中需要用到的列（主键列可以除外）都设置在宽索引中，这样就避免了回表扫描的情况，从而提升SQL 查询效率。</p></li><li><p>过滤因子：在 WHERE条件语句中，每个条件都称为一个谓词，谓词的选择性也等于满足这个条件列的记录数除以总记录数的比例。联合过滤因子有更高的过滤能力，这里还需要注意一个条件，那就是条件列的关联性应该尽量相互独立，否则如果列与列之间具有相关性，联合过滤因子的能力就会下降很多。</p></li><li><p>过滤因子决定了索引片的大小（注意这里不是窄索引和宽索引），过滤因子的条件过滤能力越强，满足条件的记录数就越少，SQL查询需要扫描的索引片也就越小。</p></li><li><p>使得SQL查询效率最大化的设计（三星索引）：</p><ol type="1"><li>在 WHERE条件语句中，找到所有等值谓词中的条件列，将它们作为索引片中的开始列；（最小化碎片，过滤因子降低）</li><li>将 GROUP BY 和 ORDER BY中的列加入到索引中；（避免排序，索引自带排序）</li><li>将 SELECT 字段中剩余的列加入到索引片中。（避免回表）</li></ol></li><li><p>三星索引的弊端：</p><ul><li>采用三星索引会让索引片变宽，这样每个页能够存储的索引数据就会变少，从而增加了页加载的数量。</li><li>增加了索引维护的成本。</li></ul></li><li><p>自适应 Hash 索引（系统会根据情况自动完成）</p><p>如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash 表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。</p><p>自适应 Hash索引只保存热数据（经常被使用到的数据），并非全表数据。因此数据量并不会很大，因此自适应Hash 也是存放到缓冲池中，这样也进一步提升了查找效率。</p><p>InnoDB 中的自适应 Hash 相当于“索引的索引”，采用 Hash 索引存储的是 B+树索引中的页面的地址。采用自适应 Hash 索引目的是方便根据 SQL的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应Hash 索引可以明显提高数据的检索效率。</p></li></ul><h3 id="数据库存储结构">数据库存储结构🎑</h3><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527162015622.png" /></p><ul><li><p>一个页中可以存储多个行记录，数据库管理存储空间的基本单位是页。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527162603016.png" /></p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527165533715.png" /></p><ul><li>在文件头中有两个字段，分别是 FIL_PAGE_PREV 和FIL_PAGE_NEXT，它们的作用相当于指针，分别指向上一个数据页和下一个数据页。<strong>连接起来的页相当于一个双向的链表</strong>，需要说明的是采用链表的结构让数据页之间不需要是物理上的连续，而是逻辑上的连续。</li><li>文件尾的校验方式就是采用 Hash 算法进行校验。</li><li>当有新的记录插入时，会从空闲空间中进行分配用于存储新记录</li></ul><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527170207669.png" /></p><ul><li><p>页目录起到了记录的索引作用，在页中，<strong>记录是以单向链表的形式进行存储的</strong>。在页目录中提供了二分查找的方式，用来提高记录的检索效率。</p><ol type="1"><li>将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li><li>第 1 组，也就是最小记录所在的分组只有 1个记录；最后一组，就是最大记录所在的分组，会有 1-8条记录；其余的组记录数量在 4-8 条之间。这样做的好处是，除了第 1组（最小记录所在组）以外，其余组的记录数会尽量平分。</li><li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为n_owned 字段。</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li></ol><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527180809501.png" /></p><p>页目录存储的是槽，槽相当于分组记录的索引。我们通过槽查找记录，实际上就是在做二分查找。通过对槽从最小到最大记录进行编号，划定二分法的查询范围，并按照（low+high）/2的槽中提取数据与需查询数据比对，判定下一步的最低最高值，如果＞目前槽中数据，则下一步low为当前槽的序号，high为最大记录的槽序号，如果&lt;目前槽中数据，则反之。从而逐步逼近，最终定位到需查询数据对应槽。</p></li></ul></li><li><p>区（Extent）是比页大一级的存储结构，在 InnoDB存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是16KB，所以一个区的大小是 64*16KB=1MB。</p></li><li><p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB 中是连续的 64个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p></li><li><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p></li><li><p>在一棵 B+树中，每个节点都是一个页，每次新建节点的时候，就会申请一个页空间。同一层上的节点之间，通过页的结构构成一个双向的链表（页文件头中的两个指针字段）。非叶子节点，包括了多个索引行，每个索引行里存储索引键和指向下一层页面的页面指针。最后是叶子节点，它存储了关键字和行记录，在节点内部（也就是页结构的内部）记录之间是一个单向的链表，但是对记录进行查找，则可以通过页目录采用二分查找的方式来进行。</p></li></ul><h3 id="缓冲池">缓冲池🌸</h3><p>磁盘 I/O需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS会申请占用内存来作为数据缓冲池，这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行I/O 的时间。要知道，这种策略对提升 SQL语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p>当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做checkpoint的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p><p>如果缓冲池中没有该页数据，读取数据方式：</p><ul><li><p>内存读取</p><p>如果该数据存在于内存中，直接读取即可。【1ms】</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527192120706.png" /></p></li><li><p>随机读取</p><p>如果数据没有在内存中，就需要在磁盘上对该页进行查找。【10ms】</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220527192220693.png" /></p></li><li><p>顺序读取</p><p>批量读取，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘I/O 操作了。</p></li></ul><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528151618933.png" /></p><p>缓冲池的作用就是提升 I/O效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O 操作。</p><p>查看SQL语句查询成本：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进行查询</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SELECT name FROM student <span class="hljs-built_in">where</span> <span class="hljs-built_in">id</span>=1;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看SQL语句查询成本</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SHOW STATUS LIKE <span class="hljs-string">&#x27;last_query_cost&#x27;</span>;</span><br></code></pre></div></td></tr></table></figure><h3 id="锁">锁🐸</h3><ul><li><p>按照锁粒度划分：</p><ul><li>行锁</li><li>页锁</li><li>表锁</li></ul><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528094225897.png" /></p></li><li><p>从数据库管理的角度对锁进行划分</p><ul><li>共享锁 加锁： <code>LOCK TABLE product_comment READ;</code> 解锁：<code>UNLOCK TABLE;</code> 给某一行加锁：<code>SELECT * FROM product_comment WHERE user_id = 912178 LOCK IN SHARE MODE</code></li><li>排它锁 加锁： <code>LOCK TABLE product_comment WRITE;</code> 解锁：<code>UNLOCK TABLE;</code> 给某一行加锁：<code>SELECT * FROM product_comment WHERE user_id = 912178 FOR UPDATE;</code></li><li>意向锁，简单来说就是给更大一级别的空间示意里面是否已经上过锁。如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。同理，事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录，不能对整个表进行全表扫描。</li><li>当有多个事务对同一数据获得读锁的时候，可能会出现死锁的情况。</li><li>避免死锁的方法：<ol type="1"><li>如果事务涉及多个表，操作比较复杂，那么可以尽量一次锁定所有的资源，而不是逐步来获取，这样可以减少死锁发生的概率；</li><li>如果事务需要更新数据表中的大部分数据，数据表又比较大，这时可以采用锁升级的方式，比如将行级锁升级为表级锁，从而减少死锁产生的概率；</li><li>不同事务并发读写多张数据表，可以约定访问表的顺序，采用相同的顺序降低死锁发生的概率。</li></ol></li></ul></li><li><p>从程序员的角度进行划分</p><ul><li><p>乐观锁</p><p>乐观锁（OptimisticLocking）认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者时间戳机制实现。</p><ul><li><p>版本号机制</p><p>在表中设计一个版本字段 version，第一次读的时候，会获取 version字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p></li><li><p>时间戳机制</p><p>在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p></li></ul></li><li><p>悲观锁</p><p>悲观锁（PessimisticLocking）也是一种思想，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528100720437.png" /></p></li><li><p>乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p></li><li><p>悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读- 写和写 - 写的冲突。</p></li><li><p>乐观锁和悲观锁并不是锁，而是锁的设计思想。</p></li></ul></li></ul><h3 id="mvcc">MVCC🏗️</h3><ul><li><p>MVCC是通过数据行的多个版本管理来实现数据库的并发控制，简单来说它的思想就是保存数据的历史版本。这样我们就可以通过比较版本号决定数据是否显示出来，读取数据的时候不需要加锁也可以保证事务的隔离效果。</p><p>MVCC用在已提交读和可重复读的隔离级别下。</p><p>通过 MVCC 可以解决以下几个问题：</p><ol type="1"><li>读写之间阻塞的问题，通过 MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li><li>降低了死锁的概率。这是因为 MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li><li>解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li></ol><p>快照读：快照读读取的是快照数据。不加锁的简单的 SELECT都属于快照读。</p><p>当前读：当前读读取最新数据，而不是历史版本的数据。加锁的SELECT，或者对数据进行增删改都会进行当前读。</p><p>InnoDB中MVCC的实现：</p><ul><li><p>事务版本号：每开启一个事务，我们都会从数据库中获得一个事务ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID大小，我们就可以判断事务的时间顺序。</p></li><li><p>InnoDB的叶子段存储了数据页，数据页中保存了行记录，而在行记录中有一些重要的隐藏字段，如下图所示：</p><ol type="1"><li>db_row_id：隐藏的行ID，用来生成默认聚集索引。如果我们创建数据表的时候没有指定聚集索引，这时InnoDB 就会用这个隐藏 ID来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率。</li><li>db_trx_id：操作这个数据的事务ID，也就是最后一个对该数据进行插入或更新的事务 ID。</li><li>db_roll_ptr：回滚指针，也就是指向这个记录的 Undo Log 信息。</li></ol><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528110000422.png" /></p></li><li><p>Undo Log ：InnoDB 将行记录快照保存在了 Undo Log里，我们可以在回滚段中找到它们</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528110224364.png" /></p><p>回滚指针将数据行的所有快照记录都通过链表的结构串联了起来，每个快照的记录都保存了当时的db_trx_id，也是那个时间点操作这个数据的事务ID。这样如果我们想要找历史快照，就可以通过遍历回滚指针的方式进行查找。</p></li><li><p>Read View：在 MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到Read View 了，它帮我们解决了行的可见性问题。Read View保存了当前事务开启时所有活跃（还没有提交）的事务列表，换个角度你可以理解为Read View 保存了不应该让这个事务看到的其他的事务 ID 列表。</p><p>Read View 中的几个重要属性：</p><ol type="1"><li>trx_ids，系统当前正在活跃的事务 ID 集合。</li><li>low_limit_id，活跃的事务中最大的事务 ID。</li><li>up_limit_id，活跃的事务中最小的事务 ID。</li><li>creator_trx_id，创建这个 Read View 的事务 ID。</li></ol><p>假设当前有事务 creator_trx_id 想要读取某个行记录，这个行记录的事务 ID为 trx_id，那么会出现以下几种情况。</p><p>如果 trx_id &lt; 活跃的最小事务ID（up_limit_id），也就是说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是可见的。</p><p>如果 trx_id &gt; 活跃的最大事务ID（low_limit_id），这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见。</p><p>如果 up_limit_id &lt; trx_id &lt;low_limit_id，说明该行记录所在的事务 trx_id 在目前 creator_trx_id这个事务创建的时候，可能还处于活跃的状态，因此我们需要在 trx_ids集合中进行遍历，如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id还处于活跃状态，不可见。否则，如果 trx_id 不存在于 trx_ids集合中，证明事务 trx_id 已经提交了，该行记录可见。</p></li><li><p>当查询一条记录的时候，系统如何通过多版本并发控制技术找到它：</p><ol type="1"><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>获取 Read View；</li><li>查询得到的数据，然后与 Read View 中的事务版本号进行比较；</li><li>如果不符合 Read View 规则，就需要从 Undo Log 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ol></li><li><p>MVCC 是通过 Undo Log + Read View 进行数据读取，Undo Log保存了历史快照，而 Read View规则帮我们判断当前版本的数据是否可见。</p></li><li><p>在隔离级别为读已提交（Read Commit）时，一个事务中的每一次 SELECT查询都会获取一次 Read View。这时如果 Read View不同，就可能产生不可重复读或者幻读的情况。</p></li><li><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 ReadView。</p><p>但是如果在两个快照读之间存在一个当前读，可能也会出现幻读的情况。</p></li></ul><p>InnoDB 解决幻读方法：</p><ul><li><p>在可重复读的情况下，InnoDB 可以通过 Next-Key 锁 +MVCC来解决幻读问题。</p></li><li><p>快照读用MVCC，当前读用Next-Key。</p></li><li><p>InnoDB 三种行锁的方式：</p><ol type="1"><li>记录锁：针对单个行记录添加锁。</li><li>间隙锁（GapLocking）：可以帮我们锁住一个范围（索引之间的空隙），但不包括记录本身。采用间隙锁的方式可以防止幻读情况的产生。</li><li>Next-Key 锁：帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁 +记录锁，可以解决幻读的问题。</li></ol></li><li><p>在读已提交的情况下，InnoDB只采用记录锁，不能解决幻读问题。</p></li><li><p>对比：</p><p>读已提交：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528113304621.png" /></p><p>出现幻读：事务A会读到新插入的数据，是因为这里使用了记录锁，只锁住了单条记录</p><p>可重复读：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220528113413860.png" /></p><p>这是因为采用了 Next-Key 锁，会将 height&gt;2.08的范围都进行锁定，就无法插入符合这个范围的数据了。然后事务 A重新进行条件范围的查询，就不会出现幻读的情况。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL必知必会笔记（一）</title>
    <link href="/post/2167a882.html"/>
    <url>/post/2167a882.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对<ahref="https://time.geekbang.org/column/intro/100029501">SQL必知必会</a>的内容进行总结</p><span id="more"></span><h1 id="sql必知必会笔记一">SQL必知必会笔记（一）</h1><h3 id="sql语言分类">SQL语言分类🥡</h3><ol type="1"><li>DDL，英文叫做 Data DefinitionLanguage，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用DDL，我们可以创建，删除和修改数据库和表结构。</li><li>DML，英文叫做 Data ManipulationLanguage，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。</li><li>DCL，英文叫做 Data ControlLanguage，数据控制语言，我们用它来定义访问权限和安全级别。</li><li>DQL，英文叫做 Data QueryLanguage，数据查询语言，我们用它查询想要的记录，它是 SQL语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道，因此学会编写正确且高效的查询语句，是学习的重点。</li></ol><h3 id="大小写问题">大小写问题🌵</h3><ol type="1"><li>表名、表别名、字段名、字段别名等都小写；</li><li>SQL 保留字、函数名、绑定变量等都大写。</li></ol><p>Oracle执行SQL语句过程</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202205231433971.png" /></p><p>共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？</p><p>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash值在库缓存（Library Cache）中查找，如果存在 SQL语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。</p><p>如果没有找到 SQL 语句和执行计划，Oracle就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。</p><p>要避免硬解析，尽量使用软解析。在 Oracle中，绑定变量是它的一大特色。绑定变量就是在 SQL语句中使用变量，通过不同的变量取值来改变 SQL的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，并且使用动态SQL 的方式，因为参数不同，会导致 SQL的执行效率不同，因此是否需要绑定变量还需要视情况而定。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select * from player where player_id = 10001;<br>=&gt;<br>select * from player where player_id := player_id;<br></code></pre></div></td></tr></table></figure><h3 id="mysql执行sql语句过程">MYSQL执行SQL语句过程🏵️</h3><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231438888.png" style="zoom:80%;" /></p><p>SQL层结构：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231449401.png"  style="zoom:67%;" /></p><p>因为查询缓存往往效率不高，所以在 MySQL 8.0 之后就抛弃了缓存查询。</p><p>MySQL的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的MySQL 还允许开发人员设置自己的存储引擎。</p><p><strong>不同的 DBMS 的 SQL的执行原理是相通的</strong>，只是在不同的软件中，各有各的实现路径。</p><h3 id="设计数据表原则">设计数据表原则🥒</h3><p>三少一多</p><ol type="1"><li>数据表的个数越少越好</li><li>数据表中的字段个数越少越好</li><li>数据表中联合主键的字段个数越少越好</li><li>使用主键和外键越多越好</li></ol><h3 id="常见约束">常见约束🥶</h3><p>主键约束、外键约束、唯一性约束、非空约束、CHECK约束、DEFAULT约束</p><h3 id="select语句">SELECT语句🥐</h3><ul><li>DISTINCT 需要放到所有列名的前面、DISTINCT其实是对后面所有列名的组合进行去重</li><li><code>SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...</code></li><li>执行顺序：<code>FROM(包括join) &gt; WHERE &gt; GROUP BY &gt; HAVING &gt; SELECT 的字段 &gt; DISTINCT &gt; ORDER BY &gt; LIMIT</code></li><li>在 SELECT语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在SQL 的执行过程中，对于我们来说是不可见的。</li><li>在 MySQL InnoDB存储引擎中，<code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>。如果有WHERE 子句，则是对所有符合筛选条件的数据行进行统计；如果没有 WHERE子句，则是对数据表的数据行数进行统计。</li><li><code>COUNT(*) = COUNT(1) &gt; COUNT(字段)</code></li><li>如果要统计<code>COUNT(*)</code>，尽量在数据表上建立二级索引，系统会自动采用<code>key_len</code>小的二级索引进行扫描，这样当我们使用<code>SELECT COUNT(*)</code>的时候效率就会提升，有时候可以提升几倍甚至更高。</li><li>函数：</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231610483.png" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231610988.png" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231610043.png" style="zoom:67%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205231610814.png" style="zoom:67%;" /></p><ul><li><p>日期格式：<code>"yy-mm-dd hh-mm-ss"</code>举例：<code>"2022-05-23 16:08:45"</code></p></li><li><p><code>SELECT EXTRACT(YEAR FROM '2022-05-23')</code>，运行结果为<code>2022</code></p></li><li><p><code>SELECT CAST(123.123 AS DECIMAL(8,2))</code>，运行结果为<code>123.12</code> ，<code>DECIMAL(8,2)</code>代表的是精度为 8位（整数加小数位数最多为 8 位），小数位数为 2 位的数据类型</p></li><li><p><code>SELECT COALESCE(null,1,2)</code>，运行结果为<code>1</code></p></li><li><p><code>WHERE DATE(birthdate)&gt;'2022-05-23'</code>这样才是正确的，不能直接比较时间</p></li><li><p>MAX 和 MIN函数也可以用于字符串类型数据的统计，如果是英文字母，则按照 A—Z的顺序排列，越往后，数值越大。如果是汉字则按照全拼拼音进行排列：<code>SELECT MIN(CONVERT(name USING gbk)),MAX(CONVERT(name USING gbk)) FROM heros</code></p></li><li><p>去掉重复操作再使用聚集函数：<code>SELECT ROUND(AVG(DISTINCT hp_max), 2) FROM heros</code></p></li><li><p>当查询字段进行了索引时，主表 A 大于从表 B，使用 IN子查询效率更高；相反主表 A 小于从表 B 时，使用 EXISTS 子查询效率更高</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM A WHERE cc IN (SELECT cc FROM B)<br><br>SELECT * FROM A WHERE EXIST (SELECT cc FROM B WHERE B.cc=A.cc)<br></code></pre></div></td></tr></table></figure><p>如果表A大于表B，IN可以使用表B的索引；如果表B大于表A，EXIST可以使用表A的索引</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT player_id, a.team_id FROM player as a, team as b WHERE a.team_id = b.team_id<br><br># 等价于<br><br>SELECT player_id, a.team_id FROM player as a NATURAL JOIN team <br><br># 等价于<br><br>SELECT player_id,a.team_id FROM player as a JOIN team ON a.team_id = team.team_id<br><br># 等价于<br><br>SELECT player_id, a.team_id FROM player as a JOIN team USING(team_id)<br></code></pre></div></td></tr></table></figure><ul><li>笛卡尔积： <code>CROSS JOIN</code></li></ul><h3 id="存储过程">存储过程👋🏻</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DELIMITER //<br>CREATE PROCEDURE `add_num`(IN n INT)<br>BEGIN<br>       DECLARE i INT;<br>       DECLARE sum INT;<br>       <br>       SET i = 1;<br>       SET sum = 0;<br>       WHILE i &lt;= n DO<br>              SET sum = sum + i;<br>              SET i = i +1;<br>       END WHILE;<br>       SELECT sum;<br>END //<br>DELIMITER ;<br></code></pre></div></td></tr></table></figure><p>上述是一个存储过程，我执行 <code>CALL add_num(100)</code>，便可以得到5050的答案</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20220525091804568.png" style="zoom:67%;" /></p><p>流控制语句：</p><ul><li><p>BEGIN…END：BEGIN…END中间包含了多个语句，每个语句都以（;）号为结束符。</p></li><li><p>DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END语句中间，而且需要在其他语句使用之前进行变量的声明。</p></li><li><p>SET：赋值语句，用于对变量进行赋值。</p></li><li><p>SELECT…INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</p></li><li><p>IF…THEN…ENDIF：条件判断语句，我们还可以在 IF…THEN…ENDIF 中使用ELSE 和 ELSEIF 来进行条件判断。</p></li><li><p>CASE：CASE 语句用于多条件的分支判断，使用的语法是下面这样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CASE <br>WHEN expression1 THEN ...<br>WHEN expression2 THEN ...<br>...<br>    ELSE <br>    --ELSE 语句可以加，也可以不加。加的话代表的所有条件都不满足时采用的方式。<br>END<br></code></pre></div></td></tr></table></figure></li><li><p>LOOP、LEAVE 和 ITERATE：LOOP 是循环语句，使用 LEAVE可以跳出循环，使用 ITERATE则可以进入下一次循环。如果你有面向过程的编程语言的使用经验，你可以把LEAVE 理解为 BREAK，把 ITERATE 理解为CONTINUE。</p></li><li><p>REPEAT…UNTIL…ENDREPEAT：这是一个循环语句，首先会执行一次循环，然后在 UNTIL中进行表达式的判断，如果满足条件就退出，即 ENDREPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p></li><li><p>WHILE…DO…END WHILE：这也是循环语句，和 REPEAT循环不同的是，这个语句需要先进行条件判断，如果满足条件就进行循环，如果不满足条件就退出循环。</p></li></ul><h3 id="事务">事务🏯</h3><p>原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</p><p>MySQL 中 completion_type 参数的作用：</p><ul><li><p>completion=0，这是默认情况。也就是说当我们执行 COMMIT的时候会提交事务，在执行下一个事务时，还需要我们使用 START TRANSACTION或者 BEGIN 来开启。</p></li><li><p>completion=1，这种情况下，当我们提交事务后，相当于执行了 COMMITANDCHAIN，也就是开启一个链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;关羽&#x27;;<br>COMMIT;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>ROLLBACK;<br>SELECT * FROM test;<br><br># 结果是 关羽<br># 上述结果是因为ROLLBACK到上一次COMMIT的地方<br><br>CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;关羽&#x27;;<br>COMMIT;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>ROLLBACK;<br>SELECT * FROM test;<br><br># 结果是 关羽、张飞<br># 上述结果是因为两条‘张飞’的插入操作的事务都是自动提交，相当于两个事务，ROLLBACK并没有起作用<br><br>CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;<br>SET @@completion_type = 1;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;关羽&#x27;;<br>COMMIT;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>ROLLBACK;<br>SELECT * FROM test;<br><br># 结果是 关羽<br># 上述结果是因为设置completion_type，以下所有指令都在一个链式事务中，两条‘张飞’的插入操作是在一个事务中<br></code></pre></div></td></tr></table></figure></li><li><p>completion=2，这种情况下 COMMIT=COMMIT ANDRELEASE，也就是当我们提交后，会自动与服务器断开连接。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;关羽&#x27;;<br>BEGIN;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>INSERT INTO test SELECT &#x27;张飞&#x27;;<br>INSERT INTO test SELECT &#x27;刘备&#x27;;<br>COMMIT;<br>SELECT * FROM test;<br><br># 结果是 关羽、张飞、刘备<br># 上述结果说明事务中如果有错误，如果执行COMMIT，会将事务中正确的部分进行执行<br></code></pre></div></td></tr></table></figure><p>事务并发存在异常</p><ul><li>脏读：读到了其他事务还没有提交的数据。</li><li>不可重复读：对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。</li><li>幻读：事务 A 根据条件查询得到了 N 条数据，但此时事务 B更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A再次进行查询的时候发现会有 N+M 条数据，产生了幻读。</li></ul><p>注：</p><ul><li>不可重复读是同一条记录的内容被修改了，重点在于UPDATE或DELETE</li><li>幻读是查询某一个范围的数据行变多了或者少了，重点在于INSERT</li></ul><h3 id="游标">游标☃️</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE PROCEDURE `calc_hp_max`()<br>BEGIN<br>       -- 创建接收游标的变量<br>       DECLARE hp INT;  <br> <br>       -- 创建总数变量 <br>       DECLARE hp_sum INT DEFAULT 0;<br>       -- 创建结束标志变量  <br>       DECLARE done INT DEFAULT false;<br>       -- 1. 定义游标     <br>       DECLARE cur_hero CURSOR FOR SELECT hp_max FROM heros;<br>       -- 指定游标循环结束时的返回值  <br>       DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true;  <br>       <br>       -- 2. 开启游标<br>       OPEN cur_hero;<br>       read_loop:LOOP<br>       -- 3. 从游标中取得数据<br>       FETCH cur_hero INTO hp;<br>       -- 判断游标的循环是否结束  <br>       IF done THEN  <br>           LEAVE read_loop;<br>       END IF; <br>       <br>       SET hp_sum = hp_sum + hp;<br>       END LOOP;<br>       -- 4. 关闭游标<br>       CLOSE cur_hero;<br>       SELECT hp_sum;<br>       -- 5. 释放游标<br>       DEALLOCATE PREPARE cur_hero;<br>END<br></code></pre></div></td></tr></table></figure><p>游标实际上是面向过程的思维方式，与面向集合的思维方式不同的地方在于，游标更加关注“如何执行”。我们可以通过游标更加精细、灵活地查询和管理想要的数据行。</p><h3 id="数据库调优">数据库调优🥂</h3><p>从以下维度进行分析：</p><ul><li><p>选择适合的 DBMS</p></li><li><p>优化表设计</p><ol type="1"><li>表结构要尽量遵循第三范式的原则。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新，插入和删除数据时等异常情况的发生。</li><li>如果分析查询应用比较多，尤其是需要进行多表联查的时候，可以采用反范式进行优化。反范式采用空间换时间的方式，通过增加冗余字段提高查询的效率。</li><li>表字段的数据类型选择，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用CHAR 类型；当长度不固定时，通常采用 VARCHAR 类型。</li></ol></li><li><p>优化逻辑查询</p><ol type="1"><li>EXISTS 子查询和 IN子查询的时候，会根据小表驱动大表的原则选择适合的子查询</li><li>在 WHERE子句中会尽量避免对字段进行函数运算，它们会让字段的索引失效</li></ol></li><li><p>优化物理查询（索引）</p><ol type="1"><li>如果数据重复度高，就不需要创建索引。通常在重复度超过 10%的情况下，可以不创建这个字段的索引。比如性别这个字段（取值为男和女）。</li><li>要注意索引列的位置对索引使用的影响。比如我们在 WHERE子句中对索引字段进行了表达式的计算，会造成这个字段的索引失效。</li><li>要注意联合索引对索引使用的影响。我们在创建联合索引的时候会对多个字段创建索引，这时索引的顺序就很重要了。比如我们对字段x, y, z 创建了索引，那么顺序是 (x,y,z) 还是(z,y,x)，在执行的时候就会存在差别。</li><li>要注意多个索引对索引使用的影响。索引不是越多越好，因为每个索引都需要存储空间，索引多也就意味着需要更多的存储空间。此外，过多的索引也会导致优化器在进行评估的时候增加了筛选出索引的计算时间，影响评估的效率。</li></ol></li><li><p>使用 Redis 或 Memcached 作为缓存</p><p>将常用的数据直接放到内存中，就会大幅提升查询的效率</p><p>通常我们对于查询响应要求高的场景（响应时间短，吞吐量大），可以考虑内存数据库，毕竟术业有专攻。传统的RDBMS都是将数据存储在硬盘上，而内存数据库则存放在内存中，查询起来要快得多。不过使用不同的工具，也增加了开发人员的使用成本。</p></li><li><p>库级优化</p><p>如果读和写的业务量都很大，并且它们都在同一个数据库服务器中进行操作，那么数据库的性能就会出现瓶颈，这时为了提升系统的性能，优化用户体验，我们可以采用读写分离的方式降低主数据库的负载，比如用主数据库（master）完成写操作，用从数据库（slave）完成读操作。</p><p>当数据量级达到亿级以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。</p><p><strong>采用垂直分表的形式，就是将一张数据表分拆成多张表，采用水平分表的方式，就是将单张数据量大的表按照某个属性维度分成不同的小表。</strong></p><p>如果数据库中的数据表过多，可以采用垂直分库的方式，将关联的数据表部署在一个数据库上。如果数据表中的列过多，可以采用垂直分表的方式，将数据表分拆成多张，把经常一起使用的列放到同一张表里。</p><p>如果数据表中的数据达到了亿级以上，可以考虑水平切分，将大的数据表分拆成不同的子表，每张表保持相同的表结构。</p></li></ul><p>总结：</p><ul><li>选择比努力更重要</li><li>把 SQL 查询优化分成两个部分，逻辑查询优化和物理查询优化</li><li>通过外援来增强数据库的性能</li></ul><h3 id="反范式设计">反范式设计🌚</h3><p>越高阶的范式得到的数据表越多，数据冗余度越低。但有时候，我们在设计数据表的时候，还需要为了性能和读取效率违反范式化的原则。反范式就是相对范式化而言的，换句话说，就是允许少量的冗余，通过空间来换时间。</p><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。<strong>当冗余信息有价值或者能大幅度提高查询效率的时候，我们就可以采取反范式的优化。此外反范式优化也常用在数据仓库的设计中</strong>，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><p>数据仓库 VS 数据库：</p><ol type="1"><li>数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据；</li><li>数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据；</li><li>数据库设计需要尽量避免冗余，但为了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库期末总结</title>
    <link href="/post/48d4ae84.html"/>
    <url>/post/48d4ae84.html</url>
    
    <content type="html"><![CDATA[<h1 id="数据库系统期末总结">数据库系统期末总结</h1><p>主要针对数据库系统期末复习中的一些重点进行归纳总结</p><span id="more"></span><h3 id="数据库系统概述">数据库系统概述🐲</h3><ul><li><p>三级模式：</p><ul><li>外模式、用户模式、子模式、局部模式、（视图）</li><li>逻辑模式、概念模式、全局模式、（模式）</li><li>内模式、物理模式、存储模式</li></ul></li><li><p>两层映像：</p><ul><li>E-C ： 外 → 逻辑</li><li>C-I ： 逻辑 → 内</li></ul></li><li><p>两个独立性：</p><ul><li>逻辑数据独立性：当逻辑模式改变，不用改外模式，改 E-I 即可</li><li>物理数据独立性：当内模式改变，不用改逻辑模式，改 C-I 即可</li></ul></li><li><p>模式：对数据的抽象</p></li><li><p>模型：对模式的抽象</p></li></ul><h3 id="关系数据模型">关系数据模型🦴</h3><ul><li>主属性：包含在任意一个<strong>候选码</strong>中的属性</li><li>主码：候选码中的一个</li><li>两个关系通常是通过<strong>外码</strong>联系起来的</li><li><span class="math inline">\(\sigma\)</span> 操作的优先级： 非 &gt;<span class="math inline">\(\wedge\)</span> &gt; <spanclass="math inline">\(\vee\)</span></li><li><span class="math inline">\(\pi\)</span> 操作自带去重</li><li>完整性：<ul><li>实体完整性：主码不能为空</li><li>参数完整性：外码必须有对应值或空值</li><li>用户自定义完整性</li></ul></li><li><spanclass="math inline">\(\theta\)</span>连接<strong>不会去重</strong>、等值连接<strong>不会去重</strong>、自然连接<strong>会去重</strong></li><li>重命名：<span class="math inline">\(\rho\)</span></li><li><span class="math inline">\(R ÷ S=\pi_{R-S}(R)-\pi_{R-S}((\pi_{R-S}(R)×S)-R)\)</span></li><li>外连接是为了防止在连接（<spanclass="math inline">\(\theta\)</span>连接）操作后会出现元组数据的丢失的情况（空值）</li><li>关系演算：<span class="math inline">\(\{ t|P(t)\}\)</span>，P是一个谓语</li><li>优先级： ( ) &gt; <span class="math inline">\(\theta\)</span> &gt;<span class="math inline">\(\exists\)</span> &gt; <spanclass="math inline">\(\forall\)</span> &gt; 非 &gt; <spanclass="math inline">\(\wedge\)</span> &gt; <spanclass="math inline">\(\vee\)</span> （这里的 <spanclass="math inline">\(\theta\)</span> 是指比较运算符）</li><li>关系域演算：<span class="math inline">\(\{ &lt;x_1,x_2...x_n&gt; |P(x_1,x_2...x_n) \}\)</span></li></ul><h3 id="sql">SQL🦐</h3><ul><li><p><code>insert into table_name values (a,b,c)</code></p></li><li><p><code>insert into table_name 子查询</code></p></li><li><p><code>asc</code>为升序（默认），<code>desc</code>为降序</p></li><li><p><code>update table_name set a=b where c=d</code></p></li><li><div class="hljs code-wrapper"><pre class="mysql"><code>  select 字段列表[字段别名]   from 数据源  [where条件字句]  [group by 字句]  [having 字句]  [order by 字句]  [limit 字句]</code></pre></div></li><li><p>表达式 (not) in 子查询</p></li><li><p>子查询只能外层向内层传参数</p></li><li><p>表达式 <span class="math inline">\(\theta\ some/all\)</span>子查询</p></li><li><p>in <span class="math inline">\(\leftrightarrow\)</span>=some、not in <span class="math inline">\(\leftrightarrow\)</span>&lt;&gt;all</p></li><li><p>子查询 union (all) / intersect (all) / except (all) ，其中带有<strong>all 不删除重复元组</strong></p></li><li><p>任何<strong>没有出现</strong>在groupby子句中的属性如果出现在select子句中的话，它<strong>只能出现在聚集函数的内部</strong>，否则这样的查询就是错误的</p></li><li><p>只有 COUNT 不忽略 null</p></li><li><p><span class="math inline">\(from\ table_{name1}\ (natural)\inner\ join / left\ outer\ join / right\ outer\ join / full\ outer\join\ table_{name2}\ (on ...)\)</span></p></li><li><p><span class="math inline">\(create\ view\ view_{name}\as\)</span> 子查询</p></li><li><p>不能更新的view：</p><ul><li>select 目标列包含聚集函数</li><li>select 子句使用distinct</li><li>包含group by</li><li>包含经算术表达式计算出的列</li><li>由单个表的列组成但未包含主键</li></ul></li></ul><h3 id="概念数据库设计">概念数据库设计🪂</h3><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202205201502437.png" /></p><h3 id="逻辑数据库设计">逻辑数据库设计🚍</h3><ul><li><span class="math inline">\(armstrong公理\)</span>：<ul><li><span class="math inline">\(Y\subseteq X \subseteq U,则X →Y\)</span></li><li><span class="math inline">\(X \rightarrow Y \in F.Z \subseteq U,则XZ\rightarrow YZ\)</span></li><li><span class="math inline">\(X \rightarrow Y,Y \rightarrow Z,则X\rightarrow Z\)</span></li><li><span class="math inline">\(X \rightarrow Y,X\rightarrowZ,则X\rightarrow YZ\)</span></li><li><span class="math inline">\(X\rightarrow Y,WY\rightarrowZ,则XW\rightarrow Z\)</span></li><li>$XY,Z Y,则XZ $</li></ul></li><li>最小覆盖（最小依赖集）计算：<ul><li>将F中的任意函数依赖 <span class="math inline">\(X →Y\)</span>替换为右部仅包含一个属性的函数依赖</li><li>删除左部的冗余属性</li><li>删除冗余函数依赖</li></ul></li><li>NF总结<ul><li>1NF 保证分量不可分</li><li>2NF保证只有主键才能推出其他，消除非主属性对<strong>候选键</strong>的部分函数依赖</li><li>3NF 消除非主属性对<strong>候选键</strong>的传递函数依赖</li><li>BCNF保证主属性完全函数依赖于<strong>候选键</strong>、或者满足1NF并且最小覆盖的左部都是<strong>候选键</strong></li></ul></li><li>识别无损连接分解：画表格</li><li>识别函数依赖保持：函数依赖的并集是否可以覆盖F</li><li>关系模式分解为3NF：将每一个函数依赖单独组成一个关系，然后把左部相同的进行合并【保持依赖】</li><li>关系模式分解为BCNF：将左侧不含候选键的函数依赖单独组成一个关系，将包含候选键的组成一关系【无损连接】</li></ul><h3 id="物理数据库设计">物理数据库设计🥡</h3><ul><li>索引文件组织方式：<ul><li>排序索引文件</li><li>散列索引文件</li></ul></li><li><span class="math inline">\(create\ index\ index_{name}\ on\table_{name}(a,b,c)\)</span></li><li>稠密索引 VS 稀疏索引<ul><li>稠密索引：索引文件中包含了主文件对应字段的所有不同值</li><li>稀疏索引：索引文件中包含了主文件对应字段的部分不同值</li></ul></li><li>主索引 VS 辅助索引<ul><li>主索引通常是对每一存储块有一个索引项（稀疏索引）</li><li>辅助索引是稠密索引</li><li>一个主文件仅可以有一个主索引，但可以有多个辅助索引</li><li>主索引通常建立于主码/排序码上面；辅助索引建立于其他属性上面</li><li>主索引可以重新组织主文件数据，但辅助索引不能改变主文件数据</li></ul></li><li>聚簇索引 VS 非聚簇索引<ul><li>聚簇索引：索引中邻近的记录在主文件中也是临近存储的</li><li>非聚簇索引：索引中邻近的记录在主文件中不一定是邻近存储的</li><li>主索引是聚簇索引、辅助索引是非聚簇索引</li></ul></li></ul><h3 id="数据库存储">数据库存储🪢</h3><ul><li>CPU 到 主存之间按存储字访问，主存 到 外存之间按块/IO访问</li><li>操作系统对数据组织：FAT（文件分配表） -- 目录（文件夹） --磁盘块/簇</li><li>数据库中表所占磁盘块的分配方法：<ul><li>连续分配 【访问困难】</li><li>链接分配 【访问速度慢】</li><li>按簇分配 (簇是若干连续的磁盘块,簇之间靠指针连接)</li><li>索引分配(索引块中存放指向实际data块的指­针)</li></ul></li><li>（主）文件组织方法：<ul><li>无序记录文件（堆文件）：数据库重组是通过移走被删除的记录使有效记录连续存放，从而回收那些由删除记录而产生的未利用空间</li><li>有序记录文件（排序文件）：数据库重组是将溢出文件合并到主文件中，并恢复主文件中的记录顺序</li><li>散列文件</li><li>聚簇文件</li></ul></li></ul><h3 id="索引结构">索引结构🧆</h3><ul><li><p>B+树</p><ul><li>插入：分裂</li><li>分裂后增加父节点中的指针和键（右节点的第一个值）</li><li>删除：合并</li><li>合并后删除父节点中的指针和键</li></ul></li><li><p>可扩展散列：每次增加两倍</p></li><li><p>线性散列</p><ul><li><p>位是从右端（低位）开始取</p></li><li><p>n：当前的桶数、r：当前散列表中的记录总数、要求r&lt;=1.7n</p></li><li><table><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">00</td><td style="text-align: center;">00</td><td style="text-align: center;">000</td><td style="text-align: center;">000</td><td style="text-align: center;">...</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">01</td><td style="text-align: center;">01</td><td style="text-align: center;">001</td><td style="text-align: center;">001</td><td style="text-align: center;">...</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">10</td><td style="text-align: center;">10</td><td style="text-align: center;">010</td><td style="text-align: center;">010</td><td style="text-align: center;">...</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">11</td><td style="text-align: center;">011</td><td style="text-align: center;">011</td><td style="text-align: center;">...</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">100</td><td style="text-align: center;">100</td><td style="text-align: center;">...</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">101</td><td style="text-align: center;">...</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">...</td></tr></tbody></table></li></ul></li></ul><h3 id="查询执行">查询执行👺</h3><ul><li><p>连接</p><ul><li>M ≥ 3（考虑输出）<ul><li><span class="math inline">\(B_R+B_R × B_S\)</span></li></ul></li><li>$M ≥ B_R+B_S $<ul><li><span class="math inline">\(B_R+B_S\)</span></li></ul></li><li><span class="math inline">\(M &gt; B_R，B_S≥B_R\)</span><ul><li><span class="math inline">\(B_R+B_S\)</span></li></ul></li><li><span class="math inline">\(B_S≥M，B_R≥M\)</span><ul><li><span class="math inline">\(\frac{B_RB_S}{M-2} + B_S\)</span>（考虑输出）</li></ul></li><li>排序<ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ M^2\)</span></li></ul></li><li>哈希<ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ (M-1)^2\)</span></li></ul></li><li>索引<ul><li>聚簇索引<ul><li><span class="math inline">\(B(R) + T(R)\left \lceil\frac{B(S)}{V(S,K)} \right \rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>非聚簇索引<ul><li><span class="math inline">\(B(R) +\frac{T(R)T(S)}{V(S,K)}\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li></ul></li></ul></li><li><p>去重（投影）</p><ul><li>一趟扫描<ul><li><span class="math inline">\(B(R)\)</span></li><li><span class="math inline">\(B(\delta(R))≤M\)</span></li></ul></li><li>排序<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ M^2\)</span></li></ul></li><li>哈希<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ (M-1)^2\)</span></li></ul></li></ul></li><li><p>分组</p><ul><li>一趟扫描<ul><li><span class="math inline">\(B(R)\)</span></li><li>所有分组可在内存中完整保存</li></ul></li><li>排序<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ M^2\)</span></li></ul></li><li>哈希<ul><li><span class="math inline">\(3 B(R)\)</span></li><li><span class="math inline">\(B(R) ≤ (M-1)^2\)</span></li></ul></li></ul></li><li><p>排序</p><ul><li><span class="math inline">\(3 B(R)\)</span> 【不考虑写回】、 <spanclass="math inline">\(4 B(R)\)</span> 【考虑写回】</li></ul></li><li><p>并、差、交</p><ul><li><p>集合上操作需要去重、包上操作不用去重</p></li><li><p>一趟扫描</p><ul><li><span class="math inline">\(B(R)+B(S)\)</span></li><li><span class="math inline">\(min(B(R),B(S)) ≤ M-1\)</span></li></ul></li><li><p>排序</p><ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ M^2\)</span></li></ul></li><li><p>哈希</p><ul><li><span class="math inline">\(3 B(R) + 3 B(S)\)</span></li><li><span class="math inline">\(B(R) + B(S) ≤ (M-1)^2\)</span></li></ul></li></ul></li><li><p>选择</p><ul><li>扫描<ul><li><span class="math inline">\(B(R)\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>哈希<ul><li><span class="math inline">\(\left \lceil \frac{B(R)}{V(R,K)} \right\rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>索引<ul><li>聚簇索引<ul><li><span class="math inline">\(\left \lceil \frac{B(R)}{V(R,K)} \right\rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li><li>非聚簇索引<ul><li><span class="math inline">\(\left \lceil \frac{T(R)}{V(R,K)} \right\rceil\)</span></li><li><span class="math inline">\(M ≥ 2\)</span> （考虑输出）</li></ul></li></ul></li></ul></li></ul><h3 id="查询优化">查询优化🤡</h3><ul><li>逻辑查询优化：<ul><li>把形如<span class="math inline">\(\sigma_{F_1 \wedge F_2 \wedge...\wedge F_n }(E)\)</span>的选择表达式变成串接形式<spanclass="math inline">\(\sigma_{F_1}(\sigma_{F_2}(...(\sigma_{F_n}(E)))\)</span></li><li>将<span class="math inline">\(\sigma\)</span> 移动到树底</li><li>将<span class="math inline">\(\pi\)</span>移动到底部，若是对某表达式的所有属性进行的，则删去</li><li>将<span class="math inline">\(\sigma\)</span> 和<spanclass="math inline">\(\pi\)</span> 组合为<spanclass="math inline">\(\sigma\)</span> 后跟<spanclass="math inline">\(\pi\)</span> 或单个的形式</li></ul></li><li>物理查询优化：<ul><li>掌握 <span class="math inline">\(\pi\)</span> 、<spanclass="math inline">\(\sigma_{A=c}\)</span> 、<spanclass="math inline">\(\sigma_{A&lt;c}\)</span> 、<spanclass="math inline">\(and\)</span> 、<spanclass="math inline">\(or\)</span> 、自然连接的代价估计</li></ul></li></ul><h3 id="并发控制">并发控制📮</h3><ul><li><p>所有隔离级别均可以解决丢失修改问题</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205201127663.png"/></p><table><thead><tr class="header"><th style="text-align: center;">隔离级别</th><th style="text-align: center;">脏读</th><th style="text-align: center;">不可重复读</th><th style="text-align: center;">幻读</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">读未提交</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;">读已提交</td><td style="text-align: center;">×</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="odd"><td style="text-align: center;">可重复读</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;">可串行化</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td></tr></tbody></table></li><li><p>判断冲突可串行化调度：画图，判断有无环</p></li><li><p>X（排他）锁、S（读写）锁、U（更新）锁、I（增量）锁</p></li><li><p>两段锁协议</p><ul><li>读写数据之前要获得锁。每个事务中所有封锁请求先于任何一个解锁请求</li><li>两阶段：加锁段，解锁段。加锁段中不能有解锁操作，解锁段中不能有加锁操作</li></ul></li><li><p>如果一组事务中每个事务都在等待其他事务释放锁，则这组事务形成死锁</p></li><li><p>事务产生死锁当且仅当等待图中有环</p></li></ul><h3 id="故障恢复">故障恢复🚢</h3><ul><li><p>故障及其解决方法：</p><ul><li>事务故障：redo、undo事务</li><li>系统故障：运行日志，从检查点开始恢复<ul><li>检查点表征了:在检查点之前内存中数据与介质中数据是保持一致的</li></ul></li><li>介质故障：副本</li></ul></li><li><p>缓冲区处理策略</p><ul><li>Force:内存中的数据最晚在commit的时候写入磁盘</li><li>Noforce:内存中的数据可以一直保留，在commit之后过一段时间再写入磁盘。(此时在系统崩溃的时候可能还没写入到磁盘，需要redo)</li><li>No steal:不允许在事务commit之前把内存中的数据写入磁盘</li><li>Steal:允许在事务commit之前把内存中的数据写入磁盘。(此时若系统在commit之前崩溃时，已经有数据写入到磁盘了，要恢复到崩溃前的状态，需要Undo)</li><li>一般选用 Steal + No force</li></ul></li><li><p>undo日志：</p><ul><li>&lt;T,X,v&gt;中v为x的旧值</li><li>先OUTPUT再COMMIT</li></ul></li><li><p>redo日志：</p><ul><li>&lt;T,X,v&gt;中v为x的新值</li><li>先COMMIT再OUTPUT</li></ul></li><li><p>检查点</p><ul><li><p><code>&lt;begin checkpoint (T1,T2...Tn)&gt;</code></p><p><code>...</code></p><p><code>&lt;end checkpoint&gt;</code></p><p>redo 从 <code>begin checkpoint</code>开始扫描</p><p>undo 扫描到T1，T2 ... Tn 中最早的事务 Ti的日志记录<code>&lt;Ti , begin&gt;</code>为止</p></li></ul></li><li><p>一般使用 &lt;T,X,u,v&gt;，其中旧值为u，新值为v</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个AES加密算法的工具类</title>
    <link href="/post/abbb7a99.html"/>
    <url>/post/abbb7a99.html</url>
    
    <content type="html"><![CDATA[<h1id="一个aes加密算法的工具类android">一个AES加密算法的工具类（Android）</h1><p>我想要实现对一个字符串用AES加密算法进行加密，解密的操作，本来以为很容易，但是网上找到很多都是不能用的，下面这份代码亲测可用，于是记录之。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.util.Base64;<br><span class="hljs-keyword">import</span> android.util.Log;<br><br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AESUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> AESUtils.class.getSimpleName();<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 采用AES加密算法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES&quot;</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 字符编码(用哪个都可以，要注意new String()默认使用UTF-8编码 getBytes()默认使用ISO8859-1编码)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Charset</span> <span class="hljs-variable">CHARSET_UTF8</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加解密算法/工作模式/填充方式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CIPHER_ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES/ECB/PKCS5Padding&quot;</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0123456789abcdef&quot;</span>; <span class="hljs-comment">//这里只要是16位字符即可</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * AES 加密</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data      待加密内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回Base64转码后的加密数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建AES秘钥</span><br>            <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">secretKeySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(secretKey.getBytes(CHARSET_UTF8), KEY_ALGORITHM);<br>            <span class="hljs-comment">// 创建密码器</span><br>            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);<br>            <span class="hljs-comment">// 初始化加密器</span><br>            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);<br>            <span class="hljs-type">byte</span>[] encryptByte = cipher.doFinal(data.getBytes(CHARSET_UTF8));<br>            <span class="hljs-comment">// 将加密以后的数据进行 Base64 编码</span><br>            <span class="hljs-keyword">return</span> base64Encode(encryptByte);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            handleException(<span class="hljs-string">&quot;encrypt&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * AES 解密</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> base64Data 加密的密文 Base64 字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decrypt</span><span class="hljs-params">(String base64Data)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] data = base64Decode(base64Data);<br>            <span class="hljs-comment">// 创建AES秘钥</span><br>            <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">secretKeySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(secretKey.getBytes(CHARSET_UTF8), KEY_ALGORITHM);<br>            <span class="hljs-comment">// 创建密码器</span><br>            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(CIPHER_ALGORITHM);<br>            <span class="hljs-comment">// 初始化解密器</span><br>            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);<br>            <span class="hljs-comment">// 执行解密操作</span><br>            <span class="hljs-type">byte</span>[] result = cipher.doFinal(data);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(result, CHARSET_UTF8);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            handleException(<span class="hljs-string">&quot;decrypt&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将 字节数组 转换成 Base64 编码</span><br><span class="hljs-comment">     * 用Base64.DEFAULT模式会导致加密的text下面多一行（在应用中显示是这样）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">base64Encode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>        <span class="hljs-keyword">return</span> Base64.encodeToString(data, Base64.NO_WRAP);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将 Base64 字符串 解码成 字节数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] base64Decode(String data) &#123;<br>        <span class="hljs-keyword">return</span> Base64.decode(data, Base64.NO_WRAP);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleException</span><span class="hljs-params">(String methodName, Exception e)</span> &#123;<br>        e.printStackTrace();<br>        Log.e(TAG, methodName + <span class="hljs-string">&quot;----&gt;&quot;</span> + e);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AES加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理期末总结</title>
    <link href="/post/e5a09991.html"/>
    <url>/post/e5a09991.html</url>
    
    <content type="html"><![CDATA[<h1 id="编译原理期末总结">编译原理期末总结</h1><p>主要针对编译原理期末复习中的一些重点进行归纳总结</p><span id="more"></span><h3id="first集follow集select集计算">FIRST集、FOLLOW集、SELECT集计算🎃</h3><p>FIRST集：</p><ul><li>FIRST集中是可以有<span class="math inline">\(\xi\)</span>的</li><li>如果遇到 <span class="math inline">\(E → aF\)</span>之类的，FIRST(E)中加入a</li><li>如果遇到 <span class="math inline">\(E → FT\)</span>之类的，FIRST(E)中加入FIRST(F)中内容，如果 <span class="math inline">\(F→ \xi\)</span> ，则FIRST(E)中加入FIRST(T)中内容，可以一直往后顺延至某一个终结符或FIRST集中没有<spanclass="math inline">\(\xi\)</span> 的非终结符</li></ul><p>FOLLOW集：</p><ul><li>FOLLOW集中没有 <span class="math inline">\(\xi\)</span></li><li>先在开始符号 S 的FOLLOW中加入 <spanclass="math inline">\(\$\)</span></li><li>如果遇到 $ ... → FT$ 之类的，FOLLOW(F)中加入 FIRST(T)-<spanclass="math inline">\(\xi\)</span></li><li>如果遇到 $ ... → Fa$ 之类的，FOLLOW(F)中加入a</li><li>如果遇到 <span class="math inline">\(E → ...T\)</span>之类的，FOLLOW(T)中加入FOLLOW(E)</li></ul><p>SELECT集：</p><ul><li>计算SELECT集时，要把所有的语句拆成不含 | 的形式</li><li>如果遇到 <span class="math inline">\(E →T\)</span>之类的，如果FIRST(T)不包含 <spanclass="math inline">\(\xi\)</span> ，则SELECT=FIRST(T)，如果FIRST(T)包含<span class="math inline">\(\xi\)</span> ，则SELECT=(FIRST(T)- <spanclass="math inline">\(\xi\ ) \cup\)</span> FOLLOW(E)</li></ul><h3 id="ll文法和lr文法的判定条件">LL文法和LR文法的判定条件🚀</h3><ul><li>LL文法 文法G是LL(1)的，当且仅当G的任意两个具有相同左部的产生式A → α| β 满足条件：<ol type="1"><li>文法不含左递归（即不存在终结符a使得α和β都能够推导出以a开头的串）</li><li>α和β至多有一个能推导出ε</li><li>如果 β <span class="math inline">\(\Rightarrow ^ *\)</span>ε，则FIRST(α) ∩ FOLLOW(A) =Φ；如果 α <spanclass="math inline">\(\Rightarrow ^ *\)</span> ε，则FIRST(β) ∩ FOLLOW(A)=Φ；</li></ol></li><li>LR文法<ul><li><p>LR(0)文法</p><p>如果文法对应的自动机中不存在<code>移进-归约冲突</code>和<code>归约-归约冲突</code>则为LR(0)文法。换句话说LR(0)文法分析不能解决这两种冲突，所以范围最小。移进-归约冲突就是在同一个项集族中同时出现了可以移进的产生式和可以归约的产生式。归约-归约冲突类似。</p></li><li><p>SLR文法</p><p>SLR文法中还是存在<code>归约-归约冲突</code>和存在<code>移进-归约冲突</code>，但是如果可以用FOLLOW集解决则是SLR文法。换句话说，SLR文法分析过程也不一定能解决这两种冲突。用FOLLOW集来处理出现了<code>归约-规约冲突</code>或<code>移进-归约冲突</code>的两条产生式，如果其FOLLOW集相交为空则为SLR文法，反之不是。</p></li><li><p>LR(1)文法</p><p>题目出现的基本都是LR(1)文法</p></li><li><p>LALR文法</p><p>LALR文法中存在<code>归约-归约冲突</code>。</p></li></ul></li></ul><h3 id="赋值语句翻译">赋值语句翻译🦊</h3><ul><li><p>if-else-then语句：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">if x&gt;1<br>then x=0<br>else x=2<br></code></pre></div></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">nif x&gt;1 goto n+2<br>n+1goto n+4<br>n+2x=0<br>n+3goto n+5<br>n+4x=2<br>n+5...<br></code></pre></div></td></tr></table></figure></li><li><p>while语句：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">while i&gt;0<br>do i=i+1<br></code></pre></div></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">nif i&gt;0 goto n+2<br>n+1goto n+5<br>n+2t=i+1<br>n+3i=t<br>n+4goto n<br>n+5...<br></code></pre></div></td></tr></table></figure></li><li><p>逻辑运算符</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">if ( x&lt;100 || x&gt;200 &amp;&amp; x!=y )<br><span class="hljs-code">x=0;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">nif x&lt;100 goto n+6 <br>n+1goto n+2<br>n+2if x &gt; 200 goto n+4<br>n+3goto n+7 <br>n+4if x!=y goto n+6<br>n+5goto n+7<br>n+6x=0<br>n+7...<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="控制语句的sdt回填">控制语句的<code>SDT</code>&amp;回填⛄</h3><p>控制流语句：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">1if B then S1<br>2if B then S1 else S2<br>3while B S1<br></code></pre></div></td></tr></table></figure><p>布尔表达式</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">1B1 or B2<br>2B1 and B2<br>3not B<br>4(B)<br>5E1 relop E2<br>6true<br>7false<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052245722.png" alt="控制流语句SDT" style="zoom:75%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052245278.png" alt="布尔表达式SDT" style="zoom:75%;" /></p><p>控制流SDT编写：</p><ul><li>分析每一个非终结符之前：<ul><li>先计算继承属性</li><li>再观察代码结构图中该非终结符对应的方框顶部是否有<code>导入箭头</code>。如果有，调用<code>label()</code>函数</li></ul></li><li>上一个代码框执行完<code>不顺序执行</code>下一个代码框时，生成一条<code>显式跳转</code>指令</li><li>有<code>自下而上的箭头</code>时，设置<code>begin</code>属性。且定义后<code>直接调用label( )函数</code>绑定地址</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052148748.png" alt="控制流语句回填" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205052146083.png" alt="布尔表达式的回填" style="zoom:67%;" /></p><p>回填SDT编写：</p><ul><li>文法改造<ul><li>在list箭头指向的位置设置标记非终结符M</li></ul></li><li>在产生式末尾的语义动作中<ul><li>计算综合属性</li><li>调用backpatch ( )函数回填各个list</li></ul></li></ul><p>注：上述语句的<strong>代码结构图</strong>非常重要</p><h3 id="数据流分析技术">数据流分析技术🪆</h3><h4 id="到达定值分析">到达定值分析👨🏻‍🚀</h4><p>对 <spanclass="math inline">\(d_i\)</span>进行分析，gen是本基本块中的所有 <spanclass="math inline">\(d_i\)</span>，kill是不在本基本块内，但是和本基本块内<span class="math inline">\(d_i\)</span>左部相同的<spanclass="math inline">\(d_j\)</span></p><p><span class="math inline">\(IN(B)=\cup OUT(B)\)</span></p><p><span class="math inline">\(OUT(B)=gen \cup (IN(B)-kill)\)</span></p><p>用途：</p><ol type="1"><li>循环不变计算检测</li><li>常量合并</li><li>判定变量x在p点上是否未经定值被引用</li></ol><h4 id="活跃变量分析">活跃变量分析👑</h4><p>对每一个基本块内的变量进行分析，use是右部中用到的符号，def是左部中符号，若use和def有交集，放在use里</p><p><span class="math inline">\(OUT(B)=\cup IN(B)\)</span></p><p><span class="math inline">\(IN(B)=use \cup (OUT(B)-def)\)</span></p><p>注意：活跃变量分析从<spanclass="math inline">\(B_n\)</span>开始分析</p><p>用途：</p><ol type="1"><li>删除无用赋值</li><li>为基本块分配寄存器</li></ol><h4 id="可用表达式分析">可用表达式分析🦄</h4><p>对每一个<code>z=x op y</code>这类的表达式进行分析，先找出所有的<code>x op y</code>，记作S。</p><p>遇到 z = x op y ，e_gen先加入x op y,然后删掉所有含有z的表达式；e_kill先删掉x op y，然后加入所有S中含有z的表达式。</p><p><span class="math inline">\(IN(B)=\cap OUT(B)\)</span></p><p><span class="math inline">\(OUT(B)=e_{gen} \cup(IN(B)-e_{kill})\)</span></p><p>用途：</p><ol type="1"><li>消除全局公共子表达式</li><li>复制传播</li></ol><h3 id="概念总结主要针对选填">概念总结（主要针对选填）🐼</h3><h4 id="绪论">绪论😶‍🌫️</h4><ul><li>预处理 <span class="math inline">\(\rightarrow\)</span> 编译 <spanclass="math inline">\(\rightarrow\)</span> 汇编 <spanclass="math inline">\(\rightarrow\)</span> 链接 <spanclass="math inline">\(\rightarrow\)</span> 目标机器代码</li><li>编译：将高级语言翻译成汇编语言或机器语言的过程</li><li>词法分析中 token：&lt;种别码，属性值&gt;、语法分析构造<strong>语法分析树</strong>、语义分析收集标识符的属性信息<strong>建立符号表和语义检查</strong></li></ul><h4 id="语言及其文法">语言及其文法🐻‍❄️</h4><ul><li><p>对于 <span class="math inline">\(\alpha\ \rightarrow\\beta\)</span></p><ul><li>1型文法 -- 上下文有关文法：<span class="math inline">\(|\alpha|\ ≤\|\beta|\)</span></li><li>2型文法 -- 上下文无关文法：<span class="math inline">\(\alpha\ \in\V_N，A\rightarrow \beta\)</span></li><li>3型文法 -- 正则文法：<ul><li>右线性文法<span class="math inline">\(A\rightarrow wB\)</span> 或<span class="math inline">\(A \rightarrow w\)</span><br /></li><li>右线性文法<span class="math inline">\(A\rightarrow Bw\)</span> 或<span class="math inline">\(A \rightarrow w\)</span></li></ul></li></ul></li><li><p>短语和直接短语：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202205180933517.png" /></p></li></ul><h4 id="词法分析">词法分析🐒</h4><ul><li>错误恢复（恐慌模式）：从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止</li></ul><h4 id="语法分析">语法分析👻</h4><ul><li>最右推导（规范推导）<spanclass="math inline">\(\Leftrightarrow\)</span> 最左规约<spanclass="math inline">\(\Leftrightarrow\)</span>最右句型（规范句型）</li><li>LL(1)文法不需要回溯，是一种确定的自顶向下分析方法（预测分析法）</li><li>预测分析中错误恢复（恐慌模式）：忽略输入中的一些符号，直到输入中出现由设计者选定的同步词法单元集合中的某个词法单元，将FOLLOW集中元素设置为<span class="math inline">\(synch\)</span><ul><li>如果是空：忽略</li><li>如果是 <span class="math inline">\(synch\)</span>，弹出栈顶非终结符</li><li>如果是终结符不匹配，弹出终结符</li></ul></li><li>预测分析法实现步骤：<ol type="1"><li>构造文法</li><li>改造文法：消除二义性、消除左递归、消除回溯</li><li>求每个变量的FIRST集和FOLLOW集，从而求得每个候选式的SELECT集</li><li>检查是不是 LL(1) 文法。若是，构造预测分析表</li><li>对于递归的预测分析，根据预测分析表为每一个非终结符编写一个过程；对于非递归的预测分析，实现表驱动的预测分析算法</li></ol></li><li>每次规约的符号串称为“句柄”，句柄是句型的最左直接短语</li><li>LR分析中错误恢复<ul><li>恐慌模式：丢弃输入符号</li><li>短语层次</li></ul></li></ul><h4 id="语法制导翻译">语法制导翻译🎎</h4><ul><li><p>SDD是对CFG的推广</p></li><li><p><strong>注释分析树</strong>：每个节点都有属性值的分析树</p></li><li><p>终结符只能有综合属性</p></li><li><p>一个没有副作用的SDD称为属性文法</p></li><li><p>S-SDD可以按照自底向上顺序计算属性值并且实现</p></li><li><p>如果 S-SDD的基本文法可以使用LR分析技术，那么它的SDT可以在LR语法分析中实现</p></li><li><p>扩展栈：</p><table><thead><tr class="header"><th style="text-align: center;">状态</th><th style="text-align: center;">符号</th><th style="text-align: center;">属性</th></tr></thead><tbody></tbody></table></li><li><p>如果L-SDD的基本文法可以使用LL分析技术【LL文法判定】，那么它的SDT可以在LL或LR语法分析中实现</p></li><li><p>如果选用非递归LL实现，扩展语法分析栈：</p><table><thead><tr class="header"><th style="text-align: center;">action</th><th style="text-align: center;">A</th><th style="text-align: center;">Asyn</th></tr></thead><tbody></tbody></table><p>A的继承属性在A中</p></li><li><p>如果选用递归LL实现：继承属性是形参，综合属性的返回值</p></li></ul><h4 id="中间代码生成">中间代码生成🐧</h4><ul><li>局部变量存储分配：对于声明语句，从类型表达式可以知道该类型<strong>在运行时刻所需的存储单元数量</strong>称为类型的宽度。在<strong>编译时刻</strong>，可以使用类型的宽度为每一个名字<strong>分配一个相对地址</strong>。名字的类型和相对地址信息保存在相应的符号表记录中</li><li>逻辑运算符优先级：not &gt; and &gt; or</li></ul><h4 id="运行存储分配">运行存储分配👽</h4><ul><li><p>活动记录结构：</p><table><tbody><tr class="odd"><td style="text-align: center;">实参</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">返回值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">控制链</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">访问链</td><td style="text-align: center;">访问存放于其他活动记录的非局部数据</td></tr><tr class="odd"><td style="text-align: center;">保存的机器状态</td><td style="text-align: center;">返回地址和寄存器中内容</td></tr><tr class="even"><td style="text-align: center;">局部变量</td><td style="text-align: center;">该过程中声明的数据</td></tr><tr class="odd"><td style="text-align: center;">临时变量</td><td style="text-align: center;"></td></tr></tbody></table></li><li><p>栈式存储分配可以保证它的非局部变量的相对地址总是固定的，和过程调用序列无关</p></li><li><p>活动树：用来描述程序运行期间控制进入和离开各个活动情况的树</p></li><li><p>每个活跃的活动都有一个位于控制栈中的活动记录</p></li><li><p>当一个过程是递归的时候，常常会有该过程的多个活动记录同时出现在栈中</p></li><li><p>top_sp指向活动记录中局部数据开始的位置</p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205181113824.png" alt="" style="zoom:67%;" /></p><ul><li>符号表作用：辅助代码生成、一致性检查</li></ul><h4 id="代码优化">代码优化🐇</h4><ul><li>未经声明错误是语义分析检测出的（还有重复定值）；未经定值是数据流分析检测出的</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205181145527.png" alt="" style="zoom:67%;" /></p><h4 id="代码生成">代码生成🌞</h4><ul><li>代码生成器主要任务：<ul><li>指令选择</li><li>寄存器分配和指派</li><li>指令排序</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202205181204936.png" alt="" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件过程与工具</title>
    <link href="/post/f6d9959d.html"/>
    <url>/post/f6d9959d.html</url>
    
    <content type="html"><![CDATA[<p>对软件工程与工具课程的主要内容进行总结</p><span id="more"></span><h1 id="软件过程与工具">软件过程与工具</h1><h2 id="概述">1.概述🥡</h2><h3 id="软件的基本概念">1.1 软件的基本概念</h3><ul><li>1.1.1 什么是软件<ul><li>软件：一组对象或项目所形成的一个“配置”，由<strong>程序、文档和数据</strong>构成。</li><li>“变化”是永恒的主题</li></ul></li><li>1.1.2 软件的发展<ul><li>面向构件的软件 = 构件 + 框架</li><li>面向服务的软件 = 服务 + 消息 + 总线</li></ul></li></ul><h3 id="软件工程的基本概念">1.2 软件工程的基本概念</h3><ul><li>1.2.1 软件工程产生的历史根源</li><li>1.2.2 软件工程的基本概念</li><li>1.2.3 软件工程的知识体系</li></ul><h3 id="软件工程工具">1.3 软件工程工具</h3><ul><li>1.3.1 CASE工具</li></ul><h2 id="软件过程核心思想">2.软件过程核心思想😶‍🌫️</h2><h3 id="软件工程的本质不同抽象层次之间的映射与转换">2.1软件工程的本质：不同抽象层次之间的映射与转换</h3><ul><li><p>任何软件系统开发的共同本质在于：<strong>从现实空间的需求到计算机空间的软件代码之间的映射与转换</strong></p></li><li><p>单步映射与多步映射</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337499.png" /></p><p>如上图所示，黑色虚线是正确的实现途径，红色是实际的实现途径（单步映射），蓝色也是实际的实现途径（多步映射）</p><ul><li>软件工程本质：用严格的规范和管理手段来缩小偏差，通过牺牲“时间”来提高“质量”</li></ul></li><li><p>软件工程的两个映射</p><ul><li>概念映射：问题空间的概念与解空间的模型化概念之间的映射<ul><li>“学生” <span class="math inline">\(\rightarrow Class Student (No,Name, Dept, Grade)\)</span></li></ul></li><li>业务逻辑映射：问题空间的处理逻辑与解空间处理逻辑之间的映射<ul><li>计算某班学生平均分数→</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">calculateAverageScore</span> <span class="hljs-params">(Struct [] scores)</span> <br>&#123;<br>    检索;<br>    计算平均分算法;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>软件工程：不同抽象层次之间的映射过程</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337315.png" style="zoom:70%;" /></p><p>现实空间的需求<span class="math inline">\(\rightarrow\)</span>需求规约<span class="math inline">\(\rightarrow\)</span> 设计规约<spanclass="math inline">\(\rightarrow\)</span> 代码</p></li></ul><h3 id="软件工程所关注的目标">2.2 软件工程所关注的目标</h3><ul><li><p>软件工程所关注的对象</p><ul><li><p>产品：各个抽象层次的产出物</p></li><li><p>过程：在各个抽象层次之间进行映射和转换</p><p>“产品与过程二相性”：要把二者结合起来去考虑，而不能忽略其中任何一方</p></li></ul></li><li><p>软件工程所关注的目标</p><ol type="1"><li>功能性需求：软件所实现的功能达到它的设计规范和满足用户需求的程度<ul><li>完备性、正确性（描述软件在需求范围之内的行为）、健壮性（描述软件在需求范围之外的行为）、可靠性</li></ul></li><li>非功能性需求：系统能够完成所期望的工作的性能与质量<ul><li>效率、可用性、可维护性、可移植性、清晰性、安全性、兼容性、经济性、商业质量</li></ul></li><li>不同目标之间的关系：折中</li></ol></li></ul><h3 id="软件开发中的多角色">2.3 软件开发中的多角色</h3><h3 id="软件工程-最佳实践">2.4 软件工程 = 最佳实践</h3><p><del>（当你把所有错误都犯过之后，你就是正确的了）</del></p><h3 id="软件工程的四个核心理论概念">2.5 软件工程的四个核心理论概念</h3><ul><li>分治</li><li>复用</li><li>折中</li><li>演化<ul><li>软件系统在其生命周期中面临各种变化</li><li>可修改性、可维护性、可扩展性</li></ul></li></ul><h2 id="软件过程模型">3.软件过程模型📮</h2><h3 id="软件过程">3.1 软件过程</h3><ul><li><p>黑盒过程和白盒过程</p><p>将整个软件开发过程看成一个黑盒，而在实际软件开发中要在黑盒中留出白盒进行反馈（<spanclass="math inline">\(feedback\)</span>）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337643.png"  style="zoom:80%;" /></p></li></ul><h3 id="典型软件过程模型">3.2 典型软件过程模型</h3><h4 id="瀑布模型">3.2.1 瀑布模型</h4><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337802.png" style="zoom:80%;" /></p><p>过程：从上一项活动接收该项活动的工作对象作为输入，利用这一输入实施该项活动应完成的内容给出该项活动的工作成果，并作为输出传给下一项活动。同时评审该项活动的实施，若确认，则继续下一项活动；否则返回前面，甚至更前面的活动（但是这种回溯非常困难）</p><p>每个阶段都有里程碑和提交物。</p><ul><li>优点：追求效率、能够逐步稳定的使项目向前发展</li><li>缺点：过于理想化、快速建立起来的系统结构可能会在后续的持续更改中导致软件质量低下、客户只有在末期才能得到可执行程序</li><li>适合场景：软件项目较小，各模块间接口定义非常清晰；需求在项目开始之前已经被全面的了解，产品的定义非常稳定；需求在开发中不太可能发生重大改变</li></ul><p>瀑布模型太理想化，太单纯，已不再适合现代的软件开发模式，在大型系统开发中已经很少使用。</p><h4 id="增量过程模型">3.2.2 增量过程模型</h4><p>无须等到所有需求都出来才进行开发，只要某个需求的核心部分出来，即可进行开发；可能迫切需要为用户迅速提供一套功能有限的软件产品，然后在后续版本中再细化和扩展功能。</p><ul><li><p>增量模型</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337609.png" style="zoom:60%;" /></p><p><strong>本质：以迭代的方式运用瀑布模型</strong></p><p>当使用增量模型时，<strong>第1个增量往往是核心的产品</strong>，即第1个增量实现了基本的需求，但很多补充的特征还没有发布。客户对每一个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。<strong>增量模型强调每一个增量均发布一个可操作的产品。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">例：开发一个类似于Word的字处理软件<br><span class="hljs-code">增量1：提供基本的文件管理、编辑和文档生成功能</span><br><span class="hljs-code">增量2：提供高级的文档编辑功能</span><br><span class="hljs-code">增量3：实现拼写和语法检查功能</span><br><span class="hljs-code">增量4：完成高级的页面排版功能</span><br></code></pre></div></td></tr></table></figure><ul><li>优点：能够快速推出软件产品，满足客户需求，对客户有一定的镇定作用、不用一下子投入太多资源。灵活性比较高</li><li>缺点：由于软件其他构件是后期加入的，容易导致由于构件之间的不稳定从而使系统崩溃。</li></ul></li><li><p>快速应用程序开发(RAD)</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337170.png" style="zoom:80%;" /></p><ul><li>优点：<strong>侧重于短开发周期</strong>（一般为60~90天）的增量过程模型，是瀑布模型的高速变体，通过<strong>基于构件的构建方法</strong>实现快速开发；<strong>多个团队并行进行开发</strong>，但启动时间有先后，先启动团队的提交物将作为后启动团队的输入</li><li>缺点：</li><li><strong>需要大量的人力资源</strong>来创建多个相对独立的RAD团队；如果<strong>没有在短时间内为急速完成整个系统做好准备</strong>，RAD项目将会失败；如果<strong>系统不能被合理的模块化</strong>，RAD将会带来很多问题；<strong>技术风险很高的情况下</strong>（采用很多新技术、软件需与其他已有软件建立集成等等），不宜采用RAD</li></ul></li><li><p>增量模型和RAD模型区别：增量模型要求后来的增量不能对之前的系统结构进行破坏</p></li></ul><h4 id="演化过程模型">3.2.3 演化过程模型</h4><p>需求的变更频繁，要求在非常短的期限内实现，以充分满足客户/用户要求、及时投入市场</p><p>本质：循环、反复、不断调整当前系统以适应需求变化</p><p>由于构建产品所需的周期数据不确定，给项目管理带来困难；演化速度太快，项目陷入混乱；演化速度太慢，影响生产率；为追求软件的高质量而牺牲了开发速度、灵活性和可扩展性</p><ul><li><p>快速原型法</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337551.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337539.png" style="zoom:80%;" /></p><ul><li><p>原型的分类</p><ul><li><p>抛弃式原型</p><p>最初的原型在完成并得到用户认可之后，将不会作为交付给用户的最终系统的一部分，而是被抛弃，其目的只是为了收集与验证需求</p><p><strong>该类原型是不可执行的</strong></p></li><li><p>演化式模型</p><p>最初构造的原型将具备较高的质量，包含了系统的核心功能，然后通过收集需求对其进行不断的改善和精化</p><p><strong>该类原型是可执行的，将成为最终系统的一部分</strong></p></li></ul></li><li><p>优点：提高和改善客户/用户的参与程度，最大程度的响应用户需求的变化</p></li><li><p>缺点：设计原型时未考虑整体软件质量和长期的可维护性，系统结构较差；混淆原型系统和最终系统；额外的开发费用</p></li></ul></li><li><p>螺旋模型</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337809.png" style="zoom:70%;" /></p><p>制定计划<span class="math inline">\(\rightarrow\)</span>风险分析<span class="math inline">\(\rightarrow\)</span>实施工程<spanclass="math inline">\(\rightarrow\)</span>客户评价<spanclass="math inline">\(\rightarrow\)</span>制定计划<spanclass="math inline">\(\rightarrow\)</span>...</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">例：<br>第1圈：开发出产品的规格说明<br>第2圈：开发产品的原型系统<br>第3~n圈：不断的迭代，开发不同的软件版本<br>根据每圈交付后用户的反馈来调整预算、进度、需要迭代的次数<br></code></pre></div></td></tr></table></figure><p><strong>与增量、RAD等的最大区别在于重视风险评估</strong></p><ul><li>出发点：开发过程中及时识别和分析风险，并采取适当措施以消除或减少风险带来的危害</li><li>优点：结合了原型的迭代性质与瀑布模型的系统性和可控性，是一种<strong>风险驱动型的过程模型</strong></li><li>缺点：周期长，成本高，软件开发人员应该擅长寻找可能的风险</li></ul></li></ul><h4 id="其他过程模型">3.2.4 其他过程模型</h4><ul><li>形式化过程</li><li>软件复用过程</li></ul><h3 id="案例分析">3.3 案例分析</h3><h2 id="敏捷方法与过程">4.敏捷方法与过程🎑</h2><h4 id="敏捷过程模型">4.1 敏捷过程模型</h4><p>开发过程中<strong>“变化”</strong>是无处不在的，要将<strong>“变化”</strong>的意识贯穿在每一项开发活动中。</p><p><strong>“小步快跑，及时反馈”</strong></p><p>本质：<strong>以快速的增量和迭代方式进行软件开发</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337761.png" style="zoom:75%;" /></p><p>敏捷过程中最重要的因素：<strong>人</strong></p><h4 id="极限编程xp">4.2 极限编程(XP)</h4><p>planning(用户故事User story) → design(测试驱动的开发TDD) →coding(结对编程Pair programming) → test(持续集成Continuousinstegration)</p><ul><li><p>XP planning</p><p>用户故事：<strong>客户</strong>为用户故事指定<strong>优先级</strong>，<strong>XP团队</strong>为用户故事指定<strong>成本</strong></p><p>将若干个用户故事指定为<strong>下一次发布的增量</strong></p><p>规划<strong>整体进度</strong></p></li><li><p>XP design</p><p>遵循<span class="math inline">\(KIS(Keep\ It\Simple)\)</span>原则</p><p>设计模型：面向对象方法，<spanclass="math inline">\(CRC\)</span>卡片</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337682.png" style="zoom:70%;" /></p><p>遇到困难问题：创建原型</p><p>对设计方案不断<strong>重构</strong></p></li><li><p>XP coding &amp; test</p><p>测试驱动的开发<span class="math inline">\((TDD):\)</span></p><ul><li><p>编码前设计<strong>单元测试用例</strong></p></li><li><p><strong>结对编程</strong></p><ul><li><p>驾驶员：控制键盘输入的人</p></li><li><p>领航员：起到领航，提醒的作用</p></li><li><p>驾驶员和领航员不断轮换角色，不宜连续工作超过一小时；领航员要控制时间</p></li><li><p>主动参与、只有水平上的差距，没有级别上的差异</p></li><li><p>程序各方面的质量取决于<strong>一对程序员中各方面水平较高的那一位</strong></p></li></ul></li></ul></li></ul><p>何以谓“极限”：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251337950.png" style="zoom:80%;" /></p><h4 id="scrum">4.3 Scrum</h4><p>整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个<spanclass="math inline">\(Sprint\)</span>，每个<spanclass="math inline">\(Sprint\)</span>的建议长度是2到4周</p><p>使用产品列表<span class="math inline">\(Product\Backlog\)</span>来管理需求，产品列表<span class="math inline">\(Product\Backlog\)</span>是一个按照商业价值排序的需求列表，列表条目的体现形式通常为用户故事</p><p>先开发对于用户具有较高价值的需求</p><p>在<span class="math inline">\(Sprint\)</span>中，<spanclass="math inline">\(Scrum\)</span>团队从产品列表<spanclass="math inline">\(Product\Backlog\)</span>中挑选最高优先级的需求进行开发；挑选的需求在<spanclass="math inline">\(Sprint\)</span>计划会议上经过讨论、分析和估算得到相应的任务列表(<spanclass="math inline">\(Sprint\ backlog\)</span>)</p><p>在每个迭代结束时，<spanclass="math inline">\(Scrum\)</span>团队将提交潜在可交付的产品增量</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211210103202604.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338325.png" style="zoom:55%;" /></p><p><span class="math inline">\(Scrum\)</span>中的六项活动</p><ul><li><span class="math inline">\(Sprint\)</span>(冲刺)：代表一个1-4周的迭代</li><li>发布计划会议<span class="math inline">\((Release\ Planning\Meeting)\rightarrow\ Product\ Backlog\)</span></li><li><span class="math inline">\(Sprint\)</span>计划会议<spanclass="math inline">\((Sprint\ Planning\ Meeting) \rightarrow\ Sprint\Backlog\)</span></li><li>每日站会<span class="math inline">\((Daily\ Scrum\Meeting)\)</span></li><li><span class="math inline">\(Sprint\)</span>评审会<spanclass="math inline">\((Sprint\ Review\ Meeting)\)</span></li><li><span class="math inline">\(Sprint\)</span>回顾会议<spanclass="math inline">\((Sprint\ Retrospective\ Meeting)\)</span></li></ul><p>每日站会：</p><ul><li>我昨天做了什么<span class="math inline">\((What\ have\ you\ done\since\ yesterday? )\)</span></li><li>我今天要做什么<span class="math inline">\((What\ are\ you\ planning\to\ do\ today? )\)</span></li><li>我碰到了哪些问题<span class="math inline">\((Do\ you\ have\ any\problems\ that\ would\ prevent\ you\ from\ accomplishing\ your\ goal\?)\)</span></li></ul><p><span class="math inline">\(Sprint\ Burndown\chart\)</span>：燃尽图，用于表示剩余工作量的工作图表，由横轴（X）和纵轴（Y）组成，横轴表示时间，纵轴表示工作量。这种图表可以直观的预测何时工作将全部完成。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338703.png" style="zoom:60%;" /></p><h4 id="与传统开发过程模型的对比">4.4 与传统开发过程模型的对比</h4><ul><li>瀑布模型<ul><li>将全部需求以整体方式向前推进，无迭代<br /></li><li>基本模型</li></ul></li><li>增量模型<ul><li>将需求分成多份，串行推进，无迭代</li><li>串行的瀑布</li></ul></li><li>RAD模型<ul><li>将需求分成多份，并行推进，无迭代</li><li>并行的瀑布</li></ul></li><li>原型模型<ul><li>迭代</li><li>基本模型</li></ul></li><li>螺旋模型<ul><li>按瀑布阶段划分，各阶段分别迭代(原型+风险分析)</li><li>原型+瀑布</li></ul></li><li>敏捷模型<ul><li>将需求分成尽量小的碎片，以碎片为单位进行高速迭代</li><li>增量+迭代</li></ul></li></ul><h4 id="敏捷案例分析">4.5 敏捷案例分析</h4><h4 id="总结">4.6总结</h4><ul><li><span class="math inline">\(XP\)</span>与<spanclass="math inline">\(Scrum\)</span>区别<ul><li>迭代长度的不同。<span class="math inline">\(XP\)</span>的一个<spanclass="math inline">\(Sprint\)</span>的迭代长度大致为1~2周, 而<spanclass="math inline">\(Scrum\)</span>的迭代长度一般为 2~ 4周。</li><li>在迭代中, 是否允许修改需求。<spanclass="math inline">\(XP\)</span>在一个迭代中，如果一个用户故事还没有实现，则可以考虑用另外的需求将其替换， 替换的原则是需求实现的时间量是相等的。而<spanclass="math inline">\(Scrum\)</span>是不允许这样做的，一旦迭代开工会完毕,任何需求都不允许添加进来，并有<span class="math inline">\(Scrum\Master\)</span>严格把关，不允许开发团队收到干扰。</li><li>在迭代中，用户故事是否严格按照优先级别来实现。<spanclass="math inline">\(XP\)</span>是务必要遵守优先级别的。 但<spanclass="math inline">\(Scrum\)</span>在这点做得很灵活，可以不按照优先级别来做。</li><li>软件的实施过程中，是否采用严格的工程方法，保证进度或者质量。<spanclass="math inline">\(Scrum\)</span>没有对软件的整个实施过程开出严格工程实践的处方，要求开发者自觉保证；但<spanclass="math inline">\(XP\)</span>对整个流程方法定义非常严格，规定需要采用<spanclass="math inline">\(TDD\)</span>,自动测试，结对编程，简单设计，重构等约束团队的行为。</li></ul></li></ul><h2 id="软件项目管理">5.软件项目管理🦄</h2><p>软件项目的特征：</p><ul><li>不可见性</li><li>不确定性</li><li>多变化性</li><li>高技能及其高流通性</li></ul><h4 id="软件项目管理的案例">5.1 软件项目管理的案例</h4><p>软件项目管理的<span class="math inline">\(4P\)</span></p><ul><li>人员</li><li>产品</li><li>过程</li><li>项目</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338571.png"/></p><h4 id="人员people">5.2 人员(People)</h4><p>软件开发团队的组织方式：</p><ul><li>一窝蜂模式</li><li>主治医师模式<ul><li>明星模式</li></ul></li><li>社区模式<ul><li>开源项目</li></ul></li><li>交响乐团模式<ul><li>“工厂” <span class="math inline">\(\rightarrow\)</span>“规格严格”</li></ul></li><li>爵士乐模式<ul><li>类似于一群天才构成的敏捷团队<spanclass="math inline">\(\rightarrow\)</span>“功夫到家”</li></ul></li><li>功能团队模式</li><li>官僚模式</li></ul><p>大型项目的技术管理组织结构</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338920.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338516.png"  style="zoom:80%;" /></p><h4 id="产品product">5.3 产品(Product)</h4><p>确定软件范围<span class="math inline">\(\rightarrow\)</span>分治</p><p>产品结构分解<span class="math inline">\(PBS\)</span></p><ul><li>通过分层的树型结构来定义和组织<strong>项目范围内的所有产出物(产品)</strong>，自顶向下，逐级细分</li></ul><h4 id="过程process">5.4 过程(Process)</h4><p>选择合适的软件过程模型<spanclass="math inline">\(\rightarrow\)</span>根据所选的过程模型，对其进行适应性修改<spanclass="math inline">\(\rightarrow\)</span>确定过程中所包含的工作任务列表</p><p>工作结构分解<span class="math inline">\(WBS\)</span></p><ul><li>通过分层的树型结构来定义和组织<strong>工作任务之间的分解关系</strong>，自顶向下，逐级细分</li></ul><h4 id="项目project">5.5 项目(Project)</h4><p><span class="math inline">\(W^{5}HH\)</span>原则</p><ul><li><span class="math inline">\(Why\)</span> 为什么要开发这个系统？</li><li><span class="math inline">\(What\)</span> 将要做什么？</li><li><span class="math inline">\(When\)</span> 什么时候做？</li><li><span class="math inline">\(Who\)</span> 某功能由谁来做？</li><li><span class="math inline">\(Where\)</span> 机构组织位于何处？</li><li><span class="math inline">\(How\)</span>如何完成技术与管理工作？</li><li><span class="math inline">\(How\ much\)</span>各种资源分别需要多少？</li></ul><h4 id="可行性分析与估算">5.6 可行性分析与估算</h4><h4 id="项目进度计划与监控">5.7 项目进度计划与监控</h4><p>甘特图；描述任务的进度安排</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338913.png" style="zoom:80%;" /></p><p>下图是一张项目进度跟踪甘特图：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338810.png" style="zoom:80%;" /></p><p><span class="math inline">\(T_{x}\)</span>标识<spanclass="math inline">\(task\)</span>，<spanclass="math inline">\(M_{x}\)</span>标识里程碑，白色标识各项目计划开始/结束日期，白色+ 蓝色标识各项目实际开始/结束日期。</p><p><spanclass="math inline">\(XP/Scrum\)</span>敏捷开发中的进度计划与监控</p><ul><li><p>以“迭代”为单位：每次迭代包含多少个用户故事或用例</p></li><li><p>每次迭代为30天左右</p></li><li><p>针对每个用户故事，团队成员联合估算和协商开发代价(时间)</p></li><li><p>使用任务墙(<span class="math inline">\(Task\Board\)</span>)/燃尽图(<span class="math inline">\(Burndown\Chart\)</span>)等作为进度监控工具，评估迭代的当前进展情况</p></li></ul><h2 id="软件演化与配置管理">6.软件演化与配置管理🍳</h2><h4 id="软件演化">6.1 软件演化</h4><p>软件演化的<span class="math inline">\(Lehman\)</span>定律</p><ul><li><p>持续变化：现实世界的系统要么变得越来越没有价值，要么进行持续不断的变化以适应环境的变化；环境变化产生软件修改，软件修改又继续促进环境变化</p></li><li><p>复杂度逐渐增大：当系统逐渐发生变化时，其结构和功能将变得越来越复杂，并逐渐难以维护并失去控制，直至无法继续演化，从而需要大量额外的资源和维护工作来保持系统的正常运行；软件修改会引入新的错误，造成故障率的升高</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211211095223736.png" style="zoom:80%;" /></p></li></ul><p>软件演化的处理策略：</p><ul><li>软件维护：为了修改软件缺陷或增加新的功能而对软件进行的变更；软件变更通常发生在局部，不会改变整个结构</li><li>软件再工程：为了避免软件退化而对软件的一部分进行重新设计、编码和测试，提高软件的可维护性和可靠性等</li><li><strong>前者力度小</strong></li></ul><h4 id="软件维护">6.2 软件维护</h4><p>软件维护类型</p><ul><li>纠错性维护（开发中有错误）</li><li>适应性维护（外部环境和数据环境变化）</li><li>完善性维护（新的需求和要求）【占比最大】</li><li>预防性维护（减少或避免前三类维护所做的维护）</li></ul><p>软件维护内容：</p><ul><li>程序维护</li><li>数据维护</li><li>硬件维护</li></ul><h4 id="软件配置管理scm">6.3 软件配置管理(SCM)</h4><p><spanclass="math inline">\(SCI\)</span>：软件配置项，软件配置的基本单位（文件）</p><p><spanclass="math inline">\(SCM\)</span>贯穿整个软件生命周期与软件工程过程</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338393.png" style="zoom:75%;" /></p><p><spanclass="math inline">\(SCM\)</span>目标：当变更发生时，能够提高适应变更的容易程度，并且能够减少所花费的工作量</p><p><span class="math inline">\(SCM\)</span>基本元素：</p><ul><li><p>配置项<span class="math inline">\((CI)\)</span></p><p>软件过程的输出信息可以分为三个主要类别：程序、文档，数据。</p><p>软件配置项<spanclass="math inline">\(SCI\)</span>：上述三项的总称，包含了所有在软件中产生的信息，<strong>是软件全生命周期内受管理和控制的基本单位</strong>，大到整个系统，小到某个硬件设备或软件模块</p><p><span class="math inline">\(SCI\)</span>具有唯一的名称和多个属性</p><p><spanclass="math inline">\(CI\)</span>之间<strong>依赖关系</strong>：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338465.png" style="zoom:80%;" /></p><p>对每一个<spanclass="math inline">\(CI\)</span>建立一个演变图，以记录对象的变更历史</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338247.png" style="zoom:80%;" /></p></li><li><p>基线<span class="math inline">\((Baseline)\)</span></p><p>在软件配置项成为基线之前，可以迅速而随意的进行变更，一旦成为基线，<strong>变更时需要遵循正式的评审流程才可以变更</strong>，因此，基线可看作是软件开发过程中的“里程碑”</p><p>基线是在某个时间点上对产品属性的一致描述，它是定义变化的基础</p><p><span class="math inline">\(Version \geqslant Release \geqslantBaseline \geqslant Milestone \geqslant checkpoint\)</span></p><p><span class="math inline">\(Version\)</span>：对外发布版本</p><p><spanclass="math inline">\(Release\)</span>：不一定要对外发布，但对外发布版本一定是<spanclass="math inline">\(Release\)</span></p><p><span class="math inline">\(Baseline\)</span>：不能改动</p><p><span class="math inline">\(Milestone\)</span>：里程碑</p><p><spanclass="math inline">\(checkpoint\)</span>：检查点，最为灵活</p></li><li><p>配置管理数据库<span class="math inline">\((CMDB)\)</span></p><p>也称为<spanclass="math inline">\(SCM\)</span>中心存储库，用于保存与软件相关的所有配置项的信息以及配置项之间关系的数据库</p><p><span class="math inline">\(\alpha测试\)</span>：内部单用户在开发环境测试</p><p><span class="math inline">\(\beta测试\)</span>：多用户在开发环境测试</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338613.png"  style="zoom:80%;" /></p></li><li><p>最终硬件库<span class="math inline">\((DHS)\)</span></p></li><li><p>最终软件库<span class="math inline">\((DSL)\)</span></p></li></ul><h4 id="持续集成">6.4 持续集成</h4><p>敏捷开发的一项重要实践</p><p>集成：集成测试【集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。一些局部反映不出来的问题，在全局上很可能暴露出来。）】</p><p>所有的开发人员需要在本地机器上做本地构建，然后再提交到版本控制库中，从而确保他们的变更不会导致持续集成失败，开发人员每天至少向版本控制库中提交一次代码，开发人员每天至少需要从版本控制库中更新一次代码到本地机器。需要有专门的集成服务器来执行集成构建，每天要执行多次构建，每次构建都要<spanclass="math inline">\(100\%\)</span>通过，每次构建都可以生成可发布的产品，<strong>修复失败的构建是优先级最高的事情</strong></p><h4 id="本地-vs-分布式-版本控制系统">6.5 本地 vs 分布式版本控制系统</h4><ul><li><p>本地版本控制系统(<span class="math inline">\(Local\VCS\)</span>)</p><p>采用简单的数据库或文件系统来记录本地文件的历次更新差异</p></li><li><p>集中化版本控制系统<span class="math inline">\((Centralized\VCS)\)</span></p><p>有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的开发者通过客户端连到这台服务器，取出最新的文件或者提交更新</p><p>缺点：单点故障，可靠性</p></li><li><p>分布式版本控制系统<span class="math inline">\((Distributed\VCS)\)</span></p><p>客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来</p><p>任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p><p>每一次的提取操作，实际上都是一次对代码仓库的完整备份</p></li></ul><h4 id="git的基本思想">6.6 Git的基本思想</h4><p><spanclass="math inline">\(git\)</span>关注文件数据整体是否发生变化而不是文件内容</p><ul><li><p>传统思路：存储每个文件与初始版本的差异</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338587.png" /></p></li><li><p><spanclass="math inline">\(git\)</span>思路：存储项目随时间变化的快照（在本地磁盘保留项目的完整历史，以空间换时间）</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338023.png" /></p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211211134742881.png" style="zoom:40%;" /></p><ul><li><span class="math inline">\(workspace\)</span>工作目录【已修改<spanclass="math inline">\(modified\)</span>】</li><li><spanclass="math inline">\(staging\)</span>暂存区（本地不占内存）【已暂存<spanclass="math inline">\(stages\)</span>】：本质上是一个文件，保存了下次要提交的文件列表信息</li><li><span class="math inline">\(local\repository\)</span>本地仓库【已提交<spanclass="math inline">\(committed\)</span>】</li><li><span class="math inline">\(remote\ repository\)</span>远程仓库</li></ul><p><span class="math inline">\(git\)</span>工作流程</p><ul><li>在工作目录中修改某些文件</li><li>对修改后的文件进行快照，然后保存到暂存区域</li><li>提交更新，将保存在暂存区域的文件快照永久转储到Git目录中</li></ul><h4 id="基本git指令">6.7 基本Git指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git status<br>哪些更新未暂存？哪些更新已暂存？<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git diff<br>比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容（修改之后但未加入暂存）<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git diff --cached<br>比较的是暂存区域内的文件的更改（修改之后加入缓存但尚未提交）<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git diff HEAD<br>查看已缓存和未缓存的所有差异<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338492.png" style="zoom:70%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git commit -a<br>跳过git add<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git reset<br>git add的反向操作,使得暂存区与仓库版本一致<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338369.png" style="zoom:80%;" /></p><p>更改一次<span class="math inline">\(commit\)</span></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">1.git commit --amend<br>2.git reset HEAD^<br>^表示上一次提交<br></code></pre></div></td></tr></table></figure><h4 id="git远程仓库指令">6.8 Git远程仓库指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git fetch<br>从远程仓库抓取数据到本地，获取本地仓库尚未拥有的全部更新<br>如果本地仓库有了不同的修改，则需要手工将本地修改与远程仓库的修改合并起来<br>git merge<br>分支合并<br>git pull = git fetch + git merge<br></code></pre></div></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338982.png" style="zoom:70%;" /></p><h4 id="git分支指令">6.9 Git分支指令</h4><p><span class="math inline">\(git\)</span>分支本质：指向<spanclass="math inline">\(commit\)</span>对象的可变指针</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs git">git checkout -b xxx = git branch xxx + git checkout xxx<br>创建分支并跳转<br></code></pre></div></td></tr></table></figure><p><a href="https://www.cnblogs.com/techflow/p/13876755.html"><spanclass="math inline">\(git\)</span>分支</a></p><h4 id="远程分支">6.10 远程分支</h4><p>远程仓库只能看，不能修改</p><h4 id="使用git进行协同开发的实例">6.11 使用Git进行协同开发的实例</h4><h2 id="uml及建模工具">7. UML及建模工具🪂</h2><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338391.png" style="zoom:80%;" /></p><p>UML中事物：</p><ul><li>结构事物</li><li>行为事物</li><li>分组事物<ul><li>包（只存在于开发阶段）</li></ul></li><li>注释事物</li></ul><p>UML中关系：</p><ul><li><p>关联</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251338747.png" /></p></li><li><p>依赖</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339834.png" /></p></li><li><p>泛化</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339535.png" /></p></li><li><p>实现</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339262.png" /></p></li><li><p>聚合</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339198.png" /></p></li></ul><h4 id="用例图">7.1 用例图</h4><p>用例图分类：<strong>业务用例图、系统用例图</strong></p><p>用例图组成：<strong>参与者<spanclass="math inline">\(Actor\)</span>，用例<spanclass="math inline">\(Use\ Case\)</span>，关联关系<spanclass="math inline">\(Association\)</span>，包含关系<spanclass="math inline">\(Include\)</span>，扩展关系<spanclass="math inline">\(Extend\)</span>，泛化关系<spanclass="math inline">\(Generalization\)</span></strong></p><ul><li><p>参与者</p><ul><li>参与者对系统而言总是外部的</li><li>分为启动者（消费者）和支持者（商家）</li><li>参与者之间可以有泛化关系</li></ul></li><li><p>用例</p><ul><li><p>区分用例和事件流：用例处于系统的需求分析阶段，避免考虑细节性问题；事件流描述系统“做什么”，会有更多的细节，也是在需求分析阶段。</p></li><li><p>用例对应有事件流文件</p><p>举例：<strong>用例名称：学生选课</strong></p><p><strong>简要描述：把具有选课资格的某一学生加到该课程的选课名单中</strong></p><p><strong>前提条件：学生已注册，选过该课程的先导课程并获得学分</strong></p><p><strong>后置条件：如果学生具有注册资格，并且该课程仍有空位，则学生注册到该课程</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339512.png" style="zoom:60%;" /></p><p>👆🏻一个用例对应的事件流文件</p></li></ul></li><li><p>关联关系</p><ul><li>参与者与用例之间的关系</li></ul></li><li><p>包含关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211213201926513.png" style="zoom:70%;" /></p><ul><li>用户用例执行，提供者用例必须执行</li></ul></li><li><p>扩展关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339441.png" style="zoom:70%;" /></p><ul><li>没有基础用例，扩展用例也是完整的用例</li><li>基础用例被执行时，一般不会涉及扩展用例，只有特定的条件发生，扩展用例才可能被执行，这是与包含关系的差别</li></ul></li><li><p>泛化关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339556.png" style="zoom:70%;" /></p><ul><li>子用例表示父用例的特殊形式</li><li>一个用例（父用例）可以被特别地列举为一个或多个子用例</li><li>泛化关系是一般和特殊的关系</li></ul></li><li><p>用例是有粒度的，用例的粒度指的是用例所包含的系统服务或功能单元的多少。</p><ul><li>用例的粒度越大，用例包含的功能越多，反之则包含的功能越少。</li><li><strong>步骤不是用例</strong></li><li>用例识别的标准：<spanclass="math inline">\(actor\)</span>与系统之间的一次独立交互</li></ul></li><li><p>注意用例的边界</p></li><li><p>用例是<spanclass="math inline">\(actor\)</span>与系统之间的交互，<spanclass="math inline">\(actor\)</span>与<spanclass="math inline">\(actor\)</span>在现实中的交互不应包含在<spanclass="math inline">\(use\ case\)</span></p></li><li><p>注意区分<span class="math inline">\(actor\)</span>和系统</p></li><li><p>我们要开发的系统（软件）是业务组织里面的一个业务对象，系统<strong>用例就是这个业务对象对外提供的服务</strong></p></li></ul><h4 id="活动图">7.2 活动图</h4><p>活动图描述活动的顺序，展现从一个活动到另一个活动的控制流，本质是一种<strong>流程图</strong>，着重表现从一个活动到另一个活动的控制流。</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214141101491.png"  style="zoom:80%;" /></p><p>活动图元素：</p><ul><li><p>动作状态</p><p><span class="math inline">\(Action\)</span> 节点</p><p>原子（无法分解），不可中断（一旦开始，一直运行到结束），瞬时，可以有入转换，至少有一条出转换</p><p><strong>不能有</strong>入口动作和出口动作，<strong>不能有</strong>内部转移</p></li><li><p>活动状态</p><p><span class="math inline">\(Activity\)</span>节点</p><p>非原子运行（可以分解），活动状态的内部活动可以用另一个<strong>活动图</strong>来表示，可以有入口动作和出口动作，可以有内部转移</p><p><strong>动作状态是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态</strong></p></li><li><p>开始点&amp;结束点</p><p><span class="math inline">\(\bullet\)</span> 表示开始</p><p><span class="math inline">\(\bigotimes\)</span> 表示子流程结束</p><p><span class="math inline">\(\odot\)</span> 表示整个活动结束</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339185.png"  style="zoom:60%;" /></p><p>等价于：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339939.png" style="zoom:60%;" /></p></li><li><p>分支与合并</p><p><span class="math inline">\(\lozenge\)</span> 节点</p></li><li><p>分叉与汇合</p><p>分叉用将控制流分为两个或者多个<strong>并发</strong>运行的分支；汇合用于同步这些<strong>并发</strong>分支，以达到共同完成一项事务的目的</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339135.png" style="zoom:67%;" /></p></li><li><p>泳道</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339325.png" style="zoom:50%;" /></p></li><li><p>对象流</p><p>对象流是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或动作对对象的影响；可以理解为数据流</p></li></ul><p>活动图 <span class="math inline">\(VS\)</span> 状态图</p><p><strong>活动图</strong>着重表现从一个活动到另一个活动的控制流，是<strong>内部处理驱动的流程</strong>；<strong>状态图</strong>着重描述从一个状态到另一个状态的流程，主要有<strong>外部事件的参与</strong></p><p>活动图 <span class="math inline">\(VS\)</span> 流程图</p><p><strong>流程图</strong>着重描述处理过程，它的主要控制结构是顺序、分支和循环，各个处理之间有严格的顺序和时间关系；<strong>活动图</strong>描述的则是对象活动的顺序关系所遵循的规则，它着重表现的是系统的行为，而非系统的处理过程；<strong>活动图能够表示并发活动的情形，流程图不能</strong></p><h4 id="类图对象图">7.3 类图/对象图</h4><p>描述类、接口及他们之间关系的图</p><p>显示系统各个类的<strong>静态结构</strong></p><p>类图的元素</p><ul><li><p>类</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214155332101.png" style="zoom:70%;" /></p><p>类属性可见性：</p><p><span class="math inline">\(public \mapsto +\)</span></p><p><span class="math inline">\(private \mapsto -\)</span></p><p><span class="math inline">\(protected \mapsto\#\)</span></p><p><span class="math inline">\(package \mapsto\)</span> ~</p></li><li><p>接口</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214160404753.png" style="zoom:80%;" /></p></li><li><p>依赖关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339425.png" style="zoom:70%;" /></p></li><li><p>泛化关系</p><p><span class="math inline">\(is\ a\ kind\ of\)</span></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339243.png" style="zoom:60%;" /></p></li><li><p>关联关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339923.png" style="zoom:60%;" /></p><ul><li><p>关联的名称不是必需的</p></li><li><p>关联的角色</p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214161919998.png" style="zoom:60%;" /></p><ul><li>关联的多重性</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251339601.png" style="zoom:60%;" /></p><ul><li><p>聚合关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214162140753.png" style="zoom:60%;" /></p><p>整体和部分 <span class="math inline">\(has\ a\)</span></p></li><li><p>组合关系</p><p>一种特殊的聚合关系--&gt;强聚合</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340625.png" style="zoom:60%;" /></p><p><strong>成员对象的生命周期取决于聚合的生命周期</strong></p><p>聚合不仅控制着成员对象的行为，而且控制着成员对象的<strong>创建和析构</strong></p></li></ul></li><li><p>实现关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340457.png" style="zoom:80%;" /></p></li></ul><h4 id="序列图协作图">7.4 序列图/协作图</h4><p>交互图：描述系统中对象之间消息通信的图，包括：序列图，协作图</p><p>序列图用来描述系统中对象间通过消息进行交互，它强调消息在时间轴上的先后顺序：纵轴是时间轴，时间沿竖线向下延伸；横轴代表了在交互中的各独立的对象</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340272.png" style="zoom:80%;" /></p><p>序列图用来描述<strong>用例的实现</strong>，标识了消息发生交互的先后顺序，<strong>明确类的职责</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340372.png" style="zoom:70%;" /></p><p>序列图组成：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340467.png" style="zoom:70%;" /></p><ul><li><p>对象</p><p>创建对象的两种表示方法：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/image-20211214190345889.png" style="zoom:67%;" /></p><p>注销对象：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340653.png" style="zoom:67%;" /></p></li><li><p>生命线</p></li><li><p>消息</p><p>对象之间某种形式的通信；可以是<strong>信号</strong>，也可以是<strong>调用</strong>；可以用于在对象间传递参数</p><p>消息分类：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340425.png" style="zoom:67%;" /></p></li><li><p>激活</p></li></ul><p>用例图、类图，序列图关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340337.png" style="zoom:80%;" /></p><p><span class="math inline">\(BCE\)</span>模式</p><p>边界类（<spanclass="math inline">\(Boundary\)</span>）：边界类用来<strong>隔离系统内部和外部</strong>，负责接收参与者的消息</p><p>控制类（<spanclass="math inline">\(Control\)</span>）：控制类对应用例，用来控制用例执行期间的复杂运算或者业务逻辑；<strong>在分析阶段，通常针对一个用例生成一个控制类</strong></p><p>实体类（<spanclass="math inline">\(Entity\)</span>）：对应于类图中领域概念中的类；封装了数据结构和数据存储有关的类</p><p>边界类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340947.png" style="zoom:80%;" /></p><p>控制类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340254.png" style="zoom:80%;" /></p><p>实体类画法：<img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340303.png" style="zoom:80%;" /></p><p>原则：</p><ul><li>针对每一个用例，可以对应生成一个控制类</li><li>参与者对象只能跟边界对象互动</li><li>实体对象不能发送消息给边界对象和控制对象</li><li>特别情况，如只是对数据进行增加、删除、修改和查询操作也可以不设置控制对象，让边界对象直接发送消息给实体对象，以提高执行速度</li></ul><p>一个序列图可以描述多个场景</p><p>组合片段：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340021.png" style="zoom:70%;" /></p><p>操作符分类：</p><ul><li><p><spanclass="math inline">\(opt\)</span>：包含一个可能发生或可能不发生的序列，可以在临界条件中指定序列发生的条件</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251340371.png"  style="zoom:70%;" /></p></li><li><p><spanclass="math inline">\(alt\)</span>：可以在每个片段中设置一个临界条件来指示该片段可以运行的条件；else的指示其他任何临界条件都不为true时应运行的片段；如果所有临界条件都为false并且没有else，则不执行任何片段</p></li><li><p><spanclass="math inline">\(loop\)</span>：片段重复一定次数，可以在临界条件中指示片段重复的条件</p></li><li><p><spanclass="math inline">\(break\)</span>：如果执行此片段，则放弃序列的其余部分，可以使用临界来指示发生中断的条件</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342515.png" style="zoom:70%;" /></p></li><li><p><spanclass="math inline">\(par\)</span>：并行处理，片段中的事件可以交错</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342987.png" style="zoom:70%;" /></p></li><li><p><spanclass="math inline">\(critical\)</span>：指示此片段中的消息不得与其他消息交错，通常是一些原子性操作</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342038.png" style="zoom:70%;" /></p></li><li><p><spanclass="math inline">\(ref\)</span>：用来在一个交互图中，引用其他的交互图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342976.png" style="zoom:90%;" /></p></li></ul><p>协作图组成：</p><ul><li>对象</li><li>链</li><li>消息</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342783.png" style="zoom:80%;" /></p><p>序列图和协作图是等价的，可以从一种形式的图转换为另一种形式的图而不丢失任何信息</p><h4 id="状态图">7.5 状态图</h4><p>状态图主要用于描述<strong>一个对象</strong>在其生存期间的<strong>动态行为</strong>，表现为<strong>一个对象所经历的状态序列</strong>，引起状态转移的<strong>事件</strong>（<spanclass="math inline">\(Event\)</span>），以及因状态转移而伴随的<strong>动作</strong>（<spanclass="math inline">\(Action\)</span>）</p><p>状态图元素：</p><ul><li><p>状态</p><p>状态指在对象的生命周期中的某个条件或者状况；在此期间对象将满足<strong>某些条件、执行某些活动或等待某些事件</strong></p><ul><li>初始状态 <span class="math inline">\(\bullet\)</span></li><li>终止状态 <span class="math inline">\(\bigodot\)</span></li></ul></li><li><p>转移</p><p>对象在源状态中执行一定的动作，并在某个特定事件（<strong>触发事件</strong>）发生而且某个特定的<strong>警界条件</strong>满足时进入<strong>目标状态</strong>；状态可以有返回自身状态的转移（<strong>自身转移</strong>）<span class="math inline">\(\rightarrow\)</span></p></li><li><p>动作</p><p>原子操作</p></li><li><p>组合状态</p><p>含有子状态的状态</p></li><li><p>进入节点&amp;退出节点</p><p>进入节点 <spanclass="math inline">\(\bigcirc\)</span>：不需要初始化，直接通过进入节点进入状态</p><p>退出节点 <span class="math inline">\(\bigotimes\)</span>：从子状态转移到外部状态</p></li><li><p>历史状态</p><p>记住从组合状态中退出时所处的子状态</p></li><li><p>并发</p><p>组合状态在某一时刻同时到达多个子状态</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342111.png"  style="zoom:70%;" /></p></li></ul><h4 id="组件图">7.6 组件图</h4><h4 id="部署图">7.7 部署图</h4><h2 id="需求获取与分析">8.需求获取与分析🦷</h2><h4 id="软件需求与需求获取">8.1 软件需求与需求获取</h4><h5 id="软件需求的定义">8.1.1 软件需求的定义</h5><p><strong>对用户需求的管理水平是决定软件成败的重要原因</strong></p><p>需求用于表达：“做什么”，不是表达：“怎么做”</p><h5 id="需求的分类">8.1.2 需求的分类</h5><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342633.png" style="zoom:60%;" /></p><ul><li><p>业务需求</p><p>客户对于系统的高层次目标要求<span class="math inline">\(high-level\objectives\)</span>) ，定义了项目的远景和范畴(<spanclass="math inline">\(vision\ and\ scope\)</span>)</p></li><li><p>用户需求</p><p>从用户角度描述的<strong>系统功能需求与非功能需求</strong>，通常只涉及系统的<strong>外部行为</strong>而不涉及内部特性</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342566.png" style="zoom:60%;" /></p><ul><li><p>功能需求</p><p>系统应提供的功能或服务</p></li><li><p>非功能需求</p><p>对<strong>质量和性能</strong>的额外要求</p><ul><li>速度、存储空间、可用性、可靠性、容错性（一般用一些可度量的特性来描述）</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342423.png" style="zoom:60%;" /></p><ul><li><p>约束条件</p><p>法律法规、硬件/资源限制、开发语言</p></li><li><p>业务规则</p><p><strong>内部执行逻辑</strong></p><p>“如果...，那么...”</p></li><li><p>外部接口需求</p></li></ul><h5 id="好的需求与坏的需求">8.1.3 好的需求与坏的需求</h5><p>产生不合格需求的原因：</p><ul><li>无足够用户参与</li><li>用户需求的不断增加</li><li>模棱两可的需求</li><li>不必要的特性</li><li>过于精简的规格说明</li><li>忽略的用户分类</li><li>不准确的计划</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342635.png" style="zoom:70%;" /></p><h5 id="需求工程">8.1.4 需求工程</h5><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342624.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342468.png" style="zoom:65%;" /></p><h5 id="需求获取方法">8.1.5 需求获取方法</h5><p>需求获取的基本步骤：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342373.png" style="zoom:60%;" /></p><p>第1步：<strong>了解相关背景和领域/行业的知识</strong>，确定产品所期望的<strong>用户类</strong></p><p>第2步：与客户企业或组织的<strong>高层人员进行交流</strong>，了解实际用户任务和目标以及这些任务所支持的<strong>业务需求</strong></p><p>第3步：与客户企业或组织的<strong>底层人员进行交流</strong>，获取每个用户类的详细的<strong>用户需求</strong></p><p>第4步：整理需求纪要，<strong>发现新问题</strong>，并重复1-3步</p><p>第5步：<strong>需求分类和组织</strong>，以区别<strong>功能需求、非功能需求、约束条件、业务规则、外部接口需求</strong>、建议解决方法和附加信息</p><p>第6步：<strong>优先排序和冲突解决</strong></p><p>第7步：得到最终需求清单，并与客户做最终<strong>签字确认</strong></p><p>需求获取中的问题：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342857.png" style="zoom:70%;" /></p><p>需求获取技术</p><ul><li><p>收集现有纸面材料</p><ul><li>收集现有的报表、表格和过程描述</li><li>收集现有的工作流程图</li><li>分发和收集需求收集表</li></ul></li><li><p>面对面访谈</p><p>问题分类：</p><p>上下文无关问题：充分理解用户的问题，不涉及具体的解决方案</p><p>解决方案相关的问题：通过这类问题，探寻特定的解决方案并得到用户的认可</p></li><li><p>需求研讨会</p><p><span class="math inline">\(JAD\)</span>会议</p></li><li><p>现场观察/体验</p><p>被动观察：用户实地工作，需求分析人员在旁边看</p><p>主动观察：需求分析人员直接参与到用户的实际工作</p></li><li><p>头脑风暴</p></li></ul><p>对客户输入进行分类：</p><ul><li>业务需求：描述客户可以从产品中得到的<strong>资金、市场或其它业务利润的需求</strong></li><li>业务规则：一些活动只能<strong>在特定的条件下，由一些特定的人来完成时</strong>，该用户可能在描述一个业务规则</li><li>功能需求：用户应该能<spanclass="math inline">\(&lt;执行某些功能&gt;\)</span>或者系统应该<spanclass="math inline">\(&lt;具有某些行为&gt;\)</span></li><li>非功能需求</li><li>外部接口序需求：从<spanclass="math inline">\(&lt;某些设备&gt;\)</span>读取信号；给<spanclass="math inline">\(&lt;一些其他系统&gt;\)</span>发送信息；以<spanclass="math inline">\(&lt;某种格式&gt;\)</span>读取文件；能控制<spanclass="math inline">\(&lt;一些硬件&gt;\)</span></li><li>约束条件：必须使用<spanclass="math inline">\(&lt;一个特定的数据库产品或语言&gt;\)</span>；不能申请多于<spanclass="math inline">\(&lt;一定数量的内存&gt;\)</span>；操作必须与<spanclass="math inline">\(&lt;其它系统&gt;\)</span>相同；必须与<spanclass="math inline">\(&lt;其它应用程序&gt;\)</span>一致</li><li>数据定义</li></ul><h4 id="用户故事与用例建模">8.2 用户故事与用例建模</h4><h5 id="敏捷开发中的用户故事user-story">8.2.1敏捷开发中的“用户故事”（User Story）</h5><p>在敏捷开发中，需求表述为一组“用户故事”；在传统的<spanclass="math inline">\(OO\)</span>分析与设计方法中，需求被表述为一组“用例”</p><p>组成部分：卡片、交谈、确认</p><p><span class="math inline">\(As\ a\ [user\ role],I\ want\ to\[goal]\,so\ I\ can\ [reason]\ \ \ \rightarrow\ Who/What/Why\)</span></p><p>好的用户故事具备的特征： <spanclass="math inline">\(INVEST\)</span></p><p><spanclass="math inline">\(Independent、Negotiable(可讨论的)、Valuable、Estimable、Small、Testable\)</span></p><p><span class="math inline">\(TDD\)</span>：写代码前先写测试</p><h5 id="面向对象方法中的用例use-case">8.2.2 面向对象方法中的“用例”（UseCase）</h5><h5 id="用例建模的基本过程">8.2.3 用例建模的基本过程</h5><ol type="1"><li><p>识别并描述参与者（Actor）</p><p>特殊Actor：系统时钟</p></li><li><p>识别用例</p></li><li><p>识别参与者与角色之间的通讯关联（Association）</p></li><li><p>给出用例详细描述</p><p>事件流</p><ul><li>常规流</li><li>备选流（extend可以看成是备选流）</li></ul></li><li><p>细化用例模型（extend、include、泛化）</p><p>Actor之间存在泛化关系</p></li></ol><p>用例识别标准：actor与系统之间的一次独立交互</p><p>用例是actor与系统之间的交互，actor与actor在现实中的交互（讨价还价）不应包含在用例中</p><p>注意区分actor和系统，系统自己做的事情，不是独立的用例</p><h5 id="用例模型的提交物">8.2.4 用例模型的提交物</h5><h5 id="活动图-泳道图">8.2.5 活动图 &amp; 泳道图</h5><h4 id="需求的结构化分析">8.3 需求的结构化分析</h4><h5 id="结构化方法vs面向对象方法">8.3.1 结构化方法vs面向对象方法</h5><p>结构化方法：复杂世界<spanclass="math inline">\(\rightarrow\)</span>复杂处理过程（事情的发生发展），设计一系列功能解决</p><p>面向对象方法：任何系统都是由能够完成一组相关任务的对象构成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342199.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342024.png" style="zoom:65%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342738.png" style="zoom:67%;" /></p><h5 id="需求的结构化分析方法">8.3.2 需求的结构化分析方法</h5><p>结构化分析：帮助开发人员定义系统需要做什么（处理需求），系统需要存储和使用哪些数据（数据需求），系统需要什么样的输入和输出以及如何把这些功能结合在一起来完成任务</p><p>结构化分析方法：</p><ul><li>数据流图（<span class="math inline">\(DFD\)</span>）</li><li>实体-关系图（<span class="math inline">\(ERD,IDEF1X\)</span>）</li></ul><h5 id="数据流图dfd">8.3.3 数据流图（DFD）</h5><p>数据流图：用处理、外部实体、数据流以及数据存储来表示系统需求的图表</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342161.png" style="zoom:60%;" /></p><p>从外部实体发出的“数据流”可以是：1.外部实体发出的“处理请求”，即一个事件2.外部实体给出的“输入数据”</p><p>指向“外部实体”的“数据流”一般是“处理”的反馈或处理结果</p><p>DFD图可以描述高层次的具有高度概括的系统处理也可以描述低层次的具有更详细分解的系统处理</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342013.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251342258.png" style="zoom:67%;" /></p><ul><li><p>关联图：在<strong>单个处理符号</strong>中概括系统内所有处理活动的DFD</p><p><strong>关联图在表达系统边界时用处很大</strong>，系统的范围是通过单个的处理和外部实体所表示的事物来定义的；</p><p><strong>数据存储不画在关联图</strong>中是因为它本身被认为是系统内部的内容</p><p>当一个系统响应事件较多时，常常将系统分成多个子系统，并为每个子系统创建一张关联图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343220.png" style="zoom:70%;" /></p></li><li><p>DFD片段：用一个单一处理符号表示系统响应一个事件的DFD</p><p>在DFD片段中，展示了<strong>处理、外部实体和内部数据存储</strong>之间的交互细节</p><p>每个DFD片段仅显示要响应该事件的相关的那些数据存储</p><p><strong>一个DFD片段是为事件表中的每一个事件创建的</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343251.png" style="zoom:70%;" /></p></li><li><p>DFD的0层图：将一个系统或子系统的所有DFD片段组合到一个单个的DFD图中，这样的DFD图称为<strong>事件分离的系统模型/0层图</strong></p><p><strong>0层DFD图：“处理”的编号为<spanclass="math inline">\(i\)</span></strong></p></li><li><p>DFD层次：一个DFD片段中的<strong>处理</strong>也可以包含多个更小的<strong>处理</strong>，有时分析员需要将该DFD片段进一步细化，生成更详细层次的DFD图</p><p>1层DFD图：将0层DFD中的处理进一步细化等到的DFD图“处理”的编号为“<spanclass="math inline">\(i.j\)</span>”</p><p>2层DFD图：将1层DFD中的处理进一步细化等到的DFD图 “处理”的编号为“<spanclass="math inline">\(i.j.k\)</span>”</p></li></ul><p>如何画一个好的DFD图：</p><ul><li><p>最小化复杂度：采用分层结构将DFD划分为小的且相对独立的子集这样可以逐级阅读、考察DFD</p><p><strong>单个DFD图中不应有超过7±2个处理，单个DFD中不应超过7±2个数据流进出同一个处理/数据存储</strong></p><p>接口最小化：DFD中各个元素之间的连接数越少越好</p></li><li><p>保持数据流一致：</p><p><strong>一个“处理”和该“处理”被详细分解后在数据流内容上应该一致</strong></p><p><strong>对一个“处理”，有数据流入则必须有相对应的数据流出</strong></p><p><strong>对一个“处理”，有数据流出则必须有相对应的数据流入</strong></p></li><li><p><strong>黑洞</strong>：带有输入数据的但并不用其产生输出数据的处理或数据存储</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343749.png" style="zoom:50%;" /></p></li><li><p><strong>奇迹</strong>：没有足够数据元素作为输入或产生来源的一个处理或数据存储</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343727.png" style="zoom:50%;" /></p></li><li><p>典型错误：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343082.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343139.png" style="zoom:60%;" /></p></li></ul><p>在传统方法中，DFD图一般描述3种元素：处理【使用DFD】，（数据流，数据存储）【使用DD】</p><p>DFD细节描述：决策表、决策树</p><h5 id="数据字典dd">8.3.4 数据字典（DD）</h5><p>数据字典是数据分析的描述模型，包括：</p><ul><li><p>数据项定义：定义特定数据项的组成和意义</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343555.png" style="zoom:60%;" /></p></li><li><p>数据结构定义：定义有数据项组成的表达数据的基本数据</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343415.png"  style="zoom:60%;" /></p></li><li><p>数据流描述：描述数据流的数据构成，并指明其来源或去向</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343471.png" style="zoom:60%;" /></p></li><li><p>数据存储描述：描述保存在存储介质上的数据文件或数据库表的格式和内容</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343049.png" style="zoom:60%;" /></p></li><li><p>数据处理（广义DD）：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343127.png" style="zoom:60%;" /></p></li></ul><h5 id="数据分析erdidef1x">8.3.5 数据分析（ERD、IDEF1X）</h5><p>实体关系图（<span class="math inline">\(ERD\)</span>）</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343154.png"  style="zoom:80%;" /></p><p>关联实体：解决上述问题的人为增加的数据实体，它一定包含两端数据实体的关键字</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343157.png" style="zoom:80%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343885.png" style="zoom:80%;" /></p><h4 id="面向对象的分析">8.4 面向对象的分析</h4><h5 id="面向对象的分析方法概述">8.4.1 面向对象的分析方法概述</h5><p>面向对象的分析模型由三个独立模型构成（分为3个阶段）：</p><ul><li>功能模型：从用户角度获取功能需求，由<strong>用例模型</strong>表示</li><li>静态结构模型：描述系统的概念实体，由<strong>类图</strong>表示</li><li>动态结构模型：描述对象之间的交互行为，由<strong>时序图和协作图</strong>表示</li></ul><p>静态结构模型&amp;动态结构模型建立与实现技术无关的系统逻辑结构</p><h5 id="建立静态结构模型">8.4.2 建立静态结构模型</h5><p>静态结构模型</p><ul><li><p>边界类</p><p>用户界面、系统接口、设备接口</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343809.png" style="zoom:80%;" /></p></li><li><p>控制类</p><p>对用例行为的封装，一般一个用例对于一个控制类</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343423.png" style="zoom:100%;" /></p></li><li><p>实体类</p><p>“事物”</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343679.png" style="zoom:100%;" /></p><p>三种类之间是“关联”关系</p><p><strong>一个边界类</strong>可以<strong>与多个控制类</strong>相关联</p><p><strong>一个控制类</strong>可以与<strong>多个边界类</strong>相关联、与<strong>多个实体类</strong>关联</p><p><strong>一个实体类</strong>可以与<strong>多个控制类</strong>相关联</p><ul><li><p>除非系统需要在各用例中管理和维护该角色的信息(不是指ID、密码)，否则只需将其作为actor，无需作为实体类</p></li><li><p><spanclass="math inline">\(actor\)</span>自己做的动作，都是边界类的操作，与控制类和实体类无关</p></li><li><p>实体类操作分两类：</p><ol type="a"><li><p><span class="math inline">\(new()、destroy()\)</span></p></li><li><p>对该实体内部的一个或多个属性的CRUD（增删改查）操作 —<strong>是自己的属性，不是其他实体的！</strong>因此，对用例中actor所发出的每个动作，需要仔细分析它对哪些实体类的哪些属性做CRUD</p></li></ol></li></ul><p>如果操作CRUD的对象不是该实体类的属性，则说明该操作应移动到相应的实体类中。</p><p>若某操作op会CRUD多个实体类的属性，通常可以把这个操作分解为多个小粒度操作，每个小操作放在专门的实体类中，如果没办法分解，则使用控制类加以完成。</p></li></ul><p>关系：泛化、关联、组合、聚合、依赖</p><ul><li><p>分析类图：主要区分边界类、控制类、实体类</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343643.png" style="zoom:70%;" /></p></li><li><p>领域类图：主要区分泛化、关联、组合、聚合、依赖</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343837.png" style="zoom:70%;" /></p></li></ul><h5 id="建立动态行为模型">8.4.3 建立动态行为模型</h5><p>见7.4</p><h5 id="案例分析-1">8.4.4 案例分析</h5><ol type="1"><li><p>角色识别</p></li><li><p>用例识别</p></li><li><p>建立用例模型</p></li><li><p>对用例图进行精化</p><p>（针对每个用例）</p></li><li><p>撰写用例描述</p></li><li><p>绘制用例的活动（泳道）图</p></li><li><p>识别分析类（边界类、控制类、实体类）</p></li><li><p>识别每个类的属性和方法</p></li><li><p>建立分析类图</p></li><li><p>建立领域类图</p></li><li><p>建立时序图</p></li></ol><h2 id="软件设计">9.软件设计🌏</h2><h4 id="结构化设计">9.1 结构化设计</h4><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343353.png" style="zoom:70%;" /></p><p>自动化系统边界划分：将数据流图分为手工处理部分和系统能自动完成的部分</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343277.png" style="zoom:70%;" /></p><p>结构图创建方法：</p><ul><li><p>DFD片段</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343667.png" style="zoom:70%;" /></p></li><li><p>DFD分解图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343962.png" style="zoom:70%;" /></p></li><li><p>DFD重组</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251343136.png" style="zoom:70%;" /></p></li><li><p>结构图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344086.png" style="zoom:70%;" /></p></li></ul><p>变换型结构的数据流图呈一种线性状态，它所描述的工作可表示为输入、主处理及输出。</p><p>事务型结构的数据流图则呈束状，即一束数据流平行流人或流出，可能同时有几个事务要求处理。</p><p>DFD到系统结构图转换的模式：</p><ul><li>事务型</li><li>复杂变换型</li></ul><p>结构图：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344018.png" style="zoom:60%;" /></p><p><strong>三种转换</strong>【重中之重】</p><p><strong>见<span class="math inline">\(PPT\)</span></strong></p><p><a href="https://www.it610.com/article/1864147.htm">转换</a></p><h4 id="面向对象设计">9.2 面向对象设计</h4><p>结构化方法：分析阶段与设计阶段分得特别清楚，分别使用两套完全不同的建模符号和建模方法</p><p>面向对象设计（<span class="math inline">\(OOD\)</span>）：<spanclass="math inline">\(OO\)</span>各阶段均采用统一的“对象”概念，各阶段之间的区分变得不明显，形成“无缝”连接</p><p>系统设计（<strong>概要设计</strong>）<span class="math inline">\(\\rightarrow\ \)</span>对象设计（<strong>详细设计</strong>）</p><p>子系统的划分应该符合<strong>高内聚低耦合</strong>的原则</p><p>类与类之间存在的“聚合、组合、关联、依赖”关系导致包与包之间存在依赖关系，即“包的依赖”(<spanclass="math inline">\(dependency\)</span>)；类与类之间的存在的“继承”关系导致包与包之间存在继承关系，即“包的泛化”(<spanclass="math inline">\(generalization\)</span>)</p><p>对象设计基本步骤</p><ol type="1"><li>创建初始的设计类</li><li>细化属性</li><li>细化操作</li><li>定义状态</li><li>细化依赖关系</li><li>细化关联关系</li><li>细化泛化关系</li></ol><h4 id="数据库设计">9.3 数据库设计</h4><p>数据库系统 = 数据库（DB） + 数据库管理系统（DBMS）</p><p>数据库设计任务：</p><ul><li>逻辑设计：设计<span class="math inline">\(ER\)</span>模型</li><li>物理设计：在具体的数据库系统中实现<spanclass="math inline">\(ER\)</span>模型</li></ul><p>数据库<strong>逻辑模型设计</strong>：ERD图</p><p><span class="math inline">\(3NF\)</span>范式：</p><ul><li><spanclass="math inline">\(1NF\)</span>：没有重复的属性或属性组（同样的东西不能重复拥有）</li><li><span class="math inline">\(2NF\)</span>：是<spanclass="math inline">\(1NF\)</span>且每个非主属性均函数依赖于主属性（主键）（领导在，他就在，找到领导就能找到他）</li><li><span class="math inline">\(3NF\)</span> ：是<spanclass="math inline">\(2NF\)</span>且非主属性间均不存在函数依赖（领导只有一个，不能有多级领导）</li></ul><p>根据ERD设计物理数据库</p><ol type="1"><li>为每个实体创建一个二维表</li><li>为每个字段选择适当的数据类型和取值范围</li><li>定义每个表的主键</li><li>针对1：M关联关系的子表添加外键</li><li>定义完整型约束</li></ol><p>分析类图映射到ERD</p><p>本质：把<strong>每一个类，类之间的关系</strong>分别映射到一张表或多张表</p><ul><li><p>一类一表</p></li><li><p>不管是<span class="math inline">\(1\ :\ 1，1\ :\ n，m\ :\n\)</span>的关联关系，均可以：A，B分别映射为独立的数据表，然后再加入一张新表来存储二者之间的关联</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344870.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344820.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344920.png" style="zoom:67%;" /></p></li><li><p>聚合/组合关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344279.png" style="zoom:67%;" /></p></li><li><p>泛化关系</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344472.png" style="zoom:67%;" /></p></li></ul><h4 id="用户界面设计">9.4 用户界面设计</h4><ul><li><span class="math inline">\(CUI\)</span>：字符用户界面</li><li><span class="math inline">\(GUI\)</span>：图形用户界面 <spanclass="math inline">\(\rightarrow\ WIMP\)</span></li><li><span class="math inline">\(MUI\)</span>：多通道用户界面</li></ul><p>缺省设计方法：</p><ul><li>用户操作设定缺省值（也可以作为强制值输入）</li><li>经验值作为缺省值</li><li>统计方法确定出现几率大的值作为缺省值</li><li>统计方法确定出现几率大的值作为缺省值</li><li>最近使用值作为缺省值</li><li>输入数据的上下文关联缺省值</li><li>当前状态值可作为缺省值</li><li>当前状态值可作为缺省值</li><li>正常操作序列选项作为缺省值</li><li>树状隶属关系约束选项列表</li><li>智能焦点</li></ul><h2 id="软件测试">10.软件测试🍪</h2><h4 id="软件测试基础">10.1 软件测试基础</h4><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344061.png" style="zoom:60%;" /></p><p>上面的<span class="math inline">\(Venn\Diagram\)</span>可以理解测试</p><p>测试可以证明“程序有错”，不能证明“程序正确”</p><h4 id="测试过程">10.2 测试过程</h4><p>软件测试的<span class="math inline">\(V\)</span>模型</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344859.png" style="zoom:60%;" /></p><h4 id="测试方法分类">10.3 测试方法分类</h4><ul><li><p>单元测试</p><p><strong>开发人员</strong>执行</p><p>驱动模块：模仿被测模块的上一级模块</p><p>桩模块：模拟被测单元需调用的其他函数接口</p></li><li><p>集成测试</p><p>测试的对象是模块间的接口</p><ul><li><p>整体集成</p><p>将所有模块按设计要求一次全部组装起来，然后进行整体测试</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344081.png" style="zoom:60%;" /></p></li><li><p>增量集成</p><p>逐步将新模块加入并测试</p><ul><li><p>自顶向下增量集成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345446.png" style="zoom:60%;" /></p><p>深度优先：A,B,E,C,D,F</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251344771.png" style="zoom:80%;" /></p><p>广度优先：A,B,C,D,E,F</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345884.png" style="zoom:80%;" /></p><p><strong>所需桩模块巨大</strong></p><p>较少需要驱动模块</p></li><li><p>自底向下增量集成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345781.png" style="zoom:80%;" /></p><p><strong>不用桩模块</strong></p><p>难以尽早建立信心</p></li><li><p>三明治集成</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345073.png" style="zoom:60%;" /></p></li></ul></li></ul></li><li><p>确认测试</p><p>是否满足软件需求说明书中的确认标准</p></li><li><p>系统测试</p></li><li><p>验收测试</p><p>以用户为主的测试</p><p><spanclass="math inline">\(\alpha\)</span>测试：由用户在开发环境下进行的测试</p><p><spanclass="math inline">\(\beta\)</span>测试：由软件的多个用户在实际使用环境下进行测试</p></li><li><p>回归测试</p></li></ul><h4 id="黑盒测试">10.4 黑盒测试</h4><h5 id="黑盒测试概述">10.4.1 黑盒测试概述</h5><p>通常在软件接口处进行</p><p>原理：任何程序都可以看成是将输入定义域取值映射到输出值域的函数</p><p>不可能穷举所有的情况</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345324.png" style="zoom:67%;" /></p><h5 id="等价类划分方法">10.4.2 等价类划分方法</h5><p>确定等价类的六大原则</p><ul><li>在输入条件规定了取值范围或值的个数的情况下，则可以确立1个有效等价类和2个无效等价类</li><li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立1个有效等价类和1个无效等价类</li><li>在输入条件是一个布尔量的情况下，可确定1个有效等价类和1个无效等价类</li><li>在规定了输入数据的一组值(假定n个)、并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和1个无效等价类</li><li>在规定了输入数据必须遵守的规则的情况下，可确立1个有效等价类(符合规则)和n个无效等价类(从不同角度违反规则)</li><li>在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步的划分为更小的等价类</li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345728.png" style="zoom:80%;" /></p><h5 id="边界值方法">10.4.3 边界值方法</h5><p>原则</p><ul><li>如果输入条件规定了值的范围，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据</li><li>如果输入条件规定了值的个数，则用最大个数、最小个数、比最小个数少1,比最大个数多1的数据作为测试数据</li><li>将原则1和原则2应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值</li><li>如果程序的规格说明给出的输入域或输出域是有序集合，则应选取集合的第一个元素和最后一个元素作为测试用例</li><li>如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例</li><li>分析规格说明，找出其它可能的边界条件</li></ul><h4 id="白盒测试">10.5 白盒测试</h4><h5 id="白盒测试概述">10.5.1 白盒测试概述</h5><p><strong>白盒测试用例中的输入数据从程序结构导出，但期望输出务必从需求规格中导出</strong></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345499.png" style="zoom:70%;" /></p><h5 id="白盒测试的覆盖标准">10.5.2 白盒测试的覆盖标准</h5><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345445.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345190.png" style="zoom:70%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345956.png" style="zoom:80%;" /></p><ul><li><p>语句覆盖</p><p>使每条语句至少被执行一次</p></li><li><p>判定覆盖</p><p>使程序中的每个分支至少都通过一次</p></li><li><p>条件覆盖</p><p>使判定中的<strong>每个条件（不用考虑整体的结果）</strong>获得各种可能的结果</p><p><strong>条件覆盖并不能完全包含判定覆盖，也可能不包含语句覆盖</strong></p></li><li><p>判定/条件覆盖</p><p>使判定中的每个条件取得各种可能的结果，并使得每个分支取得各种可能的结果</p><p>不一定查出逻辑表达式的所有错误</p></li><li><p>条件组合覆盖</p><p>使得每个判定中多个条件的各种取值的可能组合都至少出现一次</p></li></ul><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345199.png" style="zoom:70%;" /></p><h5 id="基本路径法">10.5.3 基本路径法</h5><p>路径测试：设计足够多的测试用例，覆盖被测试对象的所有可能路径</p><p>基本路径测试：保证测试中程序的每一个基本独立路径至少执行一次</p><ol type="1"><li>程序的控制流图：描述程序控制流的一种图示方法</li><li>程序圈复杂度：<spanclass="math inline">\(McCabe\)</span>复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界</li><li>导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果</li><li>准备测试用例：确保基本路径集中的每一条路径的执行</li></ol><ul><li><p>程序流图</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345315.png" style="zoom:60%;" /></p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345807.png" style="zoom:60%;" /></p><p>如果判断中的条件表达式是由一个或多个逻辑运算符 (<spanclass="math inline">\(OR, AND, NAND, NOR\)</span>)连接的复合条件表达式，则需要改为一系列只有单条件的嵌套的判断</p><p>独立路径：一条程序执行的路径，至少包含一条在定义该路径之前的其他基本路径不曾用过得边</p><p>圈复杂度：</p><p><img src="https://raw.githubusercontent.com/fly-beep/picb/master/202204251345553.png" style="zoom:80%;" /></p><p><strong>某些独立路径不能以独立的方式被测试(即穿越路径所需的数据组合不能形成程序的正常流)；在这种情况下，这些路径必须作为另一个路径测试的一部分来进行测试</strong></p><p>“圈复杂度”表示：<strong>只要最多V(G)个测试用例就可以达到基本路径覆盖，但并非一定要设计V(G)个用例</strong></p><p>但是：<strong>测试用例越简化，代表测试越少、可能发现的错误就越少</strong></p></li></ul><h5 id="循环测试法">10.5.4 循环测试法</h5><h5 id="xunit白盒测试">10.5.5 xUnit白盒测试</h5>]]></content>
    
    
    <categories>
      
      <category>课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件过程与工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC学习</title>
    <link href="/post/1c335eca.html"/>
    <url>/post/1c335eca.html</url>
    
    <content type="html"><![CDATA[<p>本文主要对JDBC进行相关总结</p><span id="more"></span><p><spanclass="math inline">\(JDBC\)</span>是SUN公司定义的一套接口，因为每一个数据库的底层实现原理都不一样，所以需要引入这一套规范。</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251400895.png" /></p><p>首先引入依赖，可以下载对应<ahref="https://mvnrepository.com/artifact/mysql/mysql-connector-java">jar包</a>,具体步骤这里不再详说。接下来到了具体JDBC代码的编写，主要分为以下6步。</p><p><strong>1.注册驱动</strong>（告诉<spanclass="math inline">\(java\)</span>程序，即将连接的是哪个公司的数据库）</p><p>这一步最原始的写法是： <figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>    Driver driver = <span class="hljs-keyword">new</span> com.mysql.cj.jdbc.<span class="hljs-constructor">Driver()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>register<span class="hljs-constructor">Driver(<span class="hljs-params">driver</span>)</span>;<br>&#125; catch (SQLException e) &#123;<br>    e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>通过Driver类获取到JDBC驱动。而查看<code>com.mysql.cj.jdbc.Driver</code>的源码<figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.mysql.cj.jdbc;<br><br><span class="hljs-keyword">import</span> java.sql.<span class="hljs-type">DriverManager</span>;<br><span class="hljs-keyword">import</span> java.sql.<span class="hljs-type">SQLException</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-title">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>&#123;<br>    public <span class="hljs-type">Driver</span>() <span class="hljs-keyword">throws</span> <span class="hljs-type">SQLException</span> &#123;<br>    &#125;<br><br>    static &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DriverManager</span>.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-type">Driver</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">SQLException</span> var1) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>可以看到有一个静态代码块完成了<code>registerDriver</code>的工作，所以我们只需要使用反射机制即可：<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)</span>;<br>&#125; catch (ClassNotFoundException e) &#123;<br>    e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p><strong>2.获取连接</strong>（表示<spanclass="math inline">\(JVM\)</span>的进程和数据库进程之间的通道打开了，这属于进程之间的通信，比较重量级，使用完需要关闭）</p><p>这里使用如下方法进行连接的获取： <figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>get<span class="hljs-constructor">Connection(<span class="hljs-string">&quot;jdbc:mysql://ip:port/dbname&quot;</span>,<span class="hljs-params">user</span>,<span class="hljs-params">passwd</span>)</span>;<br></code></pre></div></td></tr></table></figure>比如我的ip就用本地<code>localhost</code>或者<code>127.0.0.1</code>，<code>port</code>一般使用3306，<code>dbname</code>、<code>user</code>和<code>passwd</code>根据自己的数据库修改即可。</p><p><strong>3.获取数据库对象</strong>（专门执行<spanclass="math inline">\(SQL\)</span>语句的对象）</p><p>可以使用<code>Statement</code>来获取数据库对象： <figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">Statement stmt <span class="hljs-operator">=</span> conn.createStatement()<span class="hljs-comment">;</span><br>String sql <span class="hljs-operator">=</span> <span class="hljs-string">&quot;....&quot;</span><span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure>注意这里的sql语句定义在stmt之后,如果使用<code>Statement</code>的话，可能会遇到sql注入问题，具体可以参考：<ahref="https://www.jianshu.com/p/643866408bb7">SQL注入</a>这篇博客，所以我们一般使用<code>PreparedStatement</code>获取数据库对象：<figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">String sql <span class="hljs-operator">=</span> <span class="hljs-string">&quot;....&quot;</span><span class="hljs-comment">;</span><br>PreparedStatement ps <span class="hljs-operator">=</span> conn.prepareStatement(sql)<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure> 注意这里的sql语句定义在ps之前,可以看看源码 <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">PreparedStatement</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Statement</span> &#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><code>PreparedStatement</code>继承自<code>Statement</code>，它也是一个接口。解决sql注入问题的关键在于不让用户输入的语句参与sql语句的编译过程，<code>PreparedStatement</code>的原理是预先对sql语句的框架进行预编译，然后再给sql语句传值。在sql语句里需要的值先用<code>?</code>替换，具体使用可以参见下一部分。<strong>Tips</strong>：当然这里说一句<code>Statement</code>和<code>PreparedStatement</code>各有各的用处，并不是一股脑就用<code>PreparedStatement</code>的，以下情况一般使用<code>Statement</code>：(1).业务逻辑需要sql注入；(2).需要sql语句拼接。</p><p><strong>4.执行<spanclass="math inline">\(SQL\)</span>语句</strong>（<spanclass="math inline">\(DQL，DML\)</span>）</p><p>原表</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401265.png" /></p><ul><li><p>增 <figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">String sql = <span class="hljs-string">&quot;insert into sc value(?,?,?)&quot;</span>;<br>ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>ps.set<span class="hljs-constructor">String(1,<span class="hljs-string">&quot;12345678&quot;</span>)</span>;<br>ps.set<span class="hljs-constructor">String(2,<span class="hljs-string">&quot;222&quot;</span>)</span>;<br>ps.set<span class="hljs-constructor">String(3,<span class="hljs-string">&quot;96&quot;</span>)</span>;<br><span class="hljs-built_in">int</span> count = ps.execute<span class="hljs-constructor">Update()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(count);<br></code></pre></div></td></tr></table></figure></p><p>运行结果：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401211.png" /></p><p>现在的表：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401993.png" /></p></li><li><p>删 <figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">String sql = <span class="hljs-string">&quot;delete from sc where s_id = ?&quot;</span>;<br>ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>ps.set<span class="hljs-constructor">String(1,<span class="hljs-string">&quot;12345678&quot;</span>)</span>;<br><span class="hljs-built_in">int</span> count = ps.execute<span class="hljs-constructor">Update()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(count);<br></code></pre></div></td></tr></table></figure></p><p>运行结果：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401860.png" /></p><p>现在的表：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401617.png" /></p></li><li><p>改 <figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">String sql = <span class="hljs-string">&quot;update sc set score = ? where s_id = 98020101&quot;</span>;<br>ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br>ps.set<span class="hljs-constructor">String(1,<span class="hljs-string">&quot;90&quot;</span>)</span>;<br><span class="hljs-built_in">int</span> count = ps.execute<span class="hljs-constructor">Update()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(count);<br></code></pre></div></td></tr></table></figure></p><p>运行结果：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401487.png" /></p><p>现在的表：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251401601.png" /></p></li><li><p>查 <figure class="highlight wren"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs wren"><span class="hljs-title class_">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select s_id,c_id,score from sc where score &gt; ?&quot;</span>;<br><span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-variable">conn</span>.<span class="hljs-property">prepareStatement</span>(<span class="hljs-variable">sql</span>);<br><span class="hljs-variable">ps</span>.<span class="hljs-property">setString</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;85&quot;</span>);<br><span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-variable">ps</span>.<span class="hljs-property">executeQuery</span>();<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-string">&quot;s_id<span class="hljs-char escape_">\t</span>c_id<span class="hljs-char escape_">\t</span>score&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-variable">rs</span>.<span class="hljs-property">next</span>()) &#123;<br>  <span class="hljs-title class_">String</span> <span class="hljs-variable">sid</span> <span class="hljs-operator">=</span> <span class="hljs-variable">rs</span>.<span class="hljs-property">getString</span>(<span class="hljs-string">&quot;s_id&quot;</span>);<br>  <span class="hljs-title class_">String</span> <span class="hljs-variable">cid</span> <span class="hljs-operator">=</span> <span class="hljs-variable">rs</span>.<span class="hljs-property">getString</span>(<span class="hljs-string">&quot;c_id&quot;</span>);<br>  <span class="hljs-title class_">String</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-variable">rs</span>.<span class="hljs-property">getString</span>(<span class="hljs-string">&quot;score&quot;</span>);<br>  <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">sid</span> <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\t</span>&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">cid</span> <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\t</span>&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">score</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>以下为运行结果：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251402376.png" /></p></li></ul><p><strong>5.处理查询结果集</strong>（只有执行<spanclass="math inline">\(DQL\)</span>语句后需要） <spanclass="math inline">\(DML\)</span>一语句一般返回<code>int</code>类型的量，而<spanclass="math inline">\(DQL\)</span>语句返回一个<spanclass="math inline">\(ResultSet\)</span>类型的量。 <figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">//if DML</span><br><span class="hljs-built_in">int</span> res = ps.execute<span class="hljs-constructor">Update()</span>;<br></code></pre></div></td></tr></table></figure></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">//if DQL</span><br>ResultSet rs = ps.execute<span class="hljs-constructor">Query()</span>;<br><span class="hljs-keyword">while</span> (rs.next<span class="hljs-literal">()</span>) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(1)</span>);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(2)</span>);<br>    ....<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是上面这种可能没有灵活性，所以有以下写法： <figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">//if DQL</span><br>ResultSet rs = ps.execute<span class="hljs-constructor">Query()</span>;<br><span class="hljs-keyword">while</span> (rs.next<span class="hljs-literal">()</span>) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(<span class="hljs-params">col_name1</span>)</span>);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(rs.get<span class="hljs-constructor">String(<span class="hljs-params">col_name2</span>)</span>);<br>    ....<br>&#125;<br></code></pre></div></td></tr></table></figure>上面的<code>col_name1</code>,<code>col_name2</code>都是列名，这样也更加具有灵活性。</p><p><strong>6.释放资源</strong>根据开启的顺序反向关闭<code>conn</code>，<code>ps</code>，<code>rs</code><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">if (rs != null) &#123;<br>    try &#123;<br>        rs<span class="hljs-selector-class">.close</span>();<br>    &#125; catch (SQLException e) &#123;<br>        e<span class="hljs-selector-class">.printStackTrace</span>();<br>    &#125;<br>&#125;<br>if (ps != null) &#123;<br>    try &#123;<br>        ps<span class="hljs-selector-class">.close</span>();<br>    &#125; catch (SQLException e) &#123;<br>        e<span class="hljs-selector-class">.printStackTrace</span>();<br>    &#125;<br>&#125;<br>if (conn != null) &#123;<br>    try &#123;<br>        conn<span class="hljs-selector-class">.close</span>();<br>    &#125; catch (SQLException e) &#123;<br>        e<span class="hljs-selector-class">.printStackTrace</span>();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>接下来，可以对以上内容进行封装 封装一个工具类<code>DBUtil</code><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装JDBC工具类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fly-beep</span><br><span class="hljs-comment"> */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBUtil</span> &#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取数据库连接对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 连接对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment">       */</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sct&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;333&quot;</span>);<br>         &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭各种已经建立的资源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> conn</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ps</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rs</span><br><span class="hljs-comment">       */</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Connection conn,Statement ps,ResultSet rs)</span> &#123;<br>        <span class="hljs-keyword">if</span> (rs != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ps != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ps.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>       &#125;<br>         &#125;<br>         <br></code></pre></div></td></tr></table></figure></p><p>具体使用如下： <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询以王开头的学生学号和姓名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> fly-beep</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jdbcTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            conn = DBUtil.getConnection();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select s_id,s_name from student where s_name like ?&quot;</span>;<br>            ps = conn.prepareStatement(sql);<br>            ps.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;王%&quot;</span>);<br>            rs = ps.executeQuery();<br>            System.out.println(<span class="hljs-string">&quot;s_id&quot;</span> + <span class="hljs-string">&quot;\t\t&quot;</span> + <span class="hljs-string">&quot;s_name&quot;</span>);<br>            <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>                System.out.println(rs.getString(<span class="hljs-string">&quot;s_id&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span> + rs.getString(<span class="hljs-string">&quot;s_name&quot;</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            DBUtil.close(conn,ps,rs);<br>        &#125;<br>    &#125;<br>    &#125;<br>    <br></code></pre></div></td></tr></table></figure></p><p>查询结果如下： <imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251402843.png" /></p><p>JDBC执行事务操作JDBC中的事务是自动提交的，只要执行任意一条<code>DML</code>语句，则自动提交一次。而我们可以使用conn的<code>setAutoCommit</code>函数取消这种自动提交机制。<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>    .....<br>    conn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>get<span class="hljs-constructor">Connection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/sct&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;333&quot;</span>)</span>;<br>    <span class="hljs-comment">//取消自动提交事务</span><br>    conn.set<span class="hljs-constructor">AutoCommit(<span class="hljs-params">false</span>)</span>;<br>    String sql1 = <span class="hljs-string">&quot;&quot;</span>;<br>    String sql2 = <span class="hljs-string">&quot;&quot;</span>;<br>    .....<br><br>    ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql1</span>)</span>;<br>    ps = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql2</span>)</span>;<br>    .....<br>    <br>    <span class="hljs-comment">//运行到这说明没有问题，提交事务</span><br>    conn.commit<span class="hljs-literal">()</span>;<br>&#125; catch (Exception e) &#123;<br>    <span class="hljs-keyword">if</span>(conn != null) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//回滚事务</span><br>            conn.rollback<span class="hljs-literal">()</span>;<br>        &#125; catch (SQLException ex) &#123;<br>            ex.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure> 以上即为JDBC部分的全部内容！</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postgresql安装pg_hint_plan插件</title>
    <link href="/post/72be2669.html"/>
    <url>/post/72be2669.html</url>
    
    <content type="html"><![CDATA[<p>解决postgresql安装pg_hint_plan插件的相关问题</p><span id="more"></span><p>前言：由于项目需要，我需要使用<spanclass="math inline">\(postgresql\)</span>中的pg_hint_plan插件进行相关的分析，但是在安装中网上却并未找到很有效的相关资料，现总结如下：</p><p>本机配置： <span class="math inline">\(CentOs\ 7.6\)</span></p><h2 id="安装postgresql">安装<spanclass="math inline">\(postgresql\)</span></h2><p>参考<ahref="https://www.postgresql.org/download/linux/redhat/">官网</a>上的描述，主要使用以下代码：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo yum install -y https:<span class="hljs-regexp">//</span>download.postgresql.org<span class="hljs-regexp">/pub/</span>repos<span class="hljs-regexp">/yum/</span>reporpms<span class="hljs-regexp">/EL-7-x86_64/</span>pgdg-redhat-repo-latest.noarch.rpm<br>sudo yum install -y postgresql14-server<br>sudo <span class="hljs-regexp">/usr/</span>pgsql-<span class="hljs-number">14</span><span class="hljs-regexp">/bin/</span>postgresql-<span class="hljs-number">14</span>-setup initdb<br>sudo systemctl enable postgresql-<span class="hljs-number">14</span><br>sudo systemctl start postgresql-<span class="hljs-number">14</span><br></code></pre></div></td></tr></table></figure><p>初始化数据库： <figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/usr/</span>pgsql-<span class="hljs-number">14</span><span class="hljs-regexp">/bin/</span>postgresql-<span class="hljs-number">14</span>-setup initdb<br></code></pre></div></td></tr></table></figure></p><p>设置开机启动： <figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">sudo systemctl <span class="hljs-built_in">enable</span> postgresql-14<br></code></pre></div></td></tr></table></figure></p><p>启动postgresql服务 <figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> systemctl start postgresql-<span class="hljs-number">14</span><br></code></pre></div></td></tr></table></figure></p><p>设置数据库密码 <figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">su postgres<br>psql<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> postgres <span class="hljs-keyword">with</span> <span class="hljs-keyword">password</span> <span class="hljs-string">&#x27;yourpwd&#x27;</span><br></code></pre></div></td></tr></table></figure></p><p>开启远程访问 <figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">vi <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/pgsql/</span><span class="hljs-number">14</span><span class="hljs-regexp">/data/</span>postgresql.conf<br></code></pre></div></td></tr></table></figure></p><p>找到下面的listen_address: <figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">listen_address</span> = <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></div></td></tr></table></figure></p><p>增加信任连接 <figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">vi /var/lib/pgsql/<span class="hljs-number">14</span>/data/pg_hba.conf<br></code></pre></div></td></tr></table></figure></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># IPv4 local connections:</span><br><span class="hljs-attribute">host</span>    <span class="hljs-literal">all</span>             <span class="hljs-literal">all</span>             <span class="hljs-number">0.0.0.0</span>/<span class="hljs-number">0</span>               trust<br></code></pre></div></td></tr></table></figure><p>重启服务 <figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">systemctl</span> restart postgresql-<span class="hljs-number">14</span><br></code></pre></div></td></tr></table></figure></p><p>添加端口号并重启防火墙 <figure class="highlight brainfuck"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">zone=public</span> <span class="hljs-literal">--</span><span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">port=5432/tcp</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanent</span><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">reload</span><br></code></pre></div></td></tr></table></figure></p><p>这时候可以检查一下： <figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">rpm -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> postgresql<br></code></pre></div></td></tr></table></figure></p><p>命令行会输出以下信息： <figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">postgresql14</span>-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-libs-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-server-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br></code></pre></div></td></tr></table></figure></p><p>并且保证此时在root的权限下直接输入： <figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">su postgres</span><br></code></pre></div></td></tr></table></figure></p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">su postgres</span><br></code></pre></div></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">psql</span><br></code></pre></div></td></tr></table></figure><p>此时可以成功打开postgres即可！</p><h2 id="安装postgresql-devel">安装<spanclass="math inline">\(postgresql-devel\)</span></h2><p>这一步可以说是最坑的了，因为一般安装postgresql时只会安装<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">postgresql14</span>-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-libs-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-server-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br></code></pre></div></td></tr></table></figure></p><p>这三个包，但是这时的postgresql是<strong>没有C/C++环境</strong>的，而我们如果想要安装pg_hint_plan的话是需要的，所以我们需要安装<spanclass="math inline">\(postgresql-devel\)</span>。</p><p>直接运行： <figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> postgresql14-devel<br></code></pre></div></td></tr></table></figure></p><p>这时输入： <figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">rpm -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> postgresql<br></code></pre></div></td></tr></table></figure></p><p>命令行会输出以下信息： <figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">postgresql14</span>-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-libs-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-devel-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br><span class="hljs-attribute">postgresql14</span>-server-<span class="hljs-number">14</span>.<span class="hljs-number">2</span>-<span class="hljs-number">1</span>PGDG.rhel7.x86_64<br></code></pre></div></td></tr></table></figure></p><h2 id="安装pg_hint_plan插件">安装pg_hint_plan插件</h2><p>从<ahref="https://github.com/ossc-db/pg_hint_plan/tags">官网</a>按照对应PG14版本的pg_hint_plan的<spanclass="math inline">\(.tar.gz\)</span>文件。</p><p>我下载的是pg_hint_plan-REL14_1_4_0.tar.gz</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">tar -zxvf pg_hint_plan-REL14_1_4_0.tar.gz<br>make<br>make install<br></code></pre></div></td></tr></table></figure><p>但是这时会遇到另一个坑了，以上代码是作者写在<spanclass="math inline">\(README.md\)</span>中的下载方法，但是这时你需要设置路径，所以应该执行以下代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">tar -zxvf pg_hint_plan-REL14_1_4_0.tar.gz<br>export <span class="hljs-type">PATH</span>=&quot;$PATH:/usr/pgsql-14/bin&quot;<br>make<br>make install<br></code></pre></div></td></tr></table></figure><p>这时就没问题了！</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/202204251402401.png" /></p><hr /><p>参考链接：</p><ul><li><ahref="https://www.postgresql.org/download/linux/redhat/">https://www.postgresql.org/download/linux/redhat/</a></li><li><ahref="https://centos.pkgs.org/7/postgresql-14-aarch64/postgresql14-devel-14.2-1PGDG.rhel7.aarch64.rpm.html">https://centos.pkgs.org/7/postgresql-14-aarch64/postgresql14-devel-14.2-1PGDG.rhel7.aarch64.rpm.html</a></li><li><ahref="https://stackoverflow.com/questions/4293111/postgresql-pg-config-bash-pg-config-command-not-found">https://stackoverflow.com/questions/4293111/postgresql-pg-config-bash-pg-config-command-not-found</a></li><li><ahref="https://github.com/ossc-db/pg_hint_plan/tags">https://github.com/ossc-db/pg_hint_plan/tags</a></li><li><ahref="https://github.com/ossc-db/pg_hint_plan/issues/57">https://github.com/ossc-db/pg_hint_plan/issues/57</a></li><li><ahref="https://osdn.net/projects/pghintplan/howto/install">https://osdn.net/projects/pghintplan/howto/install</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/post/63785.html"/>
    <url>/post/63785.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇文章">第一篇文章</h1><p>写这篇文章主要是要警示自己：<strong>绝知此事要躬行</strong><span id="more"></span></p><hr /><p>下面放一些自己喜欢的句子：</p><hr /><p>苦难既然把我推到了悬崖的边缘，那么就让我在这悬崖边坐下来，顺便看看悬崖下的流岚雾霭，唱支歌给你听。</p><hr /><p>酒一杯，敬温华不练剑，</p><p>酒二杯，敬李淳罡为后辈开山，</p><p>酒三杯，敬曹官子一人攻城，</p><p>酒四杯，敬黄三甲为万世开太平，</p><p>酒五杯，敬李义山为北凉谋生路，</p><p>酒六杯，敬洪洗象为红颜修正道，</p><p>酒七杯，敬李玉斧为后世关天门，</p><p>酒八杯，敬徐凤年为中原百姓守国门，</p><p>酒九杯，敬中原宗师拒北城悍然赴死。</p><hr /><p>最后，Saber镇站：</p><p><imgsrc="https://raw.githubusercontent.com/fly-beep/picb/master/Saber.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>纪念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
